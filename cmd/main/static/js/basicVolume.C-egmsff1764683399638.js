import{F as e,_ as r,K as a}from"./@tresjs.CJvYCGUA1764683399638.js";import{P as n}from"./tweakpane.CqZAnw7f1764683399638.js";import{d as t,a as o,r as i,w as l,q as s,G as c,o as u,I as v,u as m,b as _,h as p,v as d,f as g,e as x,a9 as f,aa as h,ah as y,m as b,F as S}from"./@vue.DjQnunkc1764683399638.js";import{C as z,V as w,dS as j,c8 as V,r as D,aE as k}from"./three.BbguFgn81764683399638.js";import{_ as M}from"./@fesjs.CQdxRiFD1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";const P=["rotation-x"],O=["uniforms","vertexShader","fragmentShader"],B=41,F=t({__name:"basicVolumeRendering",setup(a){const t=window.innerWidth,_=window.innerHeight,p=o(null),d=o(null),g=new z;g.start();const x=(new n).addFolder({title:"Display Settings"}),f=x.addFolder({title:"Cross Section Settings"}),h=new w(.5,.5,.5);f.addBinding(h,"x",{label:"X",min:.02,max:.5,step:.02}),f.addBinding(h,"y",{label:"Y",min:.02,max:.5,step:.02}),f.addBinding(h,"z",{label:"Z",min:.02,max:.5,step:.02}),f.expanded=!0;const{camera:y}=e(),b=i({u_camera:{value:y.value?.position},u_resolution:{value:new w(t,_,1)},u_dt:{value:.004},u_time:{value:0},u_crossSectionSize:{value:h},u_color:{value:1},u_volume:{value:null},u_isoValue:{value:.2},u_alphaVal:{value:.2}}),S=x.addFolder({title:"Algorithm Settings"});S.addBinding(b.u_dt,"value",{label:"dt",min:4e-4,max:.016,step:2e-4}),S.addBinding(b.u_color,"value",{label:"color",min:1,max:3,step:1}),S.addBinding(b.u_alphaVal,"value",{label:"alphaVal",min:.01,max:1,step:.01}),S.addBinding(b.u_isoValue,"value",{label:"isoValue",min:0,max:1,step:.04}),l(d,e=>{if(e){const r=new j(e,B,B,B);r.format=V,r.minFilter=D,r.magFilter=D,r.wrapT=k,r.needsUpdate=!0,b.u_volume.value=r}});const{onBeforeRender:M}=r();return M(()=>{b.u_time.value=g.getElapsedTime()}),s(()=>{fetch("/plugins/volumeRendering/image/nucleon_41x41x41_uint8.raw").then(e=>e.arrayBuffer()).then(e=>{const r=new Uint8Array(e),a=new Uint8Array(68921);for(let n=0;n<r.length;n++)a[n]=r[n];d.value=a}).catch(e=>{console.error("Error fetching volume data:",e)})}),(e,r)=>(u(),c("TresMesh",{ref_key:"meshRef",ref:p,"rotation-x":Math.PI/-2},[r[0]||(r[0]=v("TresSphereGeometry",{args:[1,16,16]},null,-1)),v("TresShaderMaterial",{uniforms:b,vertexShader:m("precision mediump float;\n\nuniform vec3 u_camera;\r\nuniform vec3 u_resolution;\r\nuniform float u_time;\n\nvarying vec3 v_hitPos;\r\nvarying vec3 v_hitPosWorldSpace;\r\nvarying vec3 v_cameraObjectSpace;\n\nvoid main() {\r\n  vec3 pos = position;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n\n  v_hitPos = position.xyz;\n\n  v_hitPosWorldSpace = (modelMatrix * vec4(position, 1.0)).xyz;\n\n  v_cameraObjectSpace = (inverse(modelMatrix) * vec4(u_camera, 1.0)).xyz;\r\n}"),fragmentShader:m("precision mediump int;\r\nprecision mediump float;\n\nuniform vec3 u_camera;\r\nuniform vec3 u_resolution;\r\nuniform mediump sampler3D u_volume;\r\nuniform vec3 u_crossSectionSize;\r\nuniform float u_dt;\r\nuniform float u_time;\r\nuniform float u_color;\r\nuniform float u_isoValue;\r\nuniform float u_alphaVal;\n\nvec3 palette(in float t) {\r\n  vec3 a = vec3(0.5, 0.5, 0.5);\r\n  vec3 b = vec3(0.5, 0.5, 0.5);\r\n  vec3 c = vec3(1.0, 1.0, 1.0);\r\n  vec3 d = vec3(0.00, 0.33, 0.67);\n\n  return a + b * cos(6.28318 * (c * t + d));\r\n}\n\nvarying vec3 v_hitPos;\r\nvarying vec3 v_hitPosWorldSpace;\r\nvarying vec3 v_cameraObjectSpace;\n\nvec2 intersect_box(vec3 orig, vec3 dir) {\n\n  vec3 box_min = vec3(-u_crossSectionSize);\r\n  vec3 box_max = vec3(u_crossSectionSize);\r\n  vec3 inv_dir = 1.0 / dir;\r\n  vec3 tmin_tmp = (box_min - orig) * inv_dir;\r\n  vec3 tmax_tmp = (box_max - orig) * inv_dir;\r\n  vec3 tmin = min(tmin_tmp, tmax_tmp);\r\n  vec3 tmax = max(tmin_tmp, tmax_tmp);\r\n  float t0 = max(tmin.x, max(tmin.y, tmin.z));\r\n  float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n  return vec2(t0, t1);\r\n}\n\nvoid main() {\r\n  vec3 rayOrigin = vec3(0.0, 0.0, -3.0);\r\n  rayOrigin = v_cameraObjectSpace;\n\n  vec2 uv = 2.0 * gl_FragCoord.xy / u_resolution.xy - 1.0;\r\n  vec3 rayDir = normalize(vec3(uv, 1.0));\r\n  rayDir = normalize(v_hitPos - rayOrigin);\n\n  vec2 t_hit = intersect_box(rayOrigin, rayDir);\r\n  if (t_hit.x > t_hit.y) {\r\n    discard;\r\n  }\n\n  t_hit.x = max(t_hit.x, 0.0);\n\n  float dt = u_dt;\n\n  vec4 color = vec4(0.0);\n\n  vec3 p = rayOrigin + t_hit.x * rayDir + 0.5;\r\n  for (float t = t_hit.x; t < t_hit.y; t += dt) {\n\n    float textureVal = texture(u_volume, p).r;\n\n    vec4 val_color = vec4(0.0);\r\n    float val_color_alpha = textureVal * 0.1;\n\n    val_color_alpha = smoothstep(0.0, u_alphaVal, val_color_alpha);\n\n    vec3 red = vec3(1.0, 0.0, 0.0);\r\n    vec3 white = vec3(1.0);\r\n    if (abs(u_color - 1.0) <= 0.01) {\r\n      val_color = vec4(white, val_color_alpha);\r\n    } else if (abs(u_color - 2.0) <= 0.01) {\r\n      val_color = vec4(mix(red, white, val_color_alpha), val_color_alpha);\r\n    } else {\r\n      val_color = vec4(palette(textureVal), val_color_alpha);\r\n    }\n\n    color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;\r\n    color.a += (1.0 - color.a) * val_color.a;\n\n    if (textureVal > u_isoValue) {\r\n      float gxLess = texture(u_volume, vec3(p.x - rayDir.x * u_dt, p.y, p.z)).r;\r\n      float gxMore = texture(u_volume, vec3(p.x + rayDir.x * u_dt, p.y, p.z)).r;\r\n      float dgx = gxMore - gxLess;\n\n      float gyLess = texture(u_volume, vec3(p.x, p.y - rayDir.y * u_dt, p.z)).r;\r\n      float gyMore = texture(u_volume, vec3(p.x, p.y + rayDir.y * u_dt, p.z)).r;\r\n      float dgy = gyMore - gyLess;\n\n      float gzLess = texture(u_volume, vec3(p.x, p.y, p.z - rayDir.z * u_dt)).r;\r\n      float gzMore = texture(u_volume, vec3(p.x, p.y, p.z + rayDir.z * u_dt)).r;\r\n      float dgz = gzMore - gzLess;\r\n      vec3 n = normalize(vec3(dgx, dgy, dgz));\n\n      vec3 lightSource = vec3(1.0);\r\n      vec3 lightDir = normalize(lightSource);\r\n      float diffuseStrength = max(dot(n, lightDir), 0.0);\n\n      vec3 viewSource = normalize(rayOrigin);\r\n      vec3 reflectSource = normalize(reflect(-lightSource, n));\r\n      float specularStrength = max(0.0, dot(viewSource, reflectSource));\r\n      specularStrength = pow(specularStrength, 64.0);\n\n      color.rgb = diffuseStrength * val_color.rgb + specularStrength * val_color.rgb;\r\n      color.rgb *= val_color.rgb;\r\n      color.a = 0.95;\r\n      break;\r\n    }\n\n    if (color.a >= 0.95) {\r\n      break;\r\n    }\n\n    p += rayDir * dt;\r\n  }\n\n  gl_FragColor = color;\r\n}")},null,8,O)],8,P))}}),T=M(t({__name:"basicVolume",setup(e){const r=i({windowSize:!0,alpha:!0,antialias:!0,clearAlpha:0,disableRender:!0}),n=i({enableDamping:!0,enableZoom:!0,enablePan:!0,enableRotate:!0,makeDefault:!0});return(e,t)=>{const o=_("TresCanvas");return u(),c(S,null,[t[3]||(t[3]=v("div",{class:"info"},[v("a",{href:"https://klacansky.com/open-scivis-datasets/skull/skull_256x256x256_uint8.raw",target:"_blank"}," https://klacansky.com/open-scivis-datasets/skull/skull_256x256x256_uint8.raw "),v("br"),d(" 请自行下载数据集, 复制到 /plugins/volumeRendering/image/skull_256x256x256_uint8.raw 并更改文件请求指向和 dim 大小 ")],-1)),p(o,b({clearColor:"#201919"},r),{default:g(()=>[t[0]||(t[0]=v("TresPerspectiveCamera",{fov:75,near:.001,far:1e3,position:[-1,.4,-1],"look-at":[0,0,0],up:[0,1,0]},null,-1)),t[1]||(t[1]=v("TresAmbientLight",{intensity:2},null,-1)),p(m(a),f(h(n)),null,16),(u(),x(y,null,{default:g(()=>[p(F,{position:[0,0,0]})]),_:1})),t[2]||(t[2]=v("TresGridHelper",{args:[50,50],position:[0,-5,0]},null,-1))]),_:1},16)],64)}}}),[["__scopeId","data-v-1dd77311"]]);export{T as default};
