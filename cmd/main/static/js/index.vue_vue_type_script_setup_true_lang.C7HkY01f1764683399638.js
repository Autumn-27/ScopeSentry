import{C as n}from"./index.DM693cYN1764683399638.js";import{d as e,a3 as o,G as r,o as t,u as c}from"./@vue.DjQnunkc1764683399638.js";import{ar as a}from"./three.BbguFgn81764683399638.js";const l=["object"],s=e({__name:"index",props:{color:{default:"#ff00fc"},metalness:{default:1},roughness:{default:1},clearcoat:{default:1},clearcoatRoughness:{default:0}},setup(e){const s=e,v={baseMaterial:a,metalness:s.metalness,roughness:s.roughness,clearcoat:s.clearcoat,clearcoatRoughness:s.clearcoatRoughness,color:s.color,vertexShader:"\n\t\t\tvarying vec3 csm_vPosition;\n\t\t\tvarying vec3 csm_vWorldNormal;\n\t\t\tvarying vec3 csm_vWorldViewDirection;\n\t\t\tvarying vec4 csm_vGlPosition;\n\n\t\t\tvoid main() {\n\t\t\t\t\tcsm_vWorldNormal = normalize((modelMatrix * vec4(normal.xyz, 0.0)).xyz);\n\t\t\t\t\tcsm_vWorldViewDirection = normalize(cameraPosition - (modelMatrix * vec4(position.xyz, 0.0)).xyz) ;\n\n\t\t\t\t\tcsm_vGlPosition = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t\tcsm_vPosition = position;\n\t\t\t}",fragmentShader:"\n\t\t\tconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\r\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\r\n  uv *= myt;\r\n  uv *= mys;\r\n  return fract(fract(uv / mys) * uv);\r\n}\n\nvec3 hash(vec3 p) {\r\n  return fract(\r\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\r\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\r\n      43758.5453);\r\n}\n\nfloat mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\r\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\r\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat floatHash(vec3 p) {\r\n  vec3 a = floor(p);\r\n  vec3 d = p - a;\r\n  d = d * d * (3.0 - 2.0 * d);\n\n  vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\r\n  vec4 k1 = perm(b.xyxy);\r\n  vec4 k2 = perm(k1.xyxy + b.zzww);\n\n  vec4 c = k2 + a.zzzz;\r\n  vec4 k3 = perm(c);\r\n  vec4 k4 = perm(c + 1.0);\n\n  vec4 o1 = fract(k3 * (1.0 / 41.0));\r\n  vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n  vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\r\n  vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n  return o4.y * d.y + o4.x * (1.0 - d.y);\r\n}\n\nvec2 voronoi3d(vec3 pos) {\r\n  vec3 baseCell = floor(pos);\n\n  float minDistToCell = 10.0;\r\n  vec3 closestCell;\r\n  for (int x = -1; x <= 1; x++) {\r\n    for (int y = -1; y <= 1; y++) {\r\n      for (int z = -1; z <= 1; z++) {\r\n        vec3 cell = baseCell + vec3(float(x), float(y), float(z));\r\n        vec3 cellPosition = cell + hash(cell);\r\n        vec3 toCell = cellPosition - pos;\r\n        float distToCell = length(toCell);\r\n        if (distToCell < minDistToCell) {\r\n          minDistToCell = distToCell;\r\n          closestCell = cell;\r\n        }\r\n      }\r\n    }\r\n  }\n\n  float random = floatHash(closestCell);\r\n  return vec2(minDistToCell, random);\r\n}\n      vec4 permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\r\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\r\nvec3 fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\nfloat pnoise(vec3 P) {\r\n  vec3 Pi0 = floor(P);        \n  vec3 Pi1 = Pi0 + vec3(1.0); \n  Pi0 = mod(Pi0, 289.0);\r\n  Pi1 = mod(Pi1, 289.0);\r\n  vec3 Pf0 = fract(P);        \n  vec3 Pf1 = Pf0 - vec3(1.0); \n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\r\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\r\n  vec4 iz0 = Pi0.zzzz;\r\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\r\n  vec4 ixy0 = permute(ixy + iz0);\r\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\r\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\r\n  gx0 = fract(gx0);\r\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\r\n  vec4 sz0 = step(gz0, vec4(0.0));\r\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\r\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\r\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\r\n  gx1 = fract(gx1);\r\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\r\n  vec4 sz1 = step(gz1, vec4(0.0));\r\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\r\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\r\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\r\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\r\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\r\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\r\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\r\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\r\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(\r\n      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\r\n  g000 *= norm0.x;\r\n  g010 *= norm0.y;\r\n  g100 *= norm0.z;\r\n  g110 *= norm0.w;\r\n  vec4 norm1 = taylorInvSqrt(\r\n      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\r\n  g001 *= norm1.x;\r\n  g011 *= norm1.y;\r\n  g101 *= norm1.z;\r\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\r\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\r\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\r\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\r\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\r\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\r\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\r\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\r\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),\r\n                 fade_xyz.z);\r\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\r\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\r\n  return 2.2 * n_xyz;\r\n}\n\t\t\tvarying vec3 csm_vPosition;\n\t\t\tvarying vec3 csm_vWorldNormal;\n\t\t\tvarying vec3 csm_vWorldViewDirection;\n\t\t\tvarying vec4 csm_vGlPosition;\n\n      uniform vec3 uFleckColor;\n\n      const float fresnel_Power = 1.0;\n\n      float fresnel() {\n          return pow(1.0 - dot(csm_vWorldNormal, csm_vWorldViewDirection), fresnel_Power);\n      }\n\n      float mapLinear(float x, float a1, float a2, float b1, float b2) {\n          return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n      }\n\n      void main() {\n      // Fresnel\n      float fresnelFactor = fresnel();\n\n      // Fleck\n      float fleckFactor = voronoi3d(csm_vPosition * 2000.0).y;\n      float fleckFactorY = voronoi3d(csm_vPosition * 2000.0 + 100.0).y;\n      float fleckFactorZ = voronoi3d(csm_vPosition * 2000.0 + 200.0).y;\n\n      // Distance from camera\n      float normalizedDist = csm_vGlPosition.z / csm_vGlPosition.w;\n      normalizedDist = smoothstep(0.6, 1.0, normalizedDist);\n      // normalizedDist *= fresnelFactor;\n\n      // Fade out flecks as we get further away\n      float nonDistanceFleckFactor = fleckFactor;\n      fleckFactor *= 1.0 - normalizedDist;\n\n      // Diffuse\n      float diffuseFactor = csm_DiffuseColor.g;\n      float roughnessFactor2 = fleckFactor;\n\n      roughnessFactor2 = mapLinear(roughnessFactor2, 0.0, 1.0, 0.4, 0.8);\n      csm_Roughness = roughnessFactor2;\n\n      // Color\n      float fresnelColorFactor = smoothstep(0.0, 1.0, clamp(fresnelFactor, 0.0, 0.4));\n      vec3 fresnelColor = mix(csm_DiffuseColor.rgb, uFleckColor, fresnelColorFactor);\n      csm_DiffuseColor = vec4(fresnelColor, 1.0);\n\n      float fleckColorFactor = smoothstep(0.99, 0.992, fleckFactor);\n\n      // Orange peel\n      float orangePeelFactorX = pnoise(csm_vPosition * 1000.0);\n      float orangePeelFactorY = pnoise(csm_vPosition * 1000.0 + 100.0);\n      float orangePeelFactorZ = pnoise(csm_vPosition * 1000.0 + 200.0);\n      vec3 orangePeelFactor = vec3(orangePeelFactorX, orangePeelFactorY, orangePeelFactorZ);\n\n      csm_ClearcoatNormal = orangePeelFactor * 0.01 * (1.0 - normalizedDist);\n      // csm_Clearcoat = 10.0;\n      // csm_ClearcoatRoughness = 0.0;\n\n      csm_Bump = vec3(fleckFactor, fleckFactorY, fleckFactorZ) * 1.0 * (1.0 - normalizedDist);\n      }\n\t\t"},i=new n(v);return o(()=>{i.color.setStyle(s.color),i.metalness=s.metalness,i.roughness=s.roughness,i.clearcoat=s.clearcoat,i.clearcoatRoughness=s.clearcoatRoughness}),(n,e)=>(t(),r("primitive",{object:c(i)},null,8,l))}});export{s as _};
