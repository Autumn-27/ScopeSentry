import{k as e,bJ as n,ad as o,A as a,d7 as r,j as t}from"./three.BbguFgn81764683399638.js";import{L as s,V as i,K as l}from"./@tresjs.CJvYCGUA1764683399638.js";import{d as u,a as m,w as d,b as c,G as v,o as h,h as p,u as f,f as w,I as g,a9 as P,aa as M,m as b,F as C}from"./@vue.DjQnunkc1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";const y=["position","a-scale","color","a-randomness"],x=u({__name:"galaxy",setup(u){const x={clearColor:"black",shadows:!0,alpha:!1,shadowMapType:r,outputColorSpace:a,toneMapping:o,windowSize:!0},z={count:3e4,size:20,radius:5,branches:5,spin:4,randomness:.13,randomnessPower:7.5,insideColor:"#b5f28d",outsideColor:"#1b3984"},T=new e(z.insideColor),A=new e(z.outsideColor),S=new Float32Array(3*z.count),j=new Float32Array(3*z.count),F=new Float32Array(z.count),_=new Float32Array(3*z.count);for(let e=0;e<z.count;e++){const n=3*e,o=Math.random()*z.radius,a=e%z.branches*Math.PI*2/z.branches;S[n]=Math.cos(a)*o,S[n+1]=0,S[n+2]=Math.sin(a)*o;const r=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),t=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),s=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);_[n]=r,_[n+1]=t,_[n+2]=s;const i=T.clone();i.lerp(A,o/z.radius),j[n+0]=i.r,j[n+1]=i.g,j[n+2]=i.b,F[e]=Math.random()}const k={transparent:!0,depthWrite:!1,blending:n,vertexColors:!0,vertexShader:"uniform float uSize;\r\nuniform float uTime;\n\nattribute float aScale;\r\nattribute vec3 aRandomness;\n\nvarying vec3 vColor;\n\nvoid main() {\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n    \n    float angle = atan(modelPosition.x, modelPosition.z);\r\n    float distanceToCenter = length(modelPosition.xz);\r\n    float angleOffset = (1.0 / distanceToCenter) * uTime * 0.2;\r\n    angle += angleOffset;\n\n    modelPosition.x = distanceToCenter * cos(angle);\r\n    modelPosition.z = distanceToCenter * sin(angle);\n\n    \n    modelPosition.xyz += aRandomness;\n\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n    gl_Position = projectedPosition;\n\n    gl_PointSize = uSize * aScale;\n\n    \n    gl_PointSize *= ( 1.0 / - viewPosition.z);\n\n    \n    vColor = color;\n\n}",fragmentShader:"varying vec3 vColor;\n\nvoid main()\r\n{\r\n    \n    float strength = distance(gl_PointCoord, vec2(0.5));\r\n    strength = 1.0 - strength;\r\n    strength = pow(strength, 5.0);\n\n    \n    vec3 color = mix(vec3(0.0), vColor, strength);\r\n    gl_FragColor = vec4(color, 1.0);\r\n}",uniforms:{uTime:{value:0},uSize:{value:z.size}}};const R=m(null),I=({elapsed:e})=>{R.value&&(R.value.material.uniforms.uTime.value=e)},{count:O,size:G,radius:L,branches:B,spin:E,randomness:J,randomnessPower:K,insideColor:V,outsideColor:W}=s({count:{value:3e4,min:0,max:1e5,step:1},size:{value:20,min:.01,max:40,step:1},radius:{value:5,min:.1,max:20,step:.01},branches:{value:5,min:2,max:10,step:1},spin:{value:4,min:-5,max:5,step:.01},randomness:{value:.13,min:.1,max:.2,step:.01},randomnessPower:{value:7.5,min:1,max:10,step:.001},insideColor:"#b5f28d",outsideColor:"#1b3984"});return d([O.value,G.value,L.value,B.value,E.value,J.value,K.value,V.value,W.value],n=>{n.forEach((e,n)=>{z[Object.keys(z)[n]]=e.value}),function(){if(R.value){const n=new e(z.insideColor),o=new e(z.outsideColor),a=new Float32Array(3*z.count),r=new Float32Array(3*z.count),s=new Float32Array(z.count),i=new Float32Array(3*z.count);for(let e=0;e<z.count;e++){const t=3*e,l=Math.random()*z.radius,u=e%z.branches*Math.PI*2/z.branches;a[t]=Math.cos(u)*l,a[t+1]=0,a[t+2]=Math.sin(u)*l;const m=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),d=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1),c=Math.random()**z.randomnessPower*(Math.random()<.5?-1:1);i[t]=m,i[t+1]=d,i[t+2]=c;const v=n.clone();v.lerp(o,l/z.radius),r[t+0]=v.r,r[t+1]=v.g,r[t+2]=v.b,s[e]=Math.random()}R.value.geometry.setAttribute("position",new t(a,3)),R.value.geometry.setAttribute("aRandomness",new t(i,3)),R.value.geometry.setAttribute("color",new t(r,3)),R.value.geometry.setAttribute("aScale",new t(s,1))}}()}),(e,n)=>{const o=c("TresCanvas");return h(),v(C,null,[p(f(i)),p(o,b(x,{onLoop:I}),{default:w(()=>[n[0]||(n[0]=g("TresPerspectiveCamera",{position:[3,3,3]},null,-1)),g("TresPoints",{ref_key:"bufferRef",ref:R},[g("TresBufferGeometry",{position:[f(S),3],"a-scale":[f(F),1],color:[f(j),3],"a-randomness":[f(_),3]},null,8,y),g("TresShaderMaterial",P(M(k)),null,16)],512),p(f(l))]),_:1},16)],64)}}});export{x as default};
