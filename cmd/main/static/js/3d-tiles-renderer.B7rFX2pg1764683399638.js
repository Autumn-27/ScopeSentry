import{V as t,M as e,S as s,R as i,E as n,a as r,b as o,e as a,B as l,P as c,T as h,L as u,c as d,d as p,G as m,f as g,g as f,O as y,C as b,Q as x,F as _,D as T,I as v,h as w,i as P,j as M,k as C,l as S,m as A,n as E,o as L,p as U,q as D,r as F,s as I,U as R,t as k,u as O,v as V,w as z,x as B,y as N,z as j,A as W,H as G,W as H,J as q,K as Z,N as Y,Z as X,X as $,Y as Q,_ as J}from"./three.BbguFgn81764683399638.js";let K=class{get unloadPriorityCallback(){return this._unloadPriorityCallback}set unloadPriorityCallback(t){1===t.length?(console.warn('LRUCache: "unloadPriorityCallback" function has been changed to take two arguments.'),this._unloadPriorityCallback=(e,s)=>{const i=t(e),n=t(s);return i<n?-1:i>n?1:0}):this._unloadPriorityCallback=t}constructor(){this.minSize=6e3,this.maxSize=8e3,this.minBytesSize=322122547.2,this.maxBytesSize=429496729.6,this.unloadPercent=.05,this.autoMarkUnused=!0,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadingHandle=-1,this.cachedBytes=0,this.bytesMap=new Map,this.loadedSet=new Set,this._unloadPriorityCallback=null;const t=this.itemSet;this.defaultPriorityCallback=e=>t.get(e)}isFull(){return this.itemSet.size>=this.maxSize||this.cachedBytes>=this.maxBytesSize}getMemoryUsage(t){return this.bytesMap.get(t)||0}setMemoryUsage(t,e){const{bytesMap:s,itemSet:i}=this;i.has(t)&&(this.cachedBytes-=s.get(t)||0,s.set(t,e),this.cachedBytes+=e)}add(t,e){const s=this.itemSet;if(s.has(t)||this.isFull())return!1;const i=this.usedSet,n=this.itemList,r=this.callbacks;return n.push(t),i.add(t),s.set(t,Date.now()),r.set(t,e),!0}has(t){return this.itemSet.has(t)}remove(t){const e=this.usedSet,s=this.itemSet,i=this.itemList,n=this.bytesMap,r=this.callbacks,o=this.loadedSet;if(s.has(t)){this.cachedBytes-=n.get(t)||0,n.delete(t),r.get(t)(t);const a=i.indexOf(t);return i.splice(a,1),e.delete(t),s.delete(t),r.delete(t),o.delete(t),!0}return!1}setLoaded(t,e){const{itemSet:s,loadedSet:i}=this;s.has(t)&&(!0===e?i.add(t):i.delete(t))}markUsed(t){const e=this.itemSet,s=this.usedSet;e.has(t)&&!s.has(t)&&(e.set(t,Date.now()),s.add(t))}markUnused(t){this.usedSet.delete(t)}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const{unloadPercent:t,minSize:e,maxSize:s,itemList:i,itemSet:n,usedSet:r,loadedSet:o,callbacks:a,bytesMap:l,minBytesSize:c,maxBytesSize:h}=this,u=i.length-r.size,d=i.length-o.size,p=Math.max(Math.min(i.length-e,u),0),m=this.cachedBytes-c,g=this.unloadPriorityCallback||this.defaultPriorityCallback;let f=!1;const y=p>0&&u>0||d&&i.length>s;if(u&&this.cachedBytes>c||d&&this.cachedBytes>h||y){i.sort((t,e)=>{const s=r.has(t);if(s===r.has(e)){const s=o.has(t);return s===o.has(e)?-g(t,e):s?1:-1}return s?1:-1});const d=Math.max(e*t,p*t),y=Math.ceil(Math.min(d,u,p)),b=Math.max(t*m,t*c),x=Math.min(b,m);let _=0,T=0;for(;this.cachedBytes-T>h||i.length-_>s;){const t=i[_],e=l.get(t)||0;if(r.has(t)&&o.has(t)||this.cachedBytes-T-e<h&&i.length-_<=s)break;T+=e,_++}for(;T<x||_<y;){const t=i[_],e=l.get(t)||0;if(r.has(t)||this.cachedBytes-T-e<c&&_>=y)break;T+=e,_++}i.splice(0,_).forEach(t=>{this.cachedBytes-=l.get(t)||0,a.get(t)(t),l.delete(t),n.delete(t),a.delete(t),o.delete(t),r.delete(t)}),f=_<p||T<m&&_<u,f=f&&_>0}f&&(this.unloadingHandle=requestAnimationFrame(()=>this.scheduleUnload()))}scheduleUnload(){cancelAnimationFrame(this.unloadingHandle),this.scheduled||(this.scheduled=!0,queueMicrotask(()=>{this.scheduled=!1,this.unloadUnusedContent()}))}},tt=class{get running(){return 0!==this.items.length||0!==this.currJobs}constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=null,this.schedulingCallback=t=>{requestAnimationFrame(t)},this._runjobs=()=>{this.scheduled=!1,this.tryRunJobs()}}sort(){const t=this.priorityCallback,e=this.items;null!==t&&e.sort(t)}has(t){return this.callbacks.has(t)}add(t,e){const s={callback:e,reject:null,resolve:null,promise:null};return s.promise=new Promise((e,i)=>{const n=this.items,r=this.callbacks;s.resolve=e,s.reject=i,n.unshift(t),r.set(t,s),this.autoUpdate&&this.scheduleJobRun()}),s.promise}remove(t){const e=this.items,s=this.callbacks,i=e.indexOf(t);if(-1!==i){const n=s.get(t);n.promise.catch(()=>{}),n.reject(new Error("PriorityQueue: Item removed.")),e.splice(i,1),s.delete(t)}}removeByFilter(t){const{items:e}=this;for(let s=0;s<e.length;s++){const i=e[s];t(i)&&this.remove(i)}}tryRunJobs(){this.sort();const t=this.items,e=this.callbacks,s=this.maxJobs;let i=0;const n=()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()};for(;s>this.currJobs&&t.length>0&&i<s;){this.currJobs++,i++;const s=t.pop(),{callback:o,resolve:a,reject:l}=e.get(s);let c;e.delete(s);try{c=o(s)}catch(r){l(r),n()}c instanceof Promise?c.then(a).catch(l).finally(n):(a(c),n())}}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}};const et=-1,st=6378137;function it(t,e=null,s=null){const i=[];for(i.push(t),i.push(null),i.push(0);i.length>0;){const t=i.pop(),n=i.pop(),r=i.pop();if(e&&e(r,n,t))return void(s&&s(r,n,t));const o=r.children;if(o)for(let e=o.length-1;e>=0;e--)i.push(o[e]),i.push(r),i.push(t+1);s&&s(r,n,t)}}function nt(t){if(null===t||t.byteLength<4)return"";let e;if(e=t instanceof DataView?t:new DataView(t),"{"===String.fromCharCode(e.getUint8(0)))return null;let s="";for(let i=0;i<4;i++)s+=String.fromCharCode(e.getUint8(i));return s}const rt=new TextDecoder;function ot(t){return rt.decode(t)}function at(t){return t.replace(/[\\/][^\\/]+$/,"")+"/"}let lt=class{constructor(){this.fetchOptions={},this.workingPath=""}load(...t){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(...t)}loadAsync(t){return fetch(t,this.fetchOptions).then(e=>{if(!e.ok)throw new Error(`Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()}).then(e=>(""===this.workingPath&&(this.workingPath=at(t)),this.parse(e)))}resolveExternalURL(t){return new URL(t,this.workingPath).href}parse(t){throw new Error("LoaderBase: Parse not implemented.")}};function ct(t){if(!t)return null;let e=t.length;const s=t.indexOf("?"),i=t.indexOf("#");-1!==s&&(e=Math.min(e,s)),-1!==i&&(e=Math.min(e,i));const n=t.lastIndexOf(".",e),r=t.lastIndexOf("/",e),o=t.indexOf("://");return-1!==o&&o+2===r||-1===n||n<r?null:t.substring(n+1,e)||null}const ht={inView:!1,error:1/0,distanceFromCamera:1/0};function ut(t){return 3===t||t===et}function dt(t,e){return t.__lastFrameVisited===e&&t.__used}function pt(t){return t.__childrenProcessed===t.children.length}function mt(t,e){t.__lastFrameVisited!==e.frameCount&&(t.__lastFrameVisited=e.frameCount,t.__used=!1,t.__inFrustum=!1,t.__isLeaf=!1,t.__visible=!1,t.__active=!1,t.__error=1/0,t.__distanceFromCamera=1/0,t.__allChildrenLoaded=!1,e.calculateTileViewError(t,ht),t.__inFrustum=ht.inView,t.__error=ht.error,t.__distanceFromCamera=ht.distanceFromCamera)}function gt(t,e){if(e.ensureChildrenArePreprocessed(t),mt(t,e),yt(t,e),t.__hasUnrenderableContent&&pt(t)){const s=t.children;for(let t=0,i=s.length;t<i;t++)gt(s[t],e)}}function ft(t,e){if(e.ensureChildrenArePreprocessed(t),dt(t,e.frameCount)&&(t.__hasContent&&e.queueTileForDownload(t),pt(t))){const s=t.children;for(let t=0,i=s.length;t<i;t++)ft(s[t],e)}}function yt(t,e){t.__used||(t.__used=!0,e.markTileUsed(t),e.stats.used++,!0===t.__inFrustum&&e.stats.inFrustum++)}function bt(t,e){if(e.ensureChildrenArePreprocessed(t),mt(t,e),!t.__inFrustum)return;if(!function(t,e){return!(t.__error<=e.errorTarget&&!t.__hasUnrenderableContent||e.maxDepth>0&&t.__depth+1>=e.maxDepth||!pt(t))}(t,e))return void yt(t,e);let s=!1,i=!1;const n=t.children;for(let r=0,o=n.length;r<o;r++){const t=n[r];bt(t,e),s=s||dt(t,e.frameCount),i=i||t.__inFrustum}if(yt(t,e),s&&"REPLACE"===t.refine&&(t.__depth,1))for(let r=0,o=n.length;r<o;r++){gt(n[r],e)}}function xt(t,e){const s=e.frameCount;if(!dt(t,s))return;const i=t.children;let n=!1;for(let r=0,o=i.length;r<o;r++){const t=i[r];n=n||dt(t,s)}if(n){let n=!0;for(let t=0,r=i.length;t<r;t++){const r=i[t];if(xt(r,e),dt(r,s)){const t=r.__allChildrenLoaded||!r.__hasContent||r.__hasRenderableContent&&ut(r.__loadingState)||r.__hasUnrenderableContent&&r.__loadingState===et;n=n&&t}}t.__allChildrenLoaded=n}else t.__isLeaf=!0}function _t(t,e){const s=e.stats;if(!dt(t,e.frameCount))return;if(t.__isLeaf)return void(3===t.__loadingState?(t.__inFrustum&&(t.__visible=!0,s.visible++),t.__active=!0,s.active++):t.__hasContent&&e.queueTileForDownload(t));const i=t.children,n=t.__hasContent,r=ut(t.__loadingState)&&n,o=(e.errorTarget+1)*e.errorThreshold,a=t.__error<=o,l="ADD"===t.refine,c=t.__allChildrenLoaded||0===t.__depth&&!1;if(n&&(a||l)&&e.queueTileForDownload(t),(a&&r&&!c||r&&l)&&(t.__inFrustum&&(t.__visible=!0,s.visible++),t.__active=!0,s.active++),l||!a||c)for(let h=0,u=i.length;h<u;h++)_t(i[h],e);else for(let h=0,u=i.length;h<u;h++){const t=i[h];dt(t,e.frameCount)&&ft(t,e)}}function Tt(t,e){const s=dt(t,e.frameCount);if(s||t.__usedLastFrame){let i=!1,n=!1;s?(i=t.__active,n=e.displayActiveTiles&&t.__active||t.__visible):mt(t,e),t.__hasRenderableContent&&3===t.__loadingState&&(t.__wasSetActive!==i&&e.invokeOnePlugin(e=>e.setTileActive&&e.setTileActive(t,i)),t.__wasSetVisible!==n&&e.invokeOnePlugin(e=>e.setTileVisible&&e.setTileVisible(t,n))),t.__wasSetActive=i,t.__wasSetVisible=n,t.__usedLastFrame=s;const r=t.children;for(let t=0,s=r.length;t<s;t++){Tt(r[t],e)}}}const vt=Symbol("PLUGIN_REGISTERED"),wt=(t,e)=>{const s=t.priority||0,i=e.priority||0;return s!==i?s>i?1:-1:t.__used!==e.__used?t.__used?1:-1:t.__error!==e.__error?t.__error>e.__error?1:-1:t.__distanceFromCamera!==e.__distanceFromCamera?t.__distanceFromCamera>e.__distanceFromCamera?-1:1:t.__depthFromRenderedParent!==e.__depthFromRenderedParent?t.__depthFromRenderedParent>e.__depthFromRenderedParent?-1:1:0},Pt=(t,e)=>{const s=t.priority||0,i=e.priority||0;return s!==i?s>i?1:-1:t.__lastFrameVisited!==e.__lastFrameVisited?t.__lastFrameVisited>e.__lastFrameVisited?-1:1:t.__depthFromRenderedParent!==e.__depthFromRenderedParent?t.__depthFromRenderedParent>e.__depthFromRenderedParent?1:-1:t.__loadingState!==e.__loadingState?t.__loadingState>e.__loadingState?-1:1:t.__hasUnrenderableContent!==e.__hasUnrenderableContent?t.__hasUnrenderableContent?-1:1:t.__error!==e.__error?t.__error>e.__error?-1:1:0};let Mt=class{get root(){const t=this.rootTileSet;return t?t.root:null}get loadProgress(){const{stats:t,isLoading:e}=this,s=t.downloading+t.parsing,i=t.inCacheSinceLoad+(e?1:0);return 0===i?1:1-s/i}get errorThreshold(){return this._errorThreshold}set errorThreshold(t){console.warn('TilesRenderer: The "errorThreshold" option has been deprecated.'),this._errorThreshold=t}constructor(t=null){this.rootLoadingState=0,this.rootTileSet=null,this.rootURL=t,this.fetchOptions={},this.plugins=[],this.queuedTiles=[],this.cachedSinceLoadComplete=new Set,this.isLoading=!1;const e=new K;e.unloadPriorityCallback=Pt;const s=new tt;s.maxJobs=25,s.priorityCallback=wt;const i=new tt;i.maxJobs=5,i.priorityCallback=wt;const n=new tt;n.maxJobs=25,this.processedTiles=new WeakSet,this.visibleTiles=new Set,this.activeTiles=new Set,this.usedSet=new Set,this.lruCache=e,this.downloadQueue=s,this.parseQueue=i,this.processNodeQueue=n,this.stats={inCacheSinceLoad:0,inCache:0,parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this._dispatchNeedsUpdateEvent=function(t){let e=null;return()=>{null===e&&(e=requestAnimationFrame(()=>{e=null,t()}))}}(()=>{this.dispatchEvent({type:"needs-update"})}),this.errorTarget=16,this._errorThreshold=1/0,this.displayActiveTiles=!1,this.maxDepth=1/0}registerPlugin(t){if(!0===t[vt])throw new Error("TilesRendererBase: A plugin can only be registered to a single tile set");const e=this.plugins,s=t.priority||0;let i=e.length;for(let n=0;n<e.length;n++)if((e[n].priority||0)>s){i=n;break}e.splice(i,0,t),t[vt]=!0,t.init&&t.init(this)}unregisterPlugin(t){const e=this.plugins;if("string"==typeof t&&(t=this.getPluginByName(name)),e.includes(t)){const s=e.indexOf(t);return e.splice(s,1),t.dispose&&t.dispose(),!0}return!1}getPluginByName(t){return this.plugins.find(e=>e.name===t)||null}traverse(t,e,s=!0){this.root&&it(this.root,(e,...i)=>(s&&this.ensureChildrenArePreprocessed(e,!0),!!t&&t(e,...i)),e)}queueTileForDownload(t){0!==t.__loadingState||this.lruCache.isFull()||this.queuedTiles.push(t)}markTileUsed(t){this.usedSet.add(t),this.lruCache.markUsed(t)}update(){const{lruCache:t,usedSet:e,stats:s,root:i,downloadQueue:n,parseQueue:r,processNodeQueue:o}=this;if(0===this.rootLoadingState&&(this.rootLoadingState=1,this.invokeOnePlugin(t=>t.loadRootTileSet&&t.loadRootTileSet()).then(t=>{let e=this.rootURL;null!==e&&this.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),this.rootLoadingState=3,this.rootTileSet=t,this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),this.dispatchEvent({type:"load-tile-set",tileSet:t,url:e})}).catch(t=>{this.rootLoadingState=et,console.error(t),this.rootTileSet=null,this.dispatchEvent({type:"load-error",tile:null,error:t,url:this.rootURL})})),!i)return;s.inFrustum=0,s.used=0,s.active=0,s.visible=0,this.frameCount++,e.forEach(e=>t.markUnused(e)),e.clear(),bt(i,this),xt(i,this),_t(i,this),Tt(i,this);const a=this.queuedTiles;a.sort(t.unloadPriorityCallback);for(let l=0,c=a.length;l<c&&!t.isFull();l++)this.requestTileContents(a[l]);a.length=0,t.scheduleUnload(),!1===(n.running||r.running||o.running)&&!0===this.isLoading&&(this.cachedSinceLoadComplete.clear(),s.inCacheSinceLoad=0,this.dispatchEvent({type:"tiles-load-end"}),this.isLoading=!1)}resetFailedTiles(){this.rootLoadingState===et&&(this.rootLoadingState=0);const t=this.stats;0!==t.failed&&(this.traverse(t=>{t.__loadingState===et&&(t.__loadingState=0)},null,!1),t.failed=0)}dispose(){[...this.plugins].forEach(t=>{this.unregisterPlugin(t)});const t=this.lruCache,e=[];this.traverse(t=>(e.push(t),!1),null,!1);for(let s=0,i=e.length;s<i;s++)t.remove(e[s]);this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}calculateBytesUsed(t,e){return 0}dispatchEvent(t){}fetchData(t,e){return fetch(t,e)}parseTile(t,e,s){return null}disposeTile(t){t.__visible&&(this.invokeOnePlugin(e=>e.setTileVisible&&e.setTileVisible(t,!1)),t.__visible=!1),t.__active&&(this.invokeOnePlugin(e=>e.setTileActive&&e.setTileActive(t,!1)),t.__active=!1)}preprocessNode(t,e,s=null){var i;if(this.processedTiles.add(t),t.content&&(!("uri"in t.content)&&"url"in t.content&&(t.content.uri=t.content.url,delete t.content.url),t.content.boundingVolume&&!("box"in t.content.boundingVolume||"sphere"in t.content.boundingVolume||"region"in t.content.boundingVolume)&&delete t.content.boundingVolume),t.parent=s,t.children=t.children||[],null!=(i=t.content)&&i.uri){const e=ct(t.content.uri);t.__hasContent=!0,t.__hasUnrenderableContent=!(!e||!/json$/.test(e)),t.__hasRenderableContent=!t.__hasUnrenderableContent}else t.__hasContent=!1,t.__hasUnrenderableContent=!1,t.__hasRenderableContent=!1;t.__childrenProcessed=0,s&&s.__childrenProcessed++,t.__distanceFromCamera=1/0,t.__error=1/0,t.__inFrustum=!1,t.__isLeaf=!1,t.__usedLastFrame=!1,t.__used=!1,t.__wasSetVisible=!1,t.__visible=!1,t.__allChildrenLoaded=!1,t.__wasSetActive=!1,t.__active=!1,t.__loadingState=0,null===s?(t.__depth=0,t.__depthFromRenderedParent=t.__hasRenderableContent?1:0,t.refine=t.refine||"REPLACE"):(t.__depth=s.__depth+1,t.__depthFromRenderedParent=s.__depthFromRenderedParent+(t.__hasRenderableContent?1:0),t.refine=t.refine||s.refine),t.__basePath=e,t.__lastFrameVisited=-1,this.invokeAllPlugins(i=>{i!==this&&i.preprocessNode&&i.preprocessNode(t,e,s)})}setTileActive(t,e){e?this.activeTiles.add(t):this.activeTiles.delete(t)}setTileVisible(t,e){e?this.visibleTiles.add(t):this.visibleTiles.delete(t)}calculateTileViewError(t,e){}ensureChildrenArePreprocessed(t,e=!1){const s=t.children;for(let i=0,n=s.length;i<n;i++){const n=s[i];if("__depth"in n)break;e?(this.processNodeQueue.remove(n),this.preprocessNode(n,t.__basePath,t)):this.processNodeQueue.has(n)||this.processNodeQueue.add(n,e=>{this.preprocessNode(e,t.__basePath,t),this._dispatchNeedsUpdateEvent()})}}getBytesUsed(t){let e=0;return this.invokeAllPlugins(s=>{s.calculateBytesUsed&&(e+=s.calculateBytesUsed(t,t.cached.scene)||0)}),e}recalculateBytesUsed(t=null){const{lruCache:e,processedTiles:s}=this;null===t?e.itemSet.forEach(t=>{s.has(t)&&e.setMemoryUsage(t,this.getBytesUsed(t))}):e.setMemoryUsage(t,this.getBytesUsed(t))}preprocessTileSet(t,e,s=null){const i=t.asset.version,[n,r]=i.split(".").map(t=>parseInt(t));console.assert(n<=1,"TilesRenderer: asset.version is expected to be a 1.x or a compatible version."),1===n&&r>0&&console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let o=e.replace(/\/[^/]*$/,"");o=new URL(o,window.location.href).toString(),this.preprocessNode(t.root,o,s)}loadRootTileSet(){let t=this.rootURL;return this.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),this.invokeOnePlugin(e=>e.fetchData&&e.fetchData(t,this.fetchOptions)).then(e=>{if(e instanceof Response){if(e.ok)return e.json();throw new Error(`TilesRenderer: Failed to load tileset "${t}" with status ${e.status} : ${e.statusText}`)}return e}).then(e=>(this.preprocessTileSet(e,t),e))}requestTileContents(t){if(0!==t.__loadingState)return;let e=!1,s=null,i=new URL(t.content.uri,t.__basePath+"/").toString();this.invokeAllPlugins(e=>i=e.preprocessURL?e.preprocessURL(i,t):i);const n=this.stats,r=this.lruCache,o=this.downloadQueue,a=this.parseQueue,l=ct(i),c=new AbortController,h=c.signal;return r.add(t,s=>{c.abort(),e?(s.children.length=0,s.__childrenProcessed=0):this.invokeAllPlugins(t=>{t.disposeTile&&t.disposeTile(s)}),n.inCache--,this.cachedSinceLoadComplete.has(t)&&(this.cachedSinceLoadComplete.delete(t),n.inCacheSinceLoad--),1===s.__loadingState?n.downloading--:2===s.__loadingState&&n.parsing--,s.__loadingState=0,a.remove(s),o.remove(s)})?(this.isLoading||(this.isLoading=!0,this.dispatchEvent({type:"tiles-load-start"})),r.setMemoryUsage(t,this.getBytesUsed(t)),this.cachedSinceLoadComplete.add(t),n.inCacheSinceLoad++,n.inCache++,n.downloading++,t.__loadingState=1,o.add(t,e=>{if(h.aborted)return Promise.resolve();const s=this.invokeOnePlugin(t=>t.fetchData&&t.fetchData(i,{...this.fetchOptions,signal:h}));return this.dispatchEvent({type:"tile-download-start",tile:t}),s}).then(t=>{if(!h.aborted){if(t instanceof Response){if(t.ok)return"json"===l?t.json():t.arrayBuffer();throw new Error(`Failed to load model with error code ${t.status}`)}return t}}).then(r=>{if(!h.aborted)return n.downloading--,n.parsing++,t.__loadingState=2,a.add(t,n=>h.aborted?Promise.resolve():"json"===l&&r.root?(this.preprocessTileSet(r,i,t),t.children.push(r.root),s=r,e=!0,Promise.resolve()):this.invokeOnePlugin(t=>t.parseTile&&t.parseTile(r,n,l,i,h)))}).then(()=>{if(h.aborted)return;n.parsing--,t.__loadingState=3,r.setLoaded(t,!0);const o=this.getBytesUsed(t);0===r.getMemoryUsage(t)&&o>0&&r.isFull()?r.remove(t):(r.setMemoryUsage(t,o),this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),e&&this.dispatchEvent({type:"load-tile-set",tileSet:s,url:i}),t.cached.scene&&this.dispatchEvent({type:"load-model",scene:t.cached.scene,tile:t}))}).catch(e=>{h.aborted||("AbortError"!==e.name?(a.remove(t),o.remove(t),2===t.__loadingState?n.parsing--:1===t.__loadingState&&n.downloading--,n.failed++,console.error(`TilesRenderer : Failed to load tile at url "${t.content.uri}".`),console.error(e),t.__loadingState=et,r.setLoaded(t,!0),this.dispatchEvent({type:"load-error",tile:t,error:e,url:i})):r.remove(t))})):void 0}getAttributions(t=[]){return this.invokeAllPlugins(e=>e!==this&&e.getAttributions&&e.getAttributions(t)),t}invokeOnePlugin(t){const e=[...this.plugins,this];for(let s=0;s<e.length;s++){const i=t(e[s]);if(i)return i}return null}invokeAllPlugins(t){const e=[...this.plugins,this],s=[];for(let i=0;i<e.length;i++){const n=t(e[i]);n&&s.push(n)}return 0===s.length?null:Promise.all(s)}};function Ct(t,e,s,i,n,r){let o,a;switch(i){case"SCALAR":o=1;break;case"VEC2":o=2;break;case"VEC3":o=3;break;case"VEC4":o=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${r}".`)}const l=s*o;switch(n){case"BYTE":a=new Int8Array(t,e,l);break;case"UNSIGNED_BYTE":a=new Uint8Array(t,e,l);break;case"SHORT":a=new Int16Array(t,e,l);break;case"UNSIGNED_SHORT":a=new Uint16Array(t,e,l);break;case"INT":a=new Int32Array(t,e,l);break;case"UNSIGNED_INT":a=new Uint32Array(t,e,l);break;case"FLOAT":a=new Float32Array(t,e,l);break;case"DOUBLE":a=new Float64Array(t,e,l);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${r}".`)}return a}class St{constructor(t,e,s,i){this.buffer=t,this.binOffset=e+s,this.binLength=i;let n=null;if(0!==s){const i=new Uint8Array(t,e,s);n=JSON.parse(ot(i))}else n={};this.header=n}getKeys(){return Object.keys(this.header).filter(t=>"extensions"!==t)}getData(t,e,s=null,i=null){const n=this.header;if(!(t in n))return null;const r=n[t];if(r instanceof Object){if(Array.isArray(r))return r;{const{buffer:n,binOffset:o,binLength:a}=this,l=r.byteOffset||0,c=r.type||i,h=r.componentType||s;if("type"in r&&i&&r.type!==i)throw new Error("FeatureTable: Specified type does not match expected type.");const u=o+l,d=Ct(n,u,e,c,h,t);if(u+d.byteLength>o+a)throw new Error("FeatureTable: Feature data read outside binary body length.");return d}}return r}getBuffer(t,e){const{buffer:s,binOffset:i}=this;return s.slice(i+t,i+t+e)}}let At=class{constructor(t){this.batchTable=t;const e=t.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=e.classes;for(const i of this.classes){const t=i.instances;for(const e in t)i.instances[e]=this._parseProperty(t[e],i.length,e)}if(this.instancesLength=e.instancesLength,this.classIds=this._parseProperty(e.classIds,this.instancesLength,"classIds"),e.parentCounts?this.parentCounts=this._parseProperty(e.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),e.parentIds){const t=this.parentCounts.reduce((t,e)=>t+e,0);this.parentIds=this._parseProperty(e.parentIds,t,"parentIds")}else this.parentIds=null;this.instancesIds=[];const s={};for(const i of this.classIds)s[i]=s[i]??0,this.instancesIds.push(s[i]),s[i]++}_parseProperty(t,e,s){if(Array.isArray(t))return t;{const{buffer:i,binOffset:n}=this.batchTable;return Ct(i,n+t.byteOffset,e,"SCALAR",t.componentType||"UNSIGNED_SHORT",s)}}getDataFromId(t,e={}){const s=this.parentCounts[t];if(this.parentIds&&s>0){let i=0;for(let e=0;e<t;e++)i+=this.parentCounts[e];for(let n=0;n<s;n++){const s=this.parentIds[i+n];s!==t&&this.getDataFromId(s,e)}}const i=this.classIds[t],n=this.classes[i].instances,r=this.classes[i].name,o=this.instancesIds[t];for(const a in n)e[r]=e[r]||{},e[r][a]=n[a][o];return e}};class Et extends St{get batchSize(){return console.warn("BatchTable.batchSize has been deprecated and replaced with BatchTable.count."),this.count}constructor(t,e,s,i,n){super(t,s,i,n),this.count=e,this.extensions={};const r=this.header.extensions;r&&r["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new At(this))}getData(t,e=null,s=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get allproperties for an id or BatchTable.getPropertyArray for getting an array of value for a property."),super.getData(t,this.count,e,s)}getDataFromId(t,e={}){if(t<0||t>=this.count)throw new Error(`BatchTable: id value "${t}" out of bounds for "${this.count}" features number.`);for(const s of this.getKeys())e[s]=super.getData(s,this.count)[t];for(const s in this.extensions){const i=this.extensions[s];i.getDataFromId instanceof Function&&(e[s]=e[s]||{},i.getDataFromId(t,e[s]))}return e}getPropertyArray(t){return super.getData(t,this.count)}}let Lt=class extends lt{parse(t){const e=new DataView(t),s=nt(e);console.assert("b3dm"===s);const i=e.getUint32(4,!0);console.assert(1===i);const n=e.getUint32(8,!0);console.assert(n===t.byteLength);const r=e.getUint32(12,!0),o=e.getUint32(16,!0),a=e.getUint32(20,!0),l=e.getUint32(24,!0),c=t.slice(28,28+r+o),h=new St(c,0,r,o),u=28+r+o,d=t.slice(u,u+a+l),p=new Et(d,h.getData("BATCH_LENGTH"),0,a,l),m=u+a+l;return{version:i,featureTable:h,batchTable:p,glbBytes:new Uint8Array(t,m,n-m)}}},Ut=class extends lt{parse(t){const e=new DataView(t),s=nt(e);console.assert("i3dm"===s);const i=e.getUint32(4,!0);console.assert(1===i);const n=e.getUint32(8,!0);console.assert(n===t.byteLength);const r=e.getUint32(12,!0),o=e.getUint32(16,!0),a=e.getUint32(20,!0),l=e.getUint32(24,!0),c=e.getUint32(28,!0),h=t.slice(32,32+r+o),u=new St(h,0,r,o),d=32+r+o,p=t.slice(d,d+a+l),m=new Et(p,u.getData("INSTANCES_LENGTH"),0,a,l),g=d+a+l,f=new Uint8Array(t,g,n-g);let y=null,b=null,x=null;if(c)y=f,b=Promise.resolve();else{const t=this.resolveExternalURL(ot(f));x=at(t),b=fetch(t,this.fetchOptions).then(e=>{if(!e.ok)throw new Error(`I3DMLoaderBase : Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);return e.arrayBuffer()}).then(t=>{y=new Uint8Array(t)})}return b.then(()=>({version:i,featureTable:u,batchTable:m,glbBytes:y,gltfWorkingPath:x}))}},Dt=class extends lt{parse(t){const e=new DataView(t),s=nt(e);console.assert("pnts"===s);const i=e.getUint32(4,!0);console.assert(1===i);const n=e.getUint32(8,!0);console.assert(n===t.byteLength);const r=e.getUint32(12,!0),o=e.getUint32(16,!0),a=e.getUint32(20,!0),l=e.getUint32(24,!0),c=t.slice(28,28+r+o),h=new St(c,0,r,o),u=28+r+o,d=t.slice(u,u+a+l),p=new Et(d,h.getData("BATCH_LENGTH")||h.getData("POINTS_LENGTH"),0,a,l);return Promise.resolve({version:i,featureTable:h,batchTable:p})}},Ft=class extends lt{parse(t){const e=new DataView(t),s=nt(e);console.assert("cmpt"===s,'CMPTLoader: The magic bytes equal "cmpt".');const i=e.getUint32(4,!0);console.assert(1===i,'CMPTLoader: The version listed in the header is "1".');const n=e.getUint32(8,!0);console.assert(n===t.byteLength,"CMPTLoader: The contents buffer length listed in the header matches the file.");const r=e.getUint32(12,!0),o=[];let a=16;for(let l=0;l<r;l++){const e=new DataView(t,a,12),s=nt(e),i=e.getUint32(4,!0),n=e.getUint32(8,!0),r=new Uint8Array(t,a,n);o.push({type:s,buffer:r,version:i}),a+=n}return{version:i,tiles:o}}};new t;const It=new r,Rt=new t,kt=new t,Ot=new t,Vt=new e,zt=new e,Bt=new e,Nt=new s,jt=new n,Wt=new t,Gt=new t,Ht=new t,qt=new t,Zt=new i;class Yt{constructor(e=1,s=1,i=1){this.name="",this.radius=new t(e,s,i)}intersectRay(t,e){return Vt.makeScale(...this.radius).invert(),Nt.center.set(0,0,0),Nt.radius=1,Zt.copy(t).applyMatrix4(Vt),Zt.intersectSphere(Nt,e)?(Vt.makeScale(...this.radius),e.applyMatrix4(Vt),e):null}getEastNorthUpFrame(t,e,s,i){return s.isMatrix4&&(i=s,s=0,console.warn('Ellipsoid: The signature for "getEastNorthUpFrame" has changed.')),this.getEastNorthUpAxes(t,e,Wt,Gt,Ht),this.getCartographicToPosition(t,e,s,qt),i.makeBasis(Wt,Gt,Ht).setPosition(qt)}getOrientedEastNorthUpFrame(t,e,s,i,n,r,o){return this.getObjectFrame(t,e,s,i,n,r,o,0)}getObjectFrame(t,e,s,i,n,r,o,a=2){return this.getEastNorthUpFrame(t,e,s,Vt),jt.set(n,r,-i,"ZXY"),o.makeRotationFromEuler(jt).premultiply(Vt),1===a?(jt.set(Math.PI/2,0,0,"XYZ"),zt.makeRotationFromEuler(jt),o.multiply(zt)):2===a&&(jt.set(-Math.PI/2,0,Math.PI,"XYZ"),zt.makeRotationFromEuler(jt),o.multiply(zt)),o}getCartographicFromObjectFrame(t,e,s=2){return 1===s?(jt.set(-Math.PI/2,0,0,"XYZ"),zt.makeRotationFromEuler(jt).premultiply(t)):2===s?(jt.set(-Math.PI/2,0,Math.PI,"XYZ"),zt.makeRotationFromEuler(jt).premultiply(t)):zt.copy(t),qt.setFromMatrixPosition(zt),this.getPositionToCartographic(qt,e),this.getEastNorthUpFrame(e.lat,e.lon,0,Vt).invert(),zt.premultiply(Vt),jt.setFromRotationMatrix(zt,"ZXY"),e.azimuth=-jt.z,e.elevation=jt.x,e.roll=jt.y,e}getEastNorthUpAxes(t,e,s,i,n,r=qt){this.getCartographicToPosition(t,e,0,r),this.getCartographicToNormal(t,e,n),s.set(-r.y,r.x,0).normalize(),i.crossVectors(n,s).normalize()}getAzElRollFromRotationMatrix(t,e,s,i,n=0){return console.warn('Ellipsoid: "getAzElRollFromRotationMatrix" is deprecated. Use "getCartographicFromObjectFrame", instead.'),this.getCartographicToPosition(t,e,0,qt),Bt.copy(s).setPosition(qt),this.getCartographicFromObjectFrame(Bt,i,n),delete i.height,delete i.lat,delete i.lon,i}getRotationMatrixFromAzElRoll(t,e,s,i,n,r,o=0){return console.warn('Ellipsoid: "getRotationMatrixFromAzElRoll" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(t,e,0,s,i,n,r,o),r.setPosition(0,0,0),r}getFrame(t,e,s,i,n,r,o,a=0){return console.warn('Ellipsoid: "getFrame" function has been deprecated. Use "getObjectFrame", instead.'),this.getObjectFrame(t,e,r,s,i,n,o,a)}getCartographicToPosition(t,e,s,i){this.getCartographicToNormal(t,e,Rt);const n=this.radius;kt.copy(Rt),kt.x*=n.x**2,kt.y*=n.y**2,kt.z*=n.z**2;const r=Math.sqrt(Rt.dot(kt));return kt.divideScalar(r),i.copy(kt).addScaledVector(Rt,s)}getPositionToCartographic(t,e){this.getPositionToSurfacePoint(t,kt),this.getPositionToNormal(t,Rt);const s=Ot.subVectors(t,kt);return e.lon=Math.atan2(Rt.y,Rt.x),e.lat=Math.asin(Rt.z),e.height=Math.sign(s.dot(t))*s.length(),e}getCartographicToNormal(t,e,s){return It.set(1,-t+Math.PI/2,e),s.setFromSpherical(It).normalize(),function(t){const{x:e,y:s,z:i}=t;t.x=i,t.y=e,t.z=s}(s),s}getPositionToNormal(t,e){const s=this.radius;return e.copy(t),e.x/=s.x**2,e.y/=s.y**2,e.z/=s.z**2,e.normalize(),e}getPositionToSurfacePoint(t,e){const s=this.radius,i=1/s.x**2,n=1/s.y**2,r=1/s.z**2,o=t.x*t.x*i,a=t.y*t.y*n,l=t.z*t.z*r,c=o+a+l,h=Math.sqrt(1/c),u=kt.copy(t).multiplyScalar(h);if(c<.1)return isFinite(h)?e.copy(u):null;const d=Ot.set(u.x*i*2,u.y*n*2,u.z*r*2);let p,m,g,f,y,b,x,_,T,v,w,P=(1-h)*t.length()/(.5*d.length()),M=0;do{P-=M,g=1/(1+P*i),f=1/(1+P*n),y=1/(1+P*r),b=g*g,x=f*f,_=y*y,T=b*g,v=x*f,w=_*y,p=o*b+a*x+l*_-1,m=o*T*i+a*v*n+l*w*r;M=p/(-2*m)}while(Math.abs(p)>1e-12);return e.set(t.x*g,t.y*f,t.z*y)}calculateHorizonDistance(t,e){const s=this.calculateEffectiveRadius(t);return Math.sqrt(2*s*e+e**2)}calculateEffectiveRadius(t){const e=this.radius.x,s=1-this.radius.z**2/e**2,i=t*o.DEG2RAD,n=Math.sin(i)**2;return e/Math.sqrt(1-s*n)}getPositionElevation(t){this.getPositionToSurfacePoint(t,kt);const e=Ot.subVectors(t,kt);return Math.sign(e.dot(t))*e.length()}closestPointToRayEstimate(t,e){return this.intersectRay(t,e)?e:(Vt.makeScale(...this.radius).invert(),Zt.copy(t).applyMatrix4(Vt),kt.set(0,0,0),Zt.closestPointToPoint(kt,e).normalize(),Vt.makeScale(...this.radius),e.applyMatrix4(Vt))}copy(t){return this.radius.copy(t.radius),this}clone(){return(new this.constructor).copy(this)}}const Xt=new t,$t=new t,Qt=new t,Jt=new i;let Kt=class{constructor(s=new l,i=new e){this.box=s.clone(),this.transform=i.clone(),this.inverseTransform=new e,this.points=new Array(8).fill().map(()=>new t),this.planes=new Array(6).fill().map(()=>new c)}copy(t){return this.box.copy(t.box),this.transform.copy(t.transform),this.update(),this}clone(){return(new this.constructor).copy(this)}clampPoint(t,e){return e.copy(t).applyMatrix4(this.inverseTransform).clamp(this.box.min,this.box.max).applyMatrix4(this.transform)}distanceToPoint(t){return this.clampPoint(t,Qt).distanceTo(t)}containsPoint(t){return Qt.copy(t).applyMatrix4(this.inverseTransform),this.box.containsPoint(Qt)}intersectsRay(t){return Jt.copy(t).applyMatrix4(this.inverseTransform),Jt.intersectsBox(this.box)}intersectRay(t,e){return Jt.copy(t).applyMatrix4(this.inverseTransform),Jt.intersectBox(this.box,e)?(e.applyMatrix4(this.transform),e):null}update(){const{points:t,inverseTransform:e,transform:s,box:i}=this;e.copy(s).invert();const{min:n,max:r}=i;let o=0;for(let a=-1;a<=1;a+=2)for(let e=-1;e<=1;e+=2)for(let i=-1;i<=1;i+=2)t[o].set(a<0?n.x:r.x,e<0?n.y:r.y,i<0?n.z:r.z).applyMatrix4(s),o++;this.updatePlanes()}updatePlanes(){Xt.copy(this.box.min).applyMatrix4(this.transform),$t.copy(this.box.max).applyMatrix4(this.transform),Qt.set(0,0,1).transformDirection(this.transform),this.planes[0].setFromNormalAndCoplanarPoint(Qt,Xt),this.planes[1].setFromNormalAndCoplanarPoint(Qt,$t).negate(),Qt.set(0,1,0).transformDirection(this.transform),this.planes[2].setFromNormalAndCoplanarPoint(Qt,Xt),this.planes[3].setFromNormalAndCoplanarPoint(Qt,$t).negate(),Qt.set(1,0,0).transformDirection(this.transform),this.planes[4].setFromNormalAndCoplanarPoint(Qt,Xt),this.planes[5].setFromNormalAndCoplanarPoint(Qt,$t).negate()}intersectsSphere(t){return this.clampPoint(t.center,Qt),Qt.distanceToSquared(t.center)<=t.radius*t.radius}intersectsFrustum(t){return this._intersectsPlaneShape(t.planes,t.points)}intersectsOBB(t){return this._intersectsPlaneShape(t.planes,t.points)}_intersectsPlaneShape(t,e){const s=this.points,i=this.planes;for(let n=0;n<6;n++){const e=t[n];let i=-1/0;for(let t=0;t<8;t++){const n=s[t],r=e.distanceToPoint(n);i=i<r?r:i}if(i<0)return!1}for(let n=0;n<6;n++){const t=i[n];let s=-1/0;for(let i=0;i<8;i++){const n=e[i],r=t.distanceToPoint(n);s=s<r?r:s}if(s<0)return!1}return!0}};const te=Math.PI,ee=te/2,se=new t,ie=new t,ne=new t,re=new e;let oe=0;const ae=[];function le(e=!1){return e?(ae[oe]||(ae[oe]=new t),oe++,ae[oe-1]):new t}function ce(){oe=0}let he=class extends Yt{constructor(t,e,s,i=-ee,n=ee,r=0,o=2*te,a=0,l=0){super(t,e,s),this.latStart=i,this.latEnd=n,this.lonStart=r,this.lonEnd=o,this.heightStart=a,this.heightEnd=l}_getPoints(t=!1){const{latStart:e,latEnd:s,lonStart:i,lonEnd:n,heightStart:r,heightEnd:a}=this,l=o.mapLinear(.5,0,1,e,s),c=o.mapLinear(.5,0,1,i,n),h=Math.floor(i/ee)*ee,u=[[-te/2,0],[te/2,0],[0,h],[0,h+te/2],[0,h+te],[0,h+3*te/2],[e,n],[s,n],[e,i],[s,i],[0,i],[0,n],[l,c],[e,c],[s,c],[l,i],[l,n]],d=[],p=u.length;for(let m=0;m<=1;m++){const l=o.mapLinear(m,0,1,r,a);for(let r=0,o=p;r<o;r++){const[o,a]=u[r];if(o>=e&&o<=s&&a>=i&&a<=n){const e=le(t);d.push(e),this.getCartographicToPosition(o,a,l,e)}}}return d}getBoundingBox(t,e){ce();const{latStart:s,latEnd:i,lonStart:n,lonEnd:r}=this;if(i-s<te/2){const t=o.mapLinear(.5,0,1,s,i),a=o.mapLinear(.5,0,1,n,r);this.getCartographicToNormal(t,a,ne),ie.set(0,0,1),se.crossVectors(ie,ne),ie.crossVectors(se,ne),e.makeBasis(se,ie,ne)}else se.set(1,0,0),ie.set(0,1,0),ne.set(0,0,1),e.makeBasis(se,ie,ne);re.copy(e).invert();const a=this._getPoints(!0);for(let o=0,l=a.length;o<l;o++)a[o].applyMatrix4(re);t.makeEmpty(),t.setFromPoints(a)}getBoundingSphere(t,e){ce();const s=this._getPoints(!0);t.makeEmpty(),t.setFromPoints(s,e)}};function ue(t){const{TextureUtils:e}=h;if(!e||!t)return 0;const{format:s,type:i,image:n}=t,{width:r,height:o}=n;let a=e.getByteLength(r,o,s,i);return a*=t.generateMipmaps?4/3:1,a}class de extends Lt{constructor(t=T){super(),this.manager=t,this.adjustmentTransform=new e}parse(t){const e=super.parse(t),s=e.glbBytes.slice().buffer;return new Promise((t,i)=>{const n=this.manager,r=this.fetchOptions,o=n.getHandler("path.gltf")||new m(n);"include"===r.credentials&&"cors"===r.mode&&o.setCrossOrigin("use-credentials"),"credentials"in r&&o.setWithCredentials("include"===r.credentials),r.headers&&o.setRequestHeader(r.headers);let a=this.workingPath;!/[\\/]$/.test(a)&&a.length&&(a+="/");const l=this.adjustmentTransform;o.parse(s,a,s=>{const{batchTable:i,featureTable:n}=e,{scene:r}=s,o=n.getData("RTC_CENTER",1,"FLOAT","VEC3");o&&(r.position.x+=o[0],r.position.y+=o[1],r.position.z+=o[2]),s.scene.updateMatrix(),s.scene.matrix.multiply(l),s.scene.matrix.decompose(s.scene.position,s.scene.quaternion,s.scene.scale),s.batchTable=i,s.featureTable=n,r.batchTable=i,r.featureTable=n,t(s)},i)})}}function pe(t){const e=t>>11,s=t>>5&63,i=31&t;return[Math.round(e/31*255),Math.round(s/63*255),Math.round(i/31*255)]}const me=new p;function ge(e,s,i=new t){me.set(e,s).divideScalar(256).multiplyScalar(2).subScalar(1),i.set(me.x,me.y,1-Math.abs(me.x)-Math.abs(me.y));const n=o.clamp(-i.z,0,1);return i.x>=0?i.setX(i.x-n):i.setX(i.x+n),i.y>=0?i.setY(i.y-n):i.setY(i.y+n),i.normalize(),i}const fe={RGB:"color",POSITION:"position"};class ye extends Dt{constructor(t=T){super(),this.manager=t}parse(e){return super.parse(e).then(async e=>{const{featureTable:s,batchTable:i}=e,n=new w,r=s.header.extensions,o=new t;let a;if(r&&r["3DTILES_draco_point_compression"]){const{byteOffset:t,byteLength:e,properties:i}=r["3DTILES_draco_point_compression"],o=this.manager.getHandler("draco.drc");if(null==o)throw new Error("PNTSLoader: dracoLoader not available.");const l={};for(const s in i)if(s in fe&&s in i){l[fe[s]]=i[s]}const c={attributeIDs:l,attributeTypes:{position:"Float32Array",color:"Uint8Array"},useUniqueIDs:!0},h=s.getBuffer(t,e);a=await o.decodeGeometry(h,c),a.attributes.color&&(n.vertexColors=!0)}else{const e=s.getData("POINTS_LENGTH"),i=s.getData("POSITION",e,"FLOAT","VEC3"),r=s.getData("NORMAL",e,"FLOAT","VEC3"),l=s.getData("NORMAL",e,"UNSIGNED_BYTE","VEC2"),c=s.getData("RGB",e,"UNSIGNED_BYTE","VEC3"),h=s.getData("RGBA",e,"UNSIGNED_BYTE","VEC4"),u=s.getData("RGB565",e,"UNSIGNED_SHORT","SCALAR"),d=s.getData("CONSTANT_RGBA",e,"UNSIGNED_BYTE","VEC4"),p=s.getData("POSITION_QUANTIZED",e,"UNSIGNED_SHORT","VEC3"),m=s.getData("QUANTIZED_VOLUME_SCALE",e,"FLOAT","VEC3"),g=s.getData("QUANTIZED_VOLUME_OFFSET",e,"FLOAT","VEC3");if(a=new P,p){const t=new Float32Array(3*e);for(let s=0;s<e;s++)for(let e=0;e<3;e++){const i=3*s+e;t[i]=p[i]/65535*m[e]}o.x=g[0],o.y=g[1],o.z=g[2],a.setAttribute("position",new M(t,3,!1))}else a.setAttribute("position",new M(i,3,!1));if(null!==r)a.setAttribute("normal",new M(r,3,!1));else if(null!==l){const s=new Float32Array(3*e),i=new t;for(let t=0;t<e;t++){const e=ge(l[2*t],l[2*t+1],i);s[3*t]=e.x,s[3*t+1]=e.y,s[3*t+2]=e.z}a.setAttribute("normal",new M(s,3,!1))}if(null!==h)a.setAttribute("color",new M(h,4,!0)),n.vertexColors=!0,n.transparent=!0,n.depthWrite=!1;else if(null!==c)a.setAttribute("color",new M(c,3,!0)),n.vertexColors=!0;else if(null!==u){const t=new Uint8Array(3*e);for(let s=0;s<e;s++){const e=pe(u[s]);for(let i=0;i<3;i++){t[3*s+i]=e[i]}}a.setAttribute("color",new M(t,3,!0)),n.vertexColors=!0}else if(null!==d){const t=new C(d[0],d[1],d[2]);n.color=t;const e=d[3]/255;e<1&&(n.opacity=e,n.transparent=!0,n.depthWrite=!1)}}const l=new S(a,n);l.position.copy(o),e.scene=l,e.scene.featureTable=s,e.scene.batchTable=i;const c=s.getData("RTC_CENTER",1,"FLOAT","VEC3");return c&&(e.scene.position.x+=c[0],e.scene.position.y+=c[1],e.scene.position.z+=c[2]),e})}}const be=new Yt(st,st,6356752.314245179);be.name="WGS84 Earth";const xe=new t,_e=new t,Te=new t,ve=new t,we=new x,Pe=new t,Me=new e,Ce=new e,Se=new t,Ae=new e,Ee=new x,Le={};let Ue=class extends Ut{constructor(t=T){super(),this.manager=t,this.adjustmentTransform=new e,this.ellipsoid=be.clone()}resolveExternalURL(t){return this.manager.resolveURL(super.resolveExternalURL(t))}parse(e){return super.parse(e).then(e=>{const{featureTable:s,batchTable:i}=e,n=e.glbBytes.slice().buffer;return new Promise((r,o)=>{const a=this.fetchOptions,l=this.manager,c=l.getHandler("path.gltf")||new m(l);"include"===a.credentials&&"cors"===a.mode&&c.setCrossOrigin("use-credentials"),"credentials"in a&&c.setWithCredentials("include"===a.credentials),a.headers&&c.setRequestHeader(a.headers);let h=e.gltfWorkingPath??this.workingPath;/[\\/]$/.test(h)||(h+="/");const u=this.adjustmentTransform;c.parse(n,h,e=>{const n=s.getData("INSTANCES_LENGTH"),o=s.getData("POSITION",n,"FLOAT","VEC3"),a=s.getData("NORMAL_UP",n,"FLOAT","VEC3"),l=s.getData("NORMAL_RIGHT",n,"FLOAT","VEC3"),c=s.getData("SCALE_NON_UNIFORM",n,"FLOAT","VEC3"),h=s.getData("SCALE",n,"FLOAT","SCALAR"),d=s.getData("RTC_CENTER",1,"FLOAT","VEC3"),p=s.getData("EAST_NORTH_UP");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(t=>{t in s.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${t}" detected.`)});const m=new t;for(let t=0;t<n;t++)m.x+=o[3*t+0]/n,m.y+=o[3*t+1]/n,m.z+=o[3*t+2]/n;const g=[],f=[];e.scene.updateMatrixWorld(),e.scene.traverse(t=>{if(t.isMesh){f.push(t);const{geometry:e,material:s}=t,i=new v(e,s,n);i.position.copy(m),d&&(i.position.x+=d[0],i.position.y+=d[1],i.position.z+=d[2]),g.push(i)}});for(let t=0;t<n;t++){ve.set(o[3*t+0]-m.x,o[3*t+1]-m.y,o[3*t+2]-m.z),we.identity(),a&&(_e.set(a[3*t+0],a[3*t+1],a[3*t+2]),Te.set(l[3*t+0],l[3*t+1],l[3*t+2]),xe.crossVectors(Te,_e).normalize(),Me.makeBasis(Te,_e,xe),we.setFromRotationMatrix(Me)),Pe.set(1,1,1),c&&Pe.set(c[3*t+0],c[3*t+1],c[3*t+2]),h&&Pe.multiplyScalar(h[t]);for(let e=0,s=g.length;e<s;e++){const s=g[e];Ee.copy(we),p&&(s.updateMatrixWorld(),Se.copy(ve).applyMatrix4(s.matrixWorld),this.ellipsoid.getPositionToCartographic(Se,Le),this.ellipsoid.getEastNorthUpFrame(Le.lat,Le.lon,Ae),Ee.setFromRotationMatrix(Ae)),Me.compose(ve,Ee,Pe).multiply(u);const i=f[e];Ce.multiplyMatrices(Me,i.matrixWorld),s.setMatrixAt(t,Ce)}}e.scene.clear(),e.scene.add(...g),e.batchTable=i,e.featureTable=s,e.scene.batchTable=i,e.scene.featureTable=s,r(e)},o)})})}},De=class extends Ft{constructor(t=T){super(),this.manager=t,this.adjustmentTransform=new e,this.ellipsoid=be.clone()}parse(t){const e=super.parse(t),{manager:s,ellipsoid:i,adjustmentTransform:n}=this,r=[];for(const o in e.tiles){const{type:t,buffer:a}=e.tiles[o];switch(t){case"b3dm":{const t=a.slice(),e=new de(s);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions,e.adjustmentTransform.copy(n);const i=e.parse(t.buffer);r.push(i);break}case"pnts":{const t=a.slice(),e=new ye(s);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions;const i=e.parse(t.buffer);r.push(i);break}case"i3dm":{const t=a.slice(),e=new Ue(s);e.workingPath=this.workingPath,e.fetchOptions=this.fetchOptions,e.ellipsoid.copy(i),e.adjustmentTransform.copy(n);const o=e.parse(t.buffer);r.push(o);break}}}return Promise.all(r).then(t=>{const e=new g;return t.forEach(t=>{e.add(t.scene)}),{tiles:t,scene:e}})}};const Fe=new e;let Ie=class extends g{constructor(t){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=t,this.matrixWorldInverse=new e}raycast(t,e){return!this.tilesRenderer.optimizeRaycast||(this.tilesRenderer.raycast(t,e),!1)}updateMatrixWorld(t){if(this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldNeedsUpdate||t){null===this.parent?Fe.copy(this.matrix):Fe.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1;const t=Fe.elements,e=this.matrixWorld.elements;let s=!1;for(let i=0;i<16;i++){const n=t[i],r=e[i];if(Math.abs(n-r)>Number.EPSILON){s=!0;break}}if(s){this.matrixWorld.copy(Fe),this.matrixWorldInverse.copy(Fe).invert();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].updateMatrixWorld()}}}updateWorldMatrix(t,e){this.parent&&t&&this.parent.updateWorldMatrix(t,!1),this.updateMatrixWorld(!0)}};const Re=new i,ke=new t,Oe=[];function Ve(t,e){return t.distance-e.distance}function ze(t,e,s,i){const{scene:n}=t.cached;s.invokeOnePlugin(s=>s.raycastTile&&s.raycastTile(t,n,e,i))||e.intersectObject(n,!0,i)}function Be(t){return"__used"in t}function Ne(t,e,s,i=null){const{group:n,activeTiles:r}=t;null===i&&(i=Re).copy(s.ray).applyMatrix4(n.matrixWorldInverse);const o=[],a=e.children;for(let h=0,u=a.length;h<u;h++){const t=a[h];Be(t)&&t.__used&&(null!==t.cached.boundingVolume.intersectRay(i,ke)&&(ke.applyMatrix4(n.matrixWorld),o.push({distance:ke.distanceToSquared(s.ray.origin),tile:t})))}o.sort(Ve);let l=null,c=1/0;if(r.has(e)){const i=function(t,e,s){ze(t,e,s,Oe),Oe.sort(Ve);const i=Oe[0]||null;return Oe.length=0,i}(e,s,t);i&&(l=i,c=i.distance*i.distance)}for(let h=0,u=o.length;h<u;h++){const e=o[h],n=e.distance,r=e.tile;if(n>c)break;const a=Ne(t,r,s,i);if(a){const t=a.distance*a.distance;t<c&&(l=a,c=t)}}return l}function je(t,e,s,i,n=null){if(!Be(e))return;const{group:r,activeTiles:o}=t,{boundingVolume:a}=e.cached;if(null===n&&(n=Re).copy(s.ray).applyMatrix4(r.matrixWorldInverse),!e.__used||!a.intersectsRay(n))return;o.has(e)&&ze(e,s,t,i);const l=e.children;for(let c=0,h=l.length;c<h;c++)je(t,l[c],s,i,n)}const We=new t,Ge=new t,He=new t,qe=new t,Ze=new t;class Ye{constructor(){this.sphere=null,this.obb=null,this.region=null,this.regionObb=null}intersectsRay(t){const e=this.sphere,s=this.obb||this.regionObb;return!(e&&!t.intersectsSphere(e)||s&&!s.intersectsRay(t))}intersectRay(t,e=null){const s=this.sphere,i=this.obb||this.regionObb;let n=-1/0,r=-1/0;s&&t.intersectSphere(s,qe)&&(n=s.containsPoint(t.origin)?0:t.origin.distanceToSquared(qe)),i&&i.intersectRay(t,Ze)&&(r=i.containsPoint(t.origin)?0:t.origin.distanceToSquared(Ze));const o=Math.max(n,r);return o===-1/0?null:(t.at(Math.sqrt(o),e),e)}distanceToPoint(t){const e=this.sphere,s=this.obb||this.regionObb;let i=-1/0,n=-1/0;return e&&(i=Math.max(e.distanceToPoint(t),0)),s&&(n=s.distanceToPoint(t)),i>n?i:n}intersectsFrustum(t){const e=this.obb||this.regionObb,s=this.sphere;return!(s&&!t.intersectsSphere(s)||e&&!e.intersectsFrustum(t))&&!(!s&&!e)}intersectsSphere(t){const e=this.obb||this.regionObb,s=this.sphere;return!(s&&!s.intersectsSphere(t)||e&&!e.intersectsSphere(t))&&!(!s&&!e)}intersectsOBB(t){const e=this.obb||this.regionObb,s=this.sphere;return!(s&&!t.intersectsSphere(s)||e&&!e.intersectsOBB(t))&&!(!s&&!e)}getOBB(t,e){const s=this.obb||this.regionObb;s?(t.copy(s.box),e.copy(s.transform)):(this.getAABB(t),e.identity())}getAABB(t){if(this.sphere)this.sphere.getBoundingBox(t);else{const e=this.obb||this.regionObb;t.copy(e.box).applyMatrix4(e.transform)}}getSphere(t){if(this.sphere)t.copy(this.sphere);else if(this.region)this.region.getBoundingSphere(t);else{const e=this.obb||this.regionObb;e.box.getBoundingSphere(t),t.applyMatrix4(e.transform)}}setObbData(t,e){const s=new Kt;We.set(t[3],t[4],t[5]),Ge.set(t[6],t[7],t[8]),He.set(t[9],t[10],t[11]);const i=We.length(),n=Ge.length(),r=He.length();We.normalize(),Ge.normalize(),He.normalize(),0===i&&We.crossVectors(Ge,He),0===n&&Ge.crossVectors(We,He),0===r&&He.crossVectors(We,Ge),s.transform.set(We.x,Ge.x,He.x,t[0],We.y,Ge.y,He.y,t[1],We.z,Ge.z,He.z,t[2],0,0,0,1).premultiply(e),s.box.min.set(-i,-n,-r),s.box.max.set(i,n,r),s.update(),this.obb=s}setSphereData(t,e,i,n,r){const o=new s;o.center.set(t,e,i),o.radius=n,o.applyMatrix4(r),this.sphere=o}setRegionData(t,e,s,i,n,r,o){const a=new he(...t.radius,s,n,e,i,r,o),l=new Kt;a.getBoundingBox(l.box,l.transform),l.update(),this.region=a,this.regionObb=l}}const Xe=new E;class $e extends _{constructor(){super(),this.points=Array(8).fill().map(()=>new t)}setFromProjectionMatrix(t,e){return super.setFromProjectionMatrix(t,e),this.calculateFrustumPoints(),this}calculateFrustumPoints(){const{planes:t,points:e}=this;[[t[0],t[3],t[4]],[t[1],t[3],t[4]],[t[0],t[2],t[4]],[t[1],t[2],t[4]],[t[0],t[3],t[5]],[t[1],t[3],t[5]],[t[0],t[2],t[5]],[t[1],t[2],t[5]]].forEach((t,s)=>{!function(t,e,s,i){const n=Xe.set(t.normal.x,t.normal.y,t.normal.z,e.normal.x,e.normal.y,e.normal.z,s.normal.x,s.normal.y,s.normal.z);i.set(-t.constant,-e.constant,-s.constant),i.applyMatrix3(n.invert())}(t[0],t[1],t[2],e[s])})}}const Qe=new e,Je=new n,Ke=Symbol("INITIAL_FRUSTUM_CULLED"),ts=new e,es=new t,ss=new p,is={inView:!1,error:1/0},ns=new t(1,0,0),rs=new t(0,1,0);function os(t,e){t.traverse(t=>{t.frustumCulled=t[Ke]&&e})}class as extends Mt{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(t){this._autoDisableRendererCulling!==t&&(super._autoDisableRendererCulling=t,this.forEachLoadedModel(e=>{os(e,!t)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(t){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=t}constructor(...t){super(...t),this.group=new Ie(this),this.ellipsoid=be.clone(),this.cameras=[],this.cameraMap=new Map,this.cameraInfo=[],this._optimizeRaycast=!0,this._upRotationMatrix=new e,this._bytesUsed=new WeakMap,this._autoDisableRendererCulling=!0;const s=new u;s.setURLModifier(t=>this.preprocessURL?this.preprocessURL(t):t),this.manager=s,this._listeners={}}addEventListener(...t){d.prototype.addEventListener.call(this,...t)}hasEventListener(...t){d.prototype.hasEventListener.call(this,...t)}removeEventListener(...t){d.prototype.removeEventListener.call(this,...t)}dispatchEvent(...t){d.prototype.dispatchEvent.call(this,...t)}getBoundingBox(t){if(!this.root)return!1;const e=this.root.cached.boundingVolume;return!!e&&(e.getAABB(t),!0)}getOrientedBoundingBox(t,e){if(!this.root)return!1;const s=this.root.cached.boundingVolume;return!!s&&(s.getOBB(t,e),!0)}getBoundingSphere(t){if(!this.root)return!1;const e=this.root.cached.boundingVolume;return!!e&&(e.getSphere(t),!0)}forEachLoadedModel(t){this.traverse(e=>{const s=e.cached&&e.cached.scene;s&&t(s,e)},null,!1)}raycast(t,e){if(this.root)if(t.firstHitOnly){const s=Ne(this,this.root,t);s&&e.push(s)}else je(this,this.root,t,e)}hasCamera(t){return this.cameraMap.has(t)}setCamera(t){const e=this.cameras,s=this.cameraMap;return!s.has(t)&&(s.set(t,new p),e.push(t),this.dispatchEvent({type:"add-camera",camera:t}),!0)}setResolution(t,e,s){const i=this.cameraMap;if(!i.has(t))return!1;const n=e.isVector2?e.x:e,r=e.isVector2?e.y:s,o=i.get(t);return(o.width!==n||o.height!==r)&&(o.set(n,r),this.dispatchEvent({type:"camera-resolution-change"})),!0}setResolutionFromRenderer(t,e){return e.getSize(ss),this.setResolution(t,ss.x,ss.y)}deleteCamera(t){const e=this.cameras,s=this.cameraMap;if(s.has(t)){const i=e.indexOf(t);return e.splice(i,1),s.delete(t),this.dispatchEvent({type:"delete-camera",camera:t}),!0}return!1}loadRootTileSet(...t){return super.loadRootTileSet(...t).then(t=>{const{asset:e,extensions:s={}}=t;switch((e&&e.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(rs,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(ns,Math.PI/2)}if("3DTILES_ellipsoid"in s){const t=s["3DTILES_ellipsoid"],{ellipsoid:e}=this;e.name=t.body,t.radii?e.radius.set(...t.radii):e.radius.set(1,1,1)}return t})}update(){let e=null;if(this.invokeAllPlugins(t=>{if(t.doTilesNeedUpdate){const s=t.doTilesNeedUpdate();e=null===e?s:!(!e&&!s)}}),!1===e)return this.dispatchEvent({type:"update-before"}),void this.dispatchEvent({type:"update-after"});this.dispatchEvent({type:"update-before"});const s=this.group,i=this.cameras,n=this.cameraMap,r=this.cameraInfo;for(;r.length>i.length;)r.pop();for(;r.length<i.length;)r.push({frustum:new $e,isOrthographic:!1,sseDenominator:-1,position:new t,invScale:-1,pixelSize:0});es.setFromMatrixScale(s.matrixWorldInverse),Math.abs(Math.max(es.x-es.y,es.x-es.z))>1e-6&&console.warn("ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let t=0,o=r.length;t<o;t++){const e=i[t],o=r[t],a=o.frustum,l=o.position,c=n.get(e);(0===c.width||0===c.height)&&console.warn("TilesRenderer: resolution for camera error calculation is not set.");const h=e.projectionMatrix.elements;if(o.isOrthographic=1===h[15],o.isOrthographic){const t=2/h[0],e=2/h[5];o.pixelSize=Math.max(e/c.height,t/c.width)}else o.sseDenominator=2/h[5]/c.height;ts.copy(s.matrixWorld),ts.premultiply(e.matrixWorldInverse),ts.premultiply(e.projectionMatrix),a.setFromProjectionMatrix(ts),l.set(0,0,0),l.applyMatrix4(e.matrixWorld),l.applyMatrix4(s.matrixWorldInverse)}if(super.update(),this.dispatchEvent({type:"update-after"}),0===i.length&&this.root){let t=!1;this.invokeAllPlugins(e=>t=t||!(e===this||!e.calculateTileViewError)),!1===t&&console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.")}}preprocessNode(t,s,i=null){super.preprocessNode(t,s,i);const n=new e;if(t.transform){const e=t.transform;for(let t=0;t<16;t++)n.elements[t]=e[t]}i&&n.premultiply(i.cached.transform);const r=(new e).copy(n).invert(),o=new Ye;"sphere"in t.boundingVolume&&o.setSphereData(...t.boundingVolume.sphere,n),"box"in t.boundingVolume&&o.setObbData(t.boundingVolume.box,n),"region"in t.boundingVolume&&o.setRegionData(this.ellipsoid,...t.boundingVolume.region),t.cached={transform:n,transformInverse:r,active:!1,boundingVolume:o,metadata:null,scene:null,geometry:null,materials:null,textures:null}}async parseTile(t,e,s,i,n){const r=e.cached,o=at(i),a=this.fetchOptions,l=this.manager;let c=null;const h=r.transform,u=this._upRotationMatrix,d=(nt(t)||s).toLowerCase();switch(d){case"b3dm":{const e=new de(l);e.workingPath=o,e.fetchOptions=a,e.adjustmentTransform.copy(u),c=e.parse(t);break}case"pnts":{const e=new ye(l);e.workingPath=o,e.fetchOptions=a,c=e.parse(t);break}case"i3dm":{const e=new Ue(l);e.workingPath=o,e.fetchOptions=a,e.adjustmentTransform.copy(u),e.ellipsoid.copy(this.ellipsoid),c=e.parse(t);break}case"cmpt":{const e=new De(l);e.workingPath=o,e.fetchOptions=a,e.adjustmentTransform.copy(u),e.ellipsoid.copy(this.ellipsoid),c=e.parse(t).then(t=>t.scene);break}case"gltf":case"glb":{const e=l.getHandler("path.gltf")||l.getHandler("path.glb")||new m(l);e.setWithCredentials("include"===a.credentials),e.setRequestHeader(a.headers||{}),"include"===a.credentials&&"cors"===a.mode&&e.setCrossOrigin("use-credentials");let s=e.resourcePath||e.path||o;!/[\\/]$/.test(s)&&s.length&&(s+="/"),c=e.parseAsync(t,s).then(t=>{t.scene=t.scene||new g;const{scene:e}=t;return e.updateMatrix(),e.matrix.multiply(u).decompose(e.position,e.quaternion,e.scale),t});break}default:c=this.invokeOnePlugin(r=>r.parseToMesh&&r.parseToMesh(t,e,s,i,n))}const p=await c;if(null===p)throw new Error(`TilesRenderer: Content type "${d}" not supported.`);let f,y;p.isObject3D?(f=p,y=null):(f=p.scene,y=p),f.updateMatrix(),f.matrix.premultiply(h),f.matrix.decompose(f.position,f.quaternion,f.scale),await this.invokeAllPlugins(t=>t.processTileModel&&t.processTileModel(f,e)),f.traverse(t=>{t[Ke]=t.frustumCulled}),os(f,!this.autoDisableRendererCulling);const b=[],x=[],_=[];if(f.traverse(t=>{if(t.geometry&&x.push(t.geometry),t.material){const e=t.material;b.push(t.material);for(const t in e){const s=e[t];s&&s.isTexture&&_.push(s)}}}),n.aborted)for(let m=0,g=_.length;m<g;m++){const t=_[m];t.image instanceof ImageBitmap&&t.image.close(),t.dispose()}else r.materials=b,r.geometry=x,r.textures=_,r.scene=f,r.metadata=y}disposeTile(t){super.disposeTile(t);const e=t.cached;if(e.scene){const s=e.materials,i=e.geometry,n=e.textures,r=e.scene.parent;e.scene.traverse(t=>{t.userData.meshFeatures&&t.userData.meshFeatures.dispose(),t.userData.structuralMetadata&&t.userData.structuralMetadata.dispose()});for(let t=0,e=i.length;t<e;t++)i[t].dispose();for(let t=0,e=s.length;t<e;t++)s[t].dispose();for(let t=0,e=n.length;t<e;t++){const e=n[t];e.image instanceof ImageBitmap&&e.image.close(),e.dispose()}r&&r.remove(e.scene),this.dispatchEvent({type:"dispose-model",scene:e.scene,tile:t}),e.scene=null,e.materials=null,e.textures=null,e.geometry=null,e.metadata=null}}setTileVisible(t,e){const s=t.cached.scene,i=this.group;e?s&&(i.add(s),s.updateMatrixWorld(!0)):s&&i.remove(s),super.setTileVisible(t,e),this.dispatchEvent({type:"tile-visibility-change",scene:s,tile:t,visible:e})}calculateBytesUsed(t,e){const s=this._bytesUsed;return!s.has(t)&&e&&s.set(t,function(t){const e=new Set;let s=0;return t.traverse(t=>{if(t.geometry&&!e.has(t.geometry)&&(s+=a(t.geometry),e.add(t.geometry)),t.material){const i=t.material;for(const t in i){const n=i[t];n&&n.isTexture&&!e.has(n)&&(s+=ue(n),e.add(n))}}}),s}(e)),s.get(t)??null}calculateTileViewError(t,e){const s=t.cached,i=this.cameras,n=this.cameraInfo,r=s.boundingVolume;let o=!1,a=-1/0,l=1/0,c=-1/0,h=1/0;for(let u=0,d=i.length;u<d;u++){const e=n[u];let s,i;if(e.isOrthographic){const n=e.pixelSize;s=t.geometricError/n,i=1/0}else{const n=e.sseDenominator;i=r.distanceToPoint(e.position),s=0===i?1/0:t.geometricError/(i*n)}const d=n[u].frustum;r.intersectsFrustum(d)&&(o=!0,a=Math.max(a,s),l=Math.min(l,i)),c=Math.max(c,s),h=Math.min(h,i)}this.invokeAllPlugins(e=>{e!==this&&e.calculateTileViewError&&(e.calculateTileViewError(t,is),is.inView&&(o=!0,a=Math.max(a,is.error)),c=Math.max(c,is.error))}),o?(e.inView=!0,e.error=a,e.distanceFromCamera=l):(e.inView=!1,e.error=c,e.distanceFromCamera=h)}setLatLonToYUp(t,e){console.warn("TilesRenderer: setLatLonToYUp is deprecated. Use the ReorientationPlugin, instead.");const{ellipsoid:s,group:i}=this;Je.set(Math.PI/2,Math.PI/2,0),Qe.makeRotationFromEuler(Je),s.getEastNorthUpFrame(t,e,0,i.matrix).multiply(Qe).invert().decompose(i.position,i.quaternion,i.scale),i.updateMatrixWorld(!0)}dispose(){super.dispose(),this.group.removeFromParent()}}class ls extends L{constructor(){super(new U(0,0),new cs),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class cs extends D{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new p},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:"\n\n\t\t\t\tuniform float pixelRatio;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 offset = uv * 2.0 - vec2( 1.0 );\n\t\t\t\t\toffset.y *= aspect;\n\n\t\t\t\t\tvec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tscreenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;\n\n\t\t\t\t\tgl_Position = screenPoint;\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float thickness;\n\t\t\t\tuniform float opacity;\n\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat ht = 0.5 * thickness;\n\t\t\t\t\tfloat planeDim = size + thickness;\n\t\t\t\t\tfloat offset = ( planeDim - ht - 2.0 ) / planeDim;\n\t\t\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\t\t\tvec2 vec = vUv * 2.0 - vec2( 1.0 );\n\t\t\t\t\tfloat dist = abs( length( vec ) - offset );\n\t\t\t\t\tfloat fw = fwidth( dist ) * 0.5;\n\t\t\t\t\tfloat a = smoothstep( texelThickness - fw, texelThickness + fw, dist );\n\n\t\t\t\t\tgl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );\n\n\t\t\t\t}\n\t\t\t"})}}const hs=new p,us=new p;class ds{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new p,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new p,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const s in e)t[s].copy(e[s])}setHoverEvent(t){("mouse"===t.pointerType||"wheel"===t.type)&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return null!==this.pointerType?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const s=(this.domElement?this.domElement:t.target).getBoundingClientRect(),i=t.clientX-s.left,n=t.clientY-s.top;e.set(i,n)}addPointer(t){const e=t.pointerId,s=new p;this.getAdjustedPointer(t,s),this.pointerOrder.push(e),this.pointerPositions[e]=s,this.previousPositions[e]=s.clone(),this.startPositions[e]=s.clone(),1===this.getPointerCount()&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions&&(this.getAdjustedPointer(t,this.pointerPositions[e]),!0)}deletePointer(t){const e=t.pointerId,s=this.pointerOrder;s.splice(s.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],0===this.getPointerCount.length&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const s=this.pointerOrder;if(1===this.getPointerCount()||"mouse"===this.getPointerType()){const i=s[0];return t.copy(e[i]),t}if(2===this.getPointerCount()){const s=this.pointerOrder[0],i=this.pointerOrder[1],n=e[s],r=e[i];return t.addVectors(n,r).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(hs),this.getPreviousCenterPoint(us),hs.sub(us).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||"mouse"===this.getPointerType())return 0;const{pointerOrder:e}=this,s=e[0],i=e[1],n=t[s],r=t[i];return n.distanceTo(r)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return"touch"===this.getPointerType()}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(1&this.buttons)}isRightClicked(){return!!(2&this.buttons)}}const ps=new e;function ms(t,e,s){return s.makeTranslation(-t.x,-t.y,-t.z),ps.makeRotationFromQuaternion(e),s.premultiply(ps),ps.makeTranslation(t.x,t.y,t.z),s.premultiply(ps),s}function gs(t,e,s,i){i.x=(t-s.offsetLeft)/s.clientWidth*2-1,i.y=-(e-s.offsetTop)/s.clientHeight*2+1,i.isVector3&&(i.z=0)}function fs(t,e,s){const n=t instanceof i?t:t.ray,{origin:r,direction:o}=n;r.set(e.x,e.y,-1).unproject(s),o.set(e.x,e.y,1).unproject(s).sub(r),t.isRay||(t.near=0,t.far=o.length(),t.camera=s),o.normalize()}new t;const ys=.05,bs=.025,xs=new e,_s=new e,Ts=new t,vs=new t,ws=new t,Ps=new t,Ms=new t,Cs=new t,Ss=new t,As=new t,Es=new x,Ls=new c,Us=new t,Ds=new t,Fs=new t,Is=new x,Rs=new i,ks=new p,Os=new p,Vs=new p,zs=new p,Bs=new p,Ns=new p,js={type:"change"},Ws={type:"start"},Gs={type:"end"};class Hs extends d{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this._enabled=t,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(e=null,s=null,i=null,n=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.fallbackPlane=new c(new t(0,1,0),0),this.useFallbackPlane=!0,this.scaleZoomOrientationAtEdges=!1,this.autoAdjustCameraRotation=!0,this.state=0,this.pointerTracker=new ds,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new t,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new t,this.zoomPoint=new t,this.zoomDelta=0,this.rotationInertiaPivot=new t,this.rotationInertia=new p,this.dragInertia=new t,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new ls,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new A,this.raycaster.firstHitOnly=!0,this.up=new t(0,1,0),this.clock=new b,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=0,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),s&&this.setCamera(s),e&&this.setScene(e),n&&this.setTilesRenderer(n)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=t,this.resetState()}setTilesRenderer(t){console.warn('EnvironmentControls: "setTilesRenderer" has been deprecated. Use "setScene" and "setEllipsoid", instead.'),this.tilesRenderer=t,null!==this.tilesRenderer&&this.setScene(this.tilesRenderer.group)}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";const e=t=>{this.enabled&&t.preventDefault()},s=t=>{if(!this.enabled)return;t.preventDefault();const{camera:e,raycaster:s,domElement:i,up:n,pivotMesh:r,pointerTracker:o,scene:a,pivotPoint:l,enabled:c}=this;if(o.addPointer(t),this.needsUpdate=!0,o.isPointerTouch())if(r.visible=!1,0===o.getPointerCount())i.setPointerCapture(t.pointerId);else if(o.getPointerCount()>2)return void this.resetState();o.getCenterPoint(Os),gs(Os.x,Os.y,i,Os),fs(s,Os,e);const h=Math.abs(s.ray.direction.dot(n));if(h<ys||h<bs)return;const u=this._raycast(s);u&&(2===o.getPointerCount()||o.isRightClicked()||o.isLeftClicked()&&t.shiftKey?(this.setState(o.isPointerTouch()?4:2),l.copy(u.point),r.position.copy(u.point),r.visible=!o.isPointerTouch()&&c,r.updateMatrixWorld(),a.add(r)):o.isLeftClicked()&&(this.setState(1),l.copy(u.point),r.position.copy(u.point),r.updateMatrixWorld(),a.add(r)))};let i=!1;const n=t=>{const{pointerTracker:e}=this;if(!this.enabled)return;t.preventDefault();const{pivotMesh:s,enabled:n}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,0!==this.state&&(this.needsUpdate=!0),e.setHoverEvent(t),e.updatePointer(t)&&(e.isPointerTouch()&&2===e.getPointerCount()&&(i||(i=!0,queueMicrotask(()=>{i=!1,e.getCenterPoint(Bs);const t=e.getStartTouchPointerDistance(),r=e.getTouchPointerDistance(),o=r-t;if(0===this.state||4===this.state){e.getCenterPoint(Bs),e.getStartCenterPoint(Ns);const t=2*window.devicePixelRatio,s=Bs.distanceTo(Ns);(Math.abs(o)>t||s>t)&&(Math.abs(o)>s?(this.setState(3),this.zoomDirectionSet=!1):this.setState(2))}if(3===this.state){const t=e.getPreviousTouchPointerDistance();this.zoomDelta+=r-t,s.visible=!1}else 2===this.state&&(s.visible=n)}))),this.dispatchEvent(js))},r=e=>{const{pointerTracker:s}=this;!this.enabled||0===s.getPointerCount()||(s.deletePointer(e),"touch"===s.getPointerType()&&0===s.getPointerCount()&&t.releasePointerCapture(e.pointerId),this.resetState(),this.needsUpdate=!0)},o=t=>{if(!this.enabled)return;t.preventDefault();const{pointerTracker:e}=this;let s;switch(e.setHoverEvent(t),e.updatePointer(t),this.dispatchEvent(Ws),t.deltaMode){case 2:s=800*t.deltaY;break;case 1:s=40*t.deltaY;break;case 0:s=t.deltaY}const i=Math.sign(s),n=Math.abs(s);this.zoomDelta-=.25*i*n,this.needsUpdate=!0,this._lastUsedState=3,this.dispatchEvent(Gs)},a=t=>{this.enabled&&this.resetState()};t.addEventListener("contextmenu",e),t.addEventListener("pointerdown",s),t.addEventListener("wheel",o,{passive:!1});const l=t.getRootNode();l.addEventListener("pointermove",n),l.addEventListener("pointerup",r),l.addEventListener("pointerleave",a),this._detachCallback=()=>{t.removeEventListener("contextmenu",e),t.removeEventListener("pointerdown",s),t.removeEventListener("wheel",o),l.removeEventListener("pointermove",n),l.removeEventListener("pointerup",r),l.removeEventListener("pointerleave",a)}}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){let e=null;3===this._lastUsedState?this._zoomPointWasSet&&(e=t.copy(this.zoomPoint)):(2===this._lastUsedState||1===this._lastUsedState)&&(e=t.copy(this.pivotPoint));const{camera:s,raycaster:i}=this;null!==e&&(vs.copy(e).project(s),(vs.x<-1||vs.x>1||vs.y<-1||vs.y>1)&&(e=null)),fs(i,{x:0,y:0},s);const n=this._raycast(i);return n&&(null===e||n.distance<e.distanceTo(i.ray.origin))&&(e=t.copy(n.point)),e}resetState(){0!==this.state&&this.dispatchEvent(Gs),this.state=0,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0,this.pointerTracker.reset()}setState(t=this.state,e=!0){this.state!==t&&(0===this.state&&e&&this.dispatchEvent(Ws),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=t,0!==t&&4!==t&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),.064)){if(!this.enabled||!this.camera||0===t)return;const{camera:e,cameraRadius:s,pivotPoint:i,up:n,state:r,adjustHeight:o,autoAdjustCameraRotation:a}=this;e.updateMatrixWorld(),this.getCameraUpDirection(Us),this._upInitialized||(this._upInitialized=!0,this.up.copy(Us)),this.zoomPointSet=!1;const l=this._inertiaNeedsUpdate(),c=this.needsUpdate||l;if(this.needsUpdate||l){const s=this.zoomDelta;this._updateZoom(),this._updatePosition(t),this._updateRotation(t),1===r||2===r?(Ms.set(0,0,-1).transformDirection(e.matrixWorld),this.inertiaTargetDistance=vs.copy(i).sub(e.position).dot(Ms)):0===r&&this._updateInertia(t),(0!==r||0!==s||l)&&this.dispatchEvent(js),this.needsUpdate=!1}const h=e.isOrthographicCamera?null:o&&this._getPointBelowCamera()||null;if(this.getCameraUpDirection(Us),this._setFrame(Us),(1===this.state||2===this.state)&&0!==this.actionHeightOffset){const{actionHeightOffset:t}=this;e.position.addScaledVector(n,-t),i.addScaledVector(n,-t),h&&(h.distance-=t)}if(this.actionHeightOffset=0,h){const t=h.distance;if(t<s){const r=s-t;e.position.addScaledVector(n,r),i.addScaledVector(n,r),this.actionHeightOffset=r}}this.pointerTracker.updateFrame(),c&&a&&(this.getCameraUpDirection(Us),this._alignCameraUp(Us,1),this.getCameraUpDirection(Us),this._clampRotation(Us))}adjustCamera(t){const{adjustHeight:e,cameraRadius:s}=this;if(t.isPerspectiveCamera){this.getUpDirection(t.position,Us);const i=e&&this._getPointBelowCamera(t.position,Us)||null;if(i){const e=i.distance;e<s&&t.position.addScaledVector(Us,s-e)}}}dispose(){this.detach()}_updateInertia(t){const{rotationInertia:e,pivotPoint:s,dragInertia:i,enableDamping:n,dampingFactor:r,camera:o,cameraRadius:a,minDistance:l,inertiaTargetDistance:c}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return i.set(0,0,0),void e.set(0,0,0);const h=Math.pow(2,-t/r),u=Math.max(o.near,a,l,c),d=25e-5;if(e.lengthSq()>0){fs(Rs,vs.set(0,0,-1),o),Rs.applyMatrix4(o.matrixWorldInverse),Rs.direction.normalize(),Rs.recast(-Rs.direction.dot(Rs.origin)).at(u/Rs.direction.z,vs),vs.applyMatrix4(o.matrixWorld),fs(Rs,Ts.set(d,d,-1),o),Rs.applyMatrix4(o.matrixWorldInverse),Rs.direction.normalize(),Rs.recast(-Rs.direction.dot(Rs.origin)).at(u/Rs.direction.z,Ts),Ts.applyMatrix4(o.matrixWorld),vs.sub(s).normalize(),Ts.sub(s).normalize();const i=vs.angleTo(Ts)/t;e.multiplyScalar(h),(e.lengthSq()<i**2||!n)&&e.set(0,0)}if(i.lengthSq()>0){fs(Rs,vs.set(0,0,-1),o),Rs.applyMatrix4(o.matrixWorldInverse),Rs.direction.normalize(),Rs.recast(-Rs.direction.dot(Rs.origin)).at(u/Rs.direction.z,vs),vs.applyMatrix4(o.matrixWorld),fs(Rs,Ts.set(d,d,-1),o),Rs.applyMatrix4(o.matrixWorldInverse),Rs.direction.normalize(),Rs.recast(-Rs.direction.dot(Rs.origin)).at(u/Rs.direction.z,Ts),Ts.applyMatrix4(o.matrixWorld);const e=vs.distanceTo(Ts)/t;i.multiplyScalar(h),(i.lengthSq()<e**2||!n)&&i.set(0,0,0)}e.lengthSq()>0&&this._applyRotation(e.x*t,e.y*t,s),i.lengthSq()>0&&(o.position.addScaledVector(i,t),o.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return 0!==t.lengthSq()||0!==e.lengthSq()}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:s,minDistance:i,maxDistance:n,pointerTracker:r,domElement:o,minZoom:a,maxZoom:l,zoomSpeed:c,state:h}=this;let u=this.zoomDelta;if(this.zoomDelta=0,r.getLatestPoint(Os)&&(0!==u||3===h))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),s.isOrthographicCamera){this._updateZoomDirection();const t=this.zoomPointSet||this._updateZoomPoint();Ds.unproject(s);const e=Math.pow(.95,Math.abs(.05*u));let i=u>0?1/Math.abs(e):e;i*=c,i>1?l<s.zoom*i&&(i=1):a>s.zoom*i&&(i=1),s.zoom*=i,s.updateProjectionMatrix(),t&&(gs(Os.x,Os.y,o,Fs),Fs.unproject(s),s.position.sub(Fs).add(Ds),s.updateMatrixWorld())}else{this._updateZoomDirection();const r=vs.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const r=t.distanceTo(s.position);if(u<0){const t=Math.min(0,r-n);u=u*r*c*.0025,u=Math.max(u,t)}else{const t=Math.max(0,r-i);u=u*Math.max(r-i,0)*c*.0025,u=Math.min(u,t)}s.position.addScaledVector(e,u),s.updateMatrixWorld()}else{const t=this._getPointBelowCamera();if(t){const e=t.distance;r.set(0,0,-1).transformDirection(s.matrixWorld),s.position.addScaledVector(r,u*e*.01),s.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:s,zoomDirection:i,pointerTracker:n}=this;n.getLatestPoint(Os),gs(Os.x,Os.y,t,Ds),fs(e,Ds,s),i.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:s,raycaster:i,zoomPoint:n,pointerTracker:r,domElement:o}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&r.getLatestPoint(ks)?(gs(ks.x,ks.y,o,ks),fs(i,ks,t)):(i.ray.origin.copy(t.position),i.ray.direction.copy(s),i.near=0,i.far=1/0);const a=this._raycast(i);return!!a&&(n.copy(a.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0)}_getPointBelowCamera(t=this.camera.position,e=this.up){const{raycaster:s}=this;s.ray.direction.copy(e).multiplyScalar(-1),s.ray.origin.copy(t).addScaledVector(e,1e5),s.near=0,s.far=1/0;const i=this._raycast(s);return i&&(i.distance-=1e5),i}_updatePosition(t){const{raycaster:e,camera:s,pivotPoint:i,up:n,pointerTracker:r,domElement:o,state:a,dragInertia:l}=this;if(1===a){if(r.getCenterPoint(Os),gs(Os.x,Os.y,o,Os),Ls.setFromNormalAndCoplanarPoint(n,i),fs(e,Os,s),Math.abs(e.ray.direction.dot(n))<ys){const t=Math.acos(ys);As.crossVectors(e.ray.direction,n).normalize(),e.ray.direction.copy(n).applyAxisAngle(As,t).multiplyScalar(-1)}if(this.getUpDirection(i,Us),Math.abs(e.ray.direction.dot(Us))<bs){const t=Math.acos(bs);As.crossVectors(e.ray.direction,Us).normalize(),e.ray.direction.copy(Us).applyAxisAngle(As,t).multiplyScalar(-1)}e.ray.intersectPlane(Ls,vs)&&(Ts.subVectors(i,vs),s.position.add(Ts),s.updateMatrixWorld(),Ts.multiplyScalar(1/t),r.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(Ts),this.inertiaStableFrames=0))}}_updateRotation(t){const{pivotPoint:e,pointerTracker:s,domElement:i,state:n,rotationInertia:r}=this;2===n&&(s.getCenterPoint(Os),s.getPreviousCenterPoint(Vs),zs.subVectors(Os,Vs).multiplyScalar(2*Math.PI/i.clientHeight),this._applyRotation(zs.x,zs.y,e),zs.multiplyScalar(1/t),s.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(r.copy(zs),this.inertiaStableFrames=0))}_applyRotation(t,e,s){if(0===t&&0===e)return;const{camera:i,minAltitude:n,maxAltitude:r,rotationSpeed:o}=this,a=-t*o;let l,c=e*o;Ms.set(0,0,1).transformDirection(i.matrixWorld),Cs.set(1,0,0).transformDirection(i.matrixWorld),this.getUpDirection(s,Us),Us.dot(Ms)>1-1e-10?l=0:(vs.crossVectors(Us,Ms).normalize(),l=Math.sign(vs.dot(Cs))*Us.angleTo(Ms)),c>0?(c=Math.min(l-n,c),c=Math.max(0,c)):(c=Math.max(l-r,c),c=Math.min(0,c)),Es.setFromAxisAngle(Us,a),ms(s,Es,xs),i.matrixWorld.premultiply(xs),Cs.set(1,0,0).transformDirection(i.matrixWorld),Es.setFromAxisAngle(Cs,-c),ms(s,Es,xs),i.matrixWorld.premultiply(xs),i.matrixWorld.decompose(i.position,i.quaternion,vs)}_setFrame(t){const{up:e,camera:s,zoomPoint:i,zoomDirectionSet:n,zoomPointSet:r,scaleZoomOrientationAtEdges:a}=this;if(n&&(r||this._updateZoomPoint())){if(Es.setFromUnitVectors(e,t),a){this.getUpDirection(i,vs);let t=Math.max(vs.dot(e)-.6,0)/.4;t=o.mapLinear(t,0,.5,0,1),t=Math.min(t,1),s.isOrthographicCamera&&(t*=.1),Es.slerp(Is,1-t)}ms(i,Es,xs),s.updateMatrixWorld(),s.matrixWorld.premultiply(xs),s.matrixWorld.decompose(s.position,s.quaternion,vs),this.zoomDirectionSet=!1,this._updateZoomDirection()}e.copy(t),s.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:s,fallbackPlane:i}=this,n=t.intersectObject(e)[0]||null;if(n)return n;if(s){const e=i;if(t.ray.intersectPlane(e,vs))return{point:vs.clone(),distance:t.ray.origin.distanceTo(vs)}}return null}_alignCameraUp(t,e=1){const{camera:s,state:i,pivotPoint:n,zoomPoint:r,zoomPointSet:a}=this;s.updateMatrixWorld(),Ms.set(0,0,-1).transformDirection(s.matrixWorld),Cs.set(-1,0,0).transformDirection(s.matrixWorld);let l=o.mapLinear(1-Math.abs(Ms.dot(t)),0,.2,0,1);l=o.clamp(l,0,1),e*=l,Ss.crossVectors(t,Ms),Ss.lerp(Cs,1-e).normalize(),Es.setFromUnitVectors(Cs,Ss),s.quaternion.premultiply(Es);let c=null;1===i||2===i?c=ws.copy(n):a&&(c=ws.copy(r)),c&&(_s.copy(s.matrixWorld).invert(),vs.copy(c).applyMatrix4(_s),s.updateMatrixWorld(),vs.applyMatrix4(s.matrixWorld),Ps.subVectors(c,vs),s.position.add(Ps)),s.updateMatrixWorld()}_clampRotation(t){const{camera:e,minAltitude:s,maxAltitude:i,state:n,pivotPoint:r,zoomPoint:o,zoomPointSet:a}=this;let l,c;if(e.updateMatrixWorld(),Ms.set(0,0,1).transformDirection(e.matrixWorld),Cs.set(1,0,0).transformDirection(e.matrixWorld),t.dot(Ms)>1-1e-10?l=0:(vs.crossVectors(t,Ms),l=Math.sign(vs.dot(Cs))*t.angleTo(Ms)),l>i)c=i;else{if(!(l<s))return;c=s}Ms.copy(t),Es.setFromAxisAngle(Cs,c),Ms.applyQuaternion(Es).normalize(),vs.crossVectors(Ms,Cs).normalize(),xs.makeBasis(Cs,vs,Ms),e.quaternion.setFromRotationMatrix(xs);let h=null;1===n||2===n?h=ws.copy(r):a&&(h=ws.copy(o)),h&&(_s.copy(e.matrixWorld).invert(),vs.copy(h).applyMatrix4(_s),e.updateMatrixWorld(),vs.applyMatrix4(e.matrixWorld),Ps.subVectors(h,vs),e.position.add(Ps)),e.updateMatrixWorld()}}const qs=new e,Zs=new e,Ys=new t,Xs=new t,$s=new t,Qs=new t,Js=new t,Ks=new t,ti=new x,ei=new t,si=new t,ii=new i,ni=new Yt,ri=new p,oi={};class ai extends Hs{get tilesGroup(){return console.warn('GlobeControls: "tilesGroup" has been deprecated. Use "ellipsoidGroup", instead.'),this.ellipsoidFrame}get ellipsoidFrame(){return this.ellipsoidGroup.matrixWorld}get ellipsoidFrameInverse(){const{ellipsoidGroup:t,ellipsoidFrame:e,_ellipsoidFrameInverse:s}=this;return t.matrixWorldInverse?t.matrixWorldInverse:s.copy(e).invert()}constructor(t=null,s=null,i=null,n=null){super(t,s,i),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.nearMargin=.25,this.farMargin=0,this.useFallbackPlane=!1,this.autoAdjustCameraRotation=!1,this.globeInertia=new x,this.globeInertiaFactor=0,this.ellipsoid=be.clone(),this.ellipsoidGroup=new g,this._ellipsoidFrameInverse=new e,null!==n&&this.setTilesRenderer(n)}setTilesRenderer(t){super.setTilesRenderer(t),null!==t&&this.setEllipsoid(t.ellipsoid,t.group)}setEllipsoid(t,e){this.ellipsoid=t||be.clone(),this.ellipsoidGroup=e||new g}getPivotPoint(t){const{camera:e,ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:n}=this;return Qs.set(0,0,-1).transformDirection(e.matrixWorld),ii.origin.copy(e.position),ii.direction.copy(Qs),ii.applyMatrix4(i),n.closestPointToRayEstimate(ii,Xs).applyMatrix4(s),(null===super.getPivotPoint(t)||Ys.subVectors(t,ii.origin).dot(ii.direction)>Ys.subVectors(Xs,ii.origin).dot(ii.direction))&&t.copy(Xs),t}getVectorToCenter(t){const{ellipsoidFrame:e,camera:s}=this;return t.setFromMatrixPosition(e).sub(s.position)}getDistanceToCenter(){return this.getVectorToCenter(Xs).length()}getUpDirection(t,e){const{ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:n}=this;Xs.copy(t).applyMatrix4(i),n.getPositionToNormal(Xs,e),e.transformDirection(s)}getCameraUpDirection(t){const{ellipsoidFrame:e,ellipsoidFrameInverse:s,ellipsoid:i,camera:n}=this;n.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(Xs),Xs.applyMatrix4(s),i.getPositionToNormal(Xs,t),t.transformDirection(e)):this.getUpDirection(n.position,t)}update(t=Math.min(this.clock.getDelta(),.064)){if(!this.enabled||!this.camera||0===t)return;const{camera:e,pivotMesh:s}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(0!==this.state&&1!==this._dragMode&&1!==this._rotationMode&&(s.visible=!1),this.scaleZoomOrientationAtEdges=!1);const i=this.needsUpdate||this._inertiaNeedsUpdate();super.update(t),this.adjustCamera(e),i&&this._isNearControls()&&(this.getCameraUpDirection(Ks),this._alignCameraUp(Ks,1),this.getCameraUpDirection(Ks),this._clampRotation(Ks))}adjustCamera(t){super.adjustCamera(t);const{ellipsoidFrame:e,ellipsoidFrameInverse:s,ellipsoid:i,nearMargin:n,farMargin:r}=this,a=Math.max(...i.radius);if(t.isPerspectiveCamera){const l=Xs.setFromMatrixPosition(e).sub(t.position).length(),c=n*a,h=o.clamp((l-a)/c,0,1),u=o.lerp(1,1e3,h);t.near=Math.max(u,l-a-c),Ys.copy(t.position).applyMatrix4(s),i.getPositionToCartographic(Ys,oi);const d=Math.max(i.getPositionElevation(Ys),2550),p=i.calculateHorizonDistance(oi.lat,d);t.far=p+.1+a*r,t.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(t.position,t),t.updateMatrixWorld(),qs.copy(t.matrixWorld).invert(),Xs.setFromMatrixPosition(e).applyMatrix4(qs);const s=-Xs.z;t.near=s-a*(1+n),t.far=s+.1+a*r,t.position.addScaledVector(Qs,t.near),t.far-=t.near,t.near=0,t.updateProjectionMatrix(),t.updateMatrixWorld()}}setState(...t){super.setState(...t),this._dragMode=0,this._rotationMode=0}_updateInertia(t){super._updateInertia(t);const{globeInertia:e,enableDamping:s,dampingFactor:i,camera:n,cameraRadius:r,minDistance:o,inertiaTargetDistance:a,ellipsoidFrame:l}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return this.globeInertiaFactor=0,void this.globeInertia.identity();const c=Math.pow(2,-t/i),h=Math.max(n.near,r,o,a),u=25e-5;if($s.setFromMatrixPosition(l),0!==this.globeInertiaFactor){fs(ii,Xs.set(0,0,-1),n),ii.applyMatrix4(n.matrixWorldInverse),ii.direction.normalize(),ii.recast(-ii.direction.dot(ii.origin)).at(h/ii.direction.z,Xs),Xs.applyMatrix4(n.matrixWorld),fs(ii,Ys.set(u,u,-1),n),ii.applyMatrix4(n.matrixWorldInverse),ii.direction.normalize(),ii.recast(-ii.direction.dot(ii.origin)).at(h/ii.direction.z,Ys),Ys.applyMatrix4(n.matrixWorld),Xs.sub($s).normalize(),Ys.sub($s).normalize(),this.globeInertiaFactor*=c;const i=Xs.angleTo(Ys)/t;(2*Math.acos(e.w)*this.globeInertiaFactor<i||!s)&&(this.globeInertiaFactor=0,e.identity())}0!==this.globeInertiaFactor&&(1===e.w&&(0!==e.x||0!==e.y||0!==e.z)&&(e.w=Math.min(e.w,1-1e-9)),$s.setFromMatrixPosition(l),ti.identity().slerp(e,this.globeInertiaFactor*t),ms($s,ti,Zs),n.matrixWorld.premultiply(Zs),n.matrixWorld.decompose(n.position,n.quaternion,Xs))}_inertiaNeedsUpdate(){return super._inertiaNeedsUpdate()||0!==this.globeInertiaFactor}_updatePosition(t){if(1===this.state){0===this._dragMode&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:e,camera:s,pivotPoint:i,pointerTracker:n,domElement:r,ellipsoidFrame:o,ellipsoidFrameInverse:a}=this,l=Ys,c=Js;n.getCenterPoint(ri),gs(ri.x,ri.y,r,ri),fs(e,ri,s),e.ray.applyMatrix4(a);const h=Xs.copy(i).applyMatrix4(a).length();if(ni.radius.setScalar(h),!ni.intersectRay(e.ray,Xs))return this.resetState(),void this._updateInertia(t);Xs.applyMatrix4(o),$s.setFromMatrixPosition(o),l.subVectors(i,$s).normalize(),c.subVectors(Xs,$s).normalize(),ti.setFromUnitVectors(c,l),ms($s,ti,Zs),s.matrixWorld.premultiply(Zs),s.matrixWorld.decompose(s.position,s.quaternion,Xs),n.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(this.globeInertia.copy(ti),this.globeInertiaFactor=1/t,this.inertiaStableFrames=0)}}_updateRotation(...t){1===this._rotationMode||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...t)):(this.pivotMesh.visible=!1,this._rotationMode=-1)}_updateZoom(){const{zoomDelta:t,ellipsoid:e,zoomSpeed:s,zoomPoint:i,camera:n,maxZoom:r,state:a}=this;if(3!==a&&0===t)return;this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),this.globeInertia.identity(),this.globeInertiaFactor=0;const l=o.clamp(o.mapLinear(Math.abs(t),0,20,0,1),0,1);if(this._isNearControls()||t>0){if(this._updateZoomDirection(),t<0&&(this.zoomPointSet||this._updateZoomPoint())){Qs.set(0,0,-1).transformDirection(n.matrixWorld).normalize(),si.copy(this.up).multiplyScalar(-1),this.getUpDirection(i,ei);const t=o.clamp(o.mapLinear(-ei.dot(si),1,.95,0,1),0,1),e=1-Qs.dot(si),s=n.isOrthographicCamera?.05:1,r=o.clamp(3*l,0,1),a=Math.min(t*e*s*r,.1);si.lerpVectors(Qs,si,a).normalize(),ti.setFromUnitVectors(Qs,si),ms(i,ti,Zs),n.matrixWorld.premultiply(Zs),n.matrixWorld.decompose(n.position,n.quaternion,si),this.zoomDirection.subVectors(i,n.position).normalize()}super._updateZoom()}else if(n.isPerspectiveCamera){const i=this._getPerspectiveTransitionDistance(),n=this._getMaxPerspectiveDistance(),r=o.mapLinear(this.getDistanceToCenter(),i,n,0,1);this._tiltTowardsCenter(o.lerp(0,.4,r*l)),this._alignCameraUpToNorth(o.lerp(0,.2,r*l));const a=t*(this.getDistanceToCenter()-e.radius.x)*s*.0025,c=Math.max(a,Math.min(this.getDistanceToCenter()-n,0));this.getVectorToCenter(Xs).normalize(),this.camera.position.addScaledVector(Xs,c),this.camera.updateMatrixWorld(),this.zoomDelta=0}else{const t=this._getOrthographicTransitionZoom(),e=this._getMinOrthographicZoom(),i=o.mapLinear(n.zoom,t,e,0,1);this._tiltTowardsCenter(o.lerp(0,.4,i*l)),this._alignCameraUpToNorth(o.lerp(0,.2,i*l));const a=this.zoomDelta,c=Math.pow(.95,Math.abs(.05*a)),h=a>0?1/Math.abs(c):c,u=e/n.zoom,d=Math.max(h*s,Math.min(u,1));n.zoom=Math.min(r,n.zoom*d),n.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(t){const{ellipsoidFrame:e}=this;Ks.set(0,0,1).transformDirection(e),this._alignCameraUp(Ks,t)}_tiltTowardsCenter(t){const{camera:e,ellipsoidFrame:s}=this;Qs.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),Xs.setFromMatrixPosition(s).sub(e.position).normalize(),Xs.lerp(Qs,1-t).normalize(),ti.setFromUnitVectors(Qs,Xs),e.quaternion.premultiply(ti),e.updateMatrixWorld()}_getPerspectiveTransitionDistance(){const{camera:t,ellipsoid:e}=this;if(!t.isPerspectiveCamera)throw new Error;const s=Math.max(...e.radius),i=2*Math.atan(Math.tan(o.DEG2RAD*t.fov*.5)*t.aspect),n=s/Math.tan(o.DEG2RAD*t.fov*.5),r=s/Math.tan(.5*i);return Math.max(n,r)}_getMaxPerspectiveDistance(){const{camera:t,ellipsoid:e}=this;if(!t.isPerspectiveCamera)throw new Error;const s=Math.max(...e.radius),i=2*Math.atan(Math.tan(o.DEG2RAD*t.fov*.5)*t.aspect),n=s/Math.tan(o.DEG2RAD*t.fov*.5),r=s/Math.tan(.5*i);return 2*Math.max(n,r)}_getOrthographicTransitionZoom(){const{camera:t,ellipsoid:e}=this;if(!t.isOrthographicCamera)throw new Error;const s=t.top-t.bottom,i=t.right-t.left;return 2*Math.max(s,i)/(2*Math.max(...e.radius))}_getMinOrthographicZoom(){const{camera:t,ellipsoid:e}=this;if(!t.isOrthographicCamera)throw new Error;const s=t.top-t.bottom,i=t.right-t.left;return.7*Math.min(s,i)/(2*Math.max(...e.radius))}_getVirtualOrthoCameraPosition(t,e=this.camera){const{ellipsoidFrame:s,ellipsoidFrameInverse:i,ellipsoid:n}=this;if(!e.isOrthographicCamera)throw new Error;ii.origin.copy(e.position),ii.direction.set(0,0,-1).transformDirection(e.matrixWorld),ii.applyMatrix4(i),n.closestPointToRayEstimate(ii,Ys).applyMatrix4(s);const r=e.top-e.bottom,o=e.right-e.left,a=Math.max(r,o)/e.zoom;Qs.set(0,0,-1).transformDirection(e.matrixWorld);const l=Ys.sub(e.position).dot(Qs);t.copy(e.position).addScaledVector(Qs,l-4*a)}_isNearControls(){const{camera:t}=this;return t.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():t.zoom>this._getOrthographicTransitionZoom()}_raycast(t){const e=super._raycast(t);if(null===e){const{ellipsoid:e,ellipsoidFrame:s,ellipsoidFrameInverse:i}=this;ii.copy(t.ray).applyMatrix4(i);const n=e.intersectRay(ii,Xs);return null!==n?(n.applyMatrix4(s),{point:n.clone(),distance:n.distanceTo(t.ray.origin)}):null}return e}}const li=new t,ci=new t,hi=new y,ui=new t,di=new t,pi=new t,mi=new x,gi=new x;class fi extends d{get animating(){return 0!==this._alpha&&1!==this._alpha}get alpha(){return 0===this._target?1-this._alpha:this._alpha}get camera(){return 0===this._alpha?this.perspectiveCamera:1===this._alpha?this.orthographicCamera:this.transitionCamera}get mode(){return 0===this._target?"perspective":"orthographic"}set mode(t){if(t===this.mode)return;const e=this.camera;"perspective"===t?(this._target=0,this._alpha=0):(this._target=1,this._alpha=1),this.dispatchEvent({type:"camera-change",camera:this.camera,prevCamera:e})}constructor(e=new f,s=new y){super(),this.perspectiveCamera=e,this.orthographicCamera=s,this.transitionCamera=new f,this.orthographicPositionalZoom=!0,this.orthographicOffset=50,this.fixedPoint=new t,this.duration=200,this.autoSync=!0,this.easeFunction=t=>t,this._target=0,this._alpha=0,this._clock=new b}toggle(){this._target=1===this._target?0:1,this._clock.getDelta(),this.dispatchEvent({type:"toggle"})}update(t=Math.min(this._clock.getDelta(),.064)){this.autoSync&&this.syncCameras();const{perspectiveCamera:e,orthographicCamera:s,transitionCamera:i,camera:n}=this,r=1e3*t;if(this._alpha!==this._target){const t=Math.sign(this._target-this._alpha)*r/this.duration;this._alpha=o.clamp(this._alpha+t,0,1),this.dispatchEvent({type:"change",alpha:this.alpha})}const a=n;let l=null;0===this._alpha?l=e:1===this._alpha?l=s:(l=i,this._updateTransitionCamera()),a!==l&&(l===i&&this.dispatchEvent({type:"transition-start"}),this.dispatchEvent({type:"camera-change",camera:l,prevCamera:a}),a===i&&this.dispatchEvent({type:"transition-end"}))}syncCameras(){const t=this._getFromCamera(),{perspectiveCamera:e,orthographicCamera:s,transitionCamera:i,fixedPoint:n}=this;if(li.set(0,0,-1).transformDirection(t.matrixWorld).normalize(),t.isPerspectiveCamera){if(this.orthographicPositionalZoom)s.position.copy(e.position).addScaledVector(li,-this.orthographicOffset),s.rotation.copy(e.rotation),s.updateMatrixWorld();else{const t=ci.subVectors(n,s.position).dot(li),i=ci.subVectors(n,e.position).dot(li);ci.copy(e.position).addScaledVector(li,i),s.rotation.copy(e.rotation),s.position.copy(ci).addScaledVector(li,-t),s.updateMatrixWorld()}const t=Math.abs(ci.subVectors(e.position,n).dot(li)),i=2*Math.tan(o.DEG2RAD*e.fov*.5)*t,r=s.top-s.bottom;s.zoom=r/i,s.updateProjectionMatrix()}else{const t=Math.abs(ci.subVectors(s.position,n).dot(li)),i=(s.top-s.bottom)/s.zoom*.5/Math.tan(o.DEG2RAD*e.fov*.5);e.rotation.copy(s.rotation),e.position.copy(s.position).addScaledVector(li,t).addScaledVector(li,-i),e.updateMatrixWorld(),this.orthographicPositionalZoom&&(s.position.copy(e.position).addScaledVector(li,-this.orthographicOffset),s.updateMatrixWorld())}i.position.copy(e.position),i.rotation.copy(e.rotation)}_getTransitionDirection(){return Math.sign(this._target-this._alpha)}_getToCamera(){const t=this._getTransitionDirection();return 0===t?0===this._target?this.perspectiveCamera:this.orthographicCamera:t>0?this.orthographicCamera:this.perspectiveCamera}_getFromCamera(){const t=this._getTransitionDirection();return 0===t?0===this._target?this.perspectiveCamera:this.orthographicCamera:t>0?this.perspectiveCamera:this.orthographicCamera}_updateTransitionCamera(){const{perspectiveCamera:t,orthographicCamera:e,transitionCamera:s,fixedPoint:i}=this,n=this.easeFunction(this._alpha);li.set(0,0,-1).transformDirection(e.matrixWorld).normalize(),hi.copy(e),hi.position.addScaledVector(li,e.near),e.far-=e.near,e.near=0,li.set(0,0,-1).transformDirection(t.matrixWorld).normalize();const r=Math.abs(ci.subVectors(t.position,i).dot(li)),a=2*Math.tan(o.DEG2RAD*t.fov*.5)*r,l=gi.slerpQuaternions(t.quaternion,hi.quaternion,n),c=o.lerp(t.fov,1,n),h=.5*a/Math.tan(o.DEG2RAD*c*.5),u=pi.copy(hi.position).sub(i).applyQuaternion(mi.copy(hi.quaternion).invert()),d=di.copy(t.position).sub(i).applyQuaternion(mi.copy(t.quaternion).invert()),p=ui.lerpVectors(d,u,n);p.z-=Math.abs(p.z)-h;const m=-(d.z-p.z),g=-(u.z-p.z),f=o.lerp(m+t.near,g+hi.near,n),y=o.lerp(m+t.far,g+hi.far,n),b=Math.max(y,0)-Math.max(f,0);s.aspect=t.aspect,s.fov=c,s.near=Math.max(f,1e-5*b),s.far=y,s.position.copy(p).applyQuaternion(l).add(i),s.quaternion.copy(l),s.updateProjectionMatrix(),s.updateMatrixWorld()}}const yi="https://tile.googleapis.com/v1/createSession";let bi=class{get isMapTilesSession(){return this.authURL===yi}constructor(t={}){const{apiToken:e,sessionOptions:s=null,autoRefreshToken:i=!1}=t;this.apiToken=e,this.autoRefreshToken=i,this.authURL=yi,this.sessionToken=null,this.sessionOptions=s,this._tokenRefreshPromise=null}async fetch(t,e){null===this.sessionToken&&this.isMapTilesSession&&this.refreshToken(e),await this._tokenRefreshPromise;const s=new URL(t);s.searchParams.set("key",this.apiToken),this.sessionToken&&s.searchParams.set("session",this.sessionToken);let i=await fetch(s,e);return i.status>=400&&i.status<=499&&this.autoRefreshToken&&(await this.refreshToken(e),this.sessionToken&&s.searchParams.set("session",this.sessionToken),i=await fetch(s,e)),null!==this.sessionToken||this.isMapTilesSession?i:i.json().then(t=>(this.sessionToken=xi(t),t))}refreshToken(t){if(null===this._tokenRefreshPromise){const e=new URL(this.authURL);e.searchParams.set("key",this.apiToken);const s={...t};this.isMapTilesSession&&(s.method="POST",s.body=JSON.stringify(this.sessionOptions),s.headers=s.headers||{},s.headers={...s.headers,"Content-Type":"application/json"}),this._tokenRefreshPromise=fetch(e,s).then(t=>{if(!t.ok)throw new Error(`GoogleCloudAuth: Failed to load data with error code ${t.status}`);return t.json()}).then(t=>(this.sessionToken=xi(t),this._tokenRefreshPromise=null,t))}return this._tokenRefreshPromise}};function xi(t){if("session"in t)return t.session;{let e=null;return it(t.root,t=>{if(t.content&&t.content.uri){const[,s]=t.content.uri.split("?");return e=new URLSearchParams(s).get("session"),!0}return!1}),e}}let _i=class{constructor(t={}){const{apiToken:e,autoRefreshToken:s=!1}=t;this.apiToken=e,this.autoRefreshToken=s,this.authURL=null,this._tokenRefreshPromise=null,this._bearerToken=null}async fetch(t,e){await this._tokenRefreshPromise;const s={...e};s.headers=s.headers||{},s.headers={...s.headers,Authorization:this._bearerToken};const i=await fetch(t,s);return i.status>=400&&i.status<=499&&this.autoRefreshToken?(await this.refreshToken(e),s.headers.Authorization=this._bearerToken,fetch(t,s)):i}refreshToken(t){if(null===this._tokenRefreshPromise){const e=new URL(this.authURL);e.searchParams.set("access_token",this.apiToken),this._tokenRefreshPromise=fetch(e,t).then(t=>{if(!t.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${t.status}`);return t.json()}).then(t=>(this._bearerToken=`Bearer ${t.accessToken}`,this._tokenRefreshPromise=null,t))}return this._tokenRefreshPromise}};function Ti(t){return t>>1^-(1&t)}let vi=class extends lt{constructor(...t){super(...t),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...t){const{fetchOptions:e}=this;return e.header=e.header||{},e.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",e.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...t)}parse(t){let e=0;const s=new DataView(t),i=()=>{const t=s.getFloat64(e,!0);return e+=8,t},n=()=>{const t=s.getFloat32(e,!0);return e+=4,t},r=()=>{const t=s.getUint32(e,!0);return e+=4,t},o=()=>{const t=s.getUint8(e);return e+=1,t},a=(s,i)=>{const n=new i(t,e,s);return e+=s*i.BYTES_PER_ELEMENT,n},l={center:[i(),i(),i()],minHeight:n(),maxHeight:n(),sphereCenter:[i(),i(),i()],sphereRadius:i(),horizonOcclusionPoint:[i(),i(),i()]},c=r(),h=a(c,Uint16Array),u=a(c,Uint16Array),d=a(c,Uint16Array),p=new Float32Array(c),m=new Float32Array(c),g=new Float32Array(c);let f=0,y=0,b=0;const x=32767;for(let F=0;F<c;++F)f+=Ti(h[F]),y+=Ti(u[F]),b+=Ti(d[F]),p[F]=f/x,m[F]=y/x,g[F]=b/x;const _=c>65536,T=_?Uint32Array:Uint16Array;e=_?4*Math.ceil(e/4):2*Math.ceil(e/2);const v=a(3*r(),T);let w=0;for(var P=0;P<v.length;++P){const t=v[P];v[P]=w-t,0===t&&++w}const M=(t,e)=>m[e]-m[t],C=(t,e)=>p[t]-p[e],S=a(r(),T);S.sort(M);const A=a(r(),T);A.sort(C);const E=a(r(),T);E.sort((t,e)=>-M(t,e));const L=a(r(),T);L.sort((t,e)=>-C(t,e));const U={westIndices:S,southIndices:A,eastIndices:E,northIndices:L},D={};for(;e<s.byteLength;){const t=o(),e=r();if(1===t){const e=a(2*c,Uint8Array),s=new Float32Array(3*c);for(let t=0;t<c;t++){let i=e[2*t+0]/255*2-1,n=e[2*t+1]/255*2-1;const r=1-(Math.abs(i)+Math.abs(n));if(r<0){const t=i;i=(1-Math.abs(n))*wi(t),n=(1-Math.abs(t))*wi(n)}const o=Math.sqrt(i*i+n*n+r*r);s[3*t+0]=i/o,s[3*t+1]=n/o,s[3*t+2]=r/o}D.octvertexnormals={extensionId:t,normals:s}}else if(2===t){const s=1===e?1:256,i=a(s*s,Uint8Array);D.watermask={extensionId:t,mask:i,size:s}}else if(4===t){const e=a(r(),Uint8Array),s=(new TextDecoder).decode(e);D.metadata={extensionId:t,json:JSON.parse(s)}}}return{header:l,indices:v,vertexData:{u:p,v:m,height:g},edgeIndices:U,extensions:D}}};function wi(t){return t<0?-1:1}class Pi{constructor(){this.creditsCount={}}_adjustAttributions(t,e){const s=this.creditsCount,i=t.split(/;/g);for(let n=0,r=i.length;n<r;n++){const t=i[n];t in s||(s[t]=0),s[t]+=e?1:-1,s[t]<=0&&delete s[t]}}addAttributions(t){this._adjustAttributions(t,!0)}removeAttributions(t){this._adjustAttributions(t,!1)}toString(){return Object.entries(this.creditsCount).sort((t,e)=>{const s=t[1];return e[1]-s}).map(t=>t[0]).join("; ")}}class Mi{constructor({apiToken:t,sessionOptions:e=null,autoRefreshToken:s=!1,logoUrl:i=null,useRecommendedSettings:n=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.apiToken=t,this.useRecommendedSettings=n,this.logoUrl=i,this.auth=new bi({apiToken:t,autoRefreshToken:s,sessionOptions:e}),this.tiles=null,this._visibilityChangeCallback=null,this._attributionsManager=new Pi,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(t){const{useRecommendedSettings:e,auth:s}=this;t.resetFailedTiles(),null==t.rootURL&&(t.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),s.sessionOptions||(s.authURL=t.rootURL),e&&!s.isMapTilesSession&&(t.errorTarget=20),this.tiles=t,this._visibilityChangeCallback=({tile:t,visible:e})=>{var s,i;const n=(null==(i=null==(s=t.cached.metadata)?void 0:s.asset)?void 0:i.copyright)||"";e?this._attributionsManager.addAttributions(n):this._attributionsManager.removeAttributions(n)},t.addEventListener("tile-visibility-change",this._visibilityChangeCallback)}getAttributions(t){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,t.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),t.push(this._attribution))}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(t,e){return this.auth.fetch(t,e)}}const Ci=new p,Si=Symbol("TILE_X"),Ai=Symbol("TILE_Y"),Ei=Symbol("TILE_LEVEL");class Li{get tiling(){return this.imageSource.tiling}constructor(t={}){const{pixelSize:e=null,center:s=!1,useRecommendedSettings:i=!0,imageSource:n=null}=t;this.priority=-10,this.tiles=null,this.imageSource=n,this.pixelSize=e,this.center=s,this.useRecommendedSettings=i,null!==e&&console.warn('ImageFormatPlugin: "pixelSize" has been deprecated in favor of scaling the tiles root.')}init(t){this.useRecommendedSettings&&(t.errorTarget=1),this.tiles=t,this.imageSource.fetchOptions=t.fetchOptions,this.imageSource.fetchData=(e,s)=>(t.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),t.invokeOnePlugin(t=>t!==this&&t.fetchData&&t.fetchData(e,s)))}async loadRootTileSet(){const{tiles:t,imageSource:e}=this;return e.url=e.url||t.rootURL,t.invokeAllPlugins(t=>e.url=t.preprocessURL?t.preprocessURL(e.url,null):e.url),await e.init(),t.rootURL=e.url,this.getTileset(e.url)}async parseToMesh(t,e,s,i,n){if(n.aborted)return null;const{imageSource:r}=this,a=e[Si],l=e[Ai],c=e[Ei],h=await r.processBufferToTexture(t);if(n.aborted)return h.dispose(),h.image.close(),null;r.setData(a,l,c,h);let u=1,d=1,p=0,m=0,g=0;const f=e.boundingVolume.box;f&&([p,m,g]=f,u=f[3],d=f[7]);const y=new U(2*u,2*d),b=new L(y,new N({map:h,transparent:!0}));b.position.set(p,m,g);const x=r.tiling.getTileContentUVBounds(a,l,c),{uv:_}=y.attributes;for(let T=0;T<_.count;T++)Ci.fromBufferAttribute(_,T),Ci.x=o.mapLinear(Ci.x,0,1,x[0],x[2]),Ci.y=o.mapLinear(Ci.y,0,1,x[1],x[3]),_.setXY(T,Ci.x,Ci.y);return b}preprocessNode(t){const{tiling:e}=this,s=e.maxLevel;t[Ei]<s&&null!==t.parent&&this.expandChildren(t)}disposeTile(t){const e=t[Si],s=t[Ai],i=t[Ei],{imageSource:n}=this;n.has(e,s,i)&&n.release(e,s,i)}getTileset(t){const{tiling:e,tiles:s}=this,i=e.minLevel,{tileCountX:n,tileCountY:r}=e.getLevel(i),o=[];for(let l=0;l<n;l++)for(let t=0;t<r;t++){const e=this.createChild(l,t,i);null!==e&&o.push(e)}const a={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:o,[Ei]:-1,[Si]:0,[Ai]:0}};return s.preprocessTileSet(a,t),a}getUrl(t,e,s){return this.imageSource.getUrl(t,e,s)}createBoundingVolume(t,e,s){const{center:i,pixelSize:n,tiling:r}=this,{pixelWidth:o,pixelHeight:a}=r.getLevel(r.maxLevel),[l,c,h,u]=-1===s?r.getContentBounds(!0):r.getTileBounds(t,e,s,!0);let d=(h-l)/2,p=(u-c)/2,m=l+d,g=c+p;return i&&(m-=.5,g-=.5),n?(m*=o*n,d*=o*n,g*=a*n,p*=a*n):(m*=r.aspectRatio,d*=r.aspectRatio),{box:[m,g,0,d,0,0,0,p,0,0,0,0]}}createChild(t,e,s){const{pixelSize:i,tiling:n}=this;if(!n.getTileExists(t,e,s))return null;const{pixelWidth:r,pixelHeight:o}=n.getLevel(n.maxLevel),{pixelWidth:a,pixelHeight:l}=n.getLevel(s);let c=Math.max(1/a,1/l);return i&&(c*=i*Math.max(r,o)),{refine:"REPLACE",geometricError:c,boundingVolume:this.createBoundingVolume(t,e,s),content:{uri:this.getUrl(t,e,s)},children:[],[Si]:t,[Ai]:e,[Ei]:s}}expandChildren(t){const e=t[Ei],s=t[Si],i=t[Ai];for(let n=0;n<2;n++)for(let r=0;r<2;r++){const o=this.createChild(2*s+n,2*i+r,e+1);o&&t.children.push(o)}}}const Ui=new t,Di=new t;const Fi=new t,Ii=new t,Ri=new p,ki=new s;class Oi extends Li{get projection(){return this.tiling.projection}constructor(t={}){const{shape:e="planar",endCaps:s=!0,...i}=t;super(i),this.shape=e,this.endCaps=s}async parseToMesh(t,e,...s){const i=await super.parseToMesh(t,e,...s),{shape:n,projection:r,tiles:a,tiling:l}=this;if("ellipsoid"===n){const t=a.ellipsoid,s=e[Ei],n=e[Si],c=e[Ai],[h,u,d,p]=e.boundingVolume.region,m=Math.ceil((p-u)*o.RAD2DEG*.25),g=Math.ceil((d-h)*o.RAD2DEG*.25),f=Math.max(15,m),y=Math.max(30,g),b=new U(1,1,y,f),[x,_,T,v]=l.getTileBounds(n,c,s,!0,!0),w=l.getTileContentUVBounds(n,c,s),{position:P,normal:M,uv:C}=b.attributes,S=P.count;e.cached.boundingVolume.getSphere(ki);for(let e=0;e<S;e++){Fi.fromBufferAttribute(P,e),Ri.fromBufferAttribute(C,e);const s=r.convertProjectionToLongitude(o.mapLinear(Ri.x,0,1,x,T));let i=r.convertProjectionToLatitude(o.mapLinear(Ri.y,0,1,_,v));if(r.isMercator&&this.endCaps&&(1===v&&1===Ri.y&&(i=Math.PI/2),0===_&&0===Ri.y&&(i=-Math.PI/2)),r.isMercator&&0!==Ri.y&&1!==Ri.y){const t=r.convertProjectionToLatitude(1),e=1/f,s=o.mapLinear(Ri.y-e,0,1,u,p),n=o.mapLinear(Ri.y+e,0,1,u,p);i>t&&s<t&&(i=t),i<-t&&n>-t&&(i=-t)}t.getCartographicToPosition(i,s,0,Fi).sub(ki.center),t.getCartographicToNormal(i,s,Ii);const n=o.mapLinear(r.convertLongitudeToProjection(s),x,T,w[0],w[2]),a=o.mapLinear(r.convertLatitudeToProjection(i),_,v,w[1],w[3]);C.setXY(e,n,a),P.setXYZ(e,...Fi),M.setXYZ(e,...Ii)}i.geometry=b,i.position.copy(ki.center)}return i}createBoundingVolume(t,e,s){if("ellipsoid"===this.shape){const{tiling:i,endCaps:n}=this,r=-1===s,o=r?i.getContentBounds(!0):i.getTileBounds(t,e,s,!0,!0),a=r?i.getContentBounds():i.getTileBounds(t,e,s,!1,!0);return n&&(1===o[3]&&(a[3]=Math.PI/2),0===o[1]&&(a[1]=-Math.PI/2)),{region:[...a,-1,1]}}return super.createBoundingVolume(t,e,s)}createChild(...t){const e=super.createChild(...t),{shape:s,projection:i,tiling:n}=this;if(e&&"ellipsoid"===s){const t=e[Ei],s=e[Si],r=e[Ai];if(-1===t)return e.geometricError=1e50,parent;const[o,a,l,c]=n.getTileBounds(s,r,t,!0),{tilePixelWidth:h,tilePixelHeight:u}=n.getLevel(t),d=(l-o)/h,p=(c-a)/u,[,m,g,f]=n.getTileBounds(s,r,t),y=m>0!=f>0?0:Math.min(Math.abs(m),Math.abs(f)),b=i.convertLatitudeToProjection(y),x=i.getLongitudeDerivativeAtProjection(o),_=i.getLatitudeDerivativeAtProjection(b),[T,v]=function(t,e,s){const i=s+1e-5;let n=e+1e-5;Math.abs(n)>Math.PI/2&&(n-=1e-5),t.getCartographicToPosition(e,s,0,Ui),t.getCartographicToPosition(n,s,0,Di);const r=Ui.distanceTo(Di)/1e-5;return t.getCartographicToPosition(e,i,0,Di),[Ui.distanceTo(Di)/1e-5,r]}(this.tiles.ellipsoid,y,g),w=Math.max(d*x*T,p*_*v);e.geometricError=w}return e}}class Vi{get isMercator(){return"EPSG:3857"===this.scheme}constructor(t="EPSG:4326"){this.scheme=t,this.tileCountX=1,this.tileCountY=1,this.setScheme(t)}setScheme(t){switch(this.scheme=t,t){case"EPSG:4326":this.tileCountX=2,this.tileCountY=1;break;case"EPSG:3857":this.tileCountX=1,this.tileCountY=1;break;default:throw new Error}}convertProjectionToLatitude(t){if(this.isMercator){const e=o.mapLinear(t,0,1,-1,1);return 2*Math.atan(Math.exp(e*Math.PI))-Math.PI/2}return o.mapLinear(t,0,1,-Math.PI/2,Math.PI/2)}convertProjectionToLongitude(t){return o.mapLinear(t,0,1,-Math.PI,Math.PI)}convertLatitudeToProjection(t){if(this.isMercator){return.5+1*Math.log(Math.tan(Math.PI/4+t/2))/(2*Math.PI)}return o.mapLinear(t,-Math.PI/2,Math.PI/2,0,1)}convertLongitudeToProjection(t){return(t+Math.PI)/(2*Math.PI)}getLongitudeDerivativeAtProjection(t){return 2*Math.PI}getLatitudeDerivativeAtProjection(t){let e=t-1e-5;return e<0&&(e=t+1e-5),this.isMercator?Math.abs(this.convertProjectionToLatitude(t)-this.convertProjectionToLatitude(e))/1e-5:Math.PI}getBounds(){return[this.convertProjectionToLongitude(0),this.convertProjectionToLatitude(0),this.convertProjectionToLongitude(1),this.convertProjectionToLatitude(1)]}}function zi(...t){return t.join("_")}class Bi{constructor(){this.cache={},this.count=0,this.cachedBytes=0,this.active=0}fetchItem(){}disposeItem(){}getMemoryUsage(t){return 0}setData(...t){const{cache:e}=this,s=t.pop(),i=zi(...t);if(i in e)throw new Error(`DataCache: "${i}" is already present.`);return this.cache[i]={abortController:new AbortController,result:s,count:1,bytes:this.getMemoryUsage(s)},this.count++,this.cachedBytes+=this.cache[i].bytes,s}lock(...t){const{cache:e}=this,s=zi(...t);if(s in e)e[s].count++;else{const e=new AbortController,i={abortController:e,result:null,count:1,bytes:0};this.active++,i.result=this.fetchItem(t,e.signal),i.result instanceof Promise?i.result.then(t=>(i.result=t,i.bytes=this.getMemoryUsage(t),this.cachedBytes+=i.bytes,t)).finally(()=>{this.active--}).catch(t=>{}):(this.active--,i.bytes=this.getMemoryUsage(i.result),this.cachedBytes+=i.bytes),this.cache[s]=i,this.count++}return e[s].result}release(...t){const e=zi(...t);this.releaseViaFullKey(e)}get(...t){const{cache:e}=this,s=zi(...t);return s in e&&e[s].count>0?e[s].result:null}has(...t){const{cache:e}=this;return zi(...t)in e}dispose(){const{cache:t}=this;for(const e in t){const{abortController:s}=t[e];s.abort(),this.releaseViaFullKey(e,!0)}this.cache={}}releaseViaFullKey(t,e=!1){const{cache:s}=this;if(t in s&&s[t].count>0){const i=s[t];if(i.count--,0===i.count||e){const n=()=>{if(s[t]!==i)return;const{result:e,abortController:n}=i;n.abort(),e instanceof Promise?e.then(t=>{this.disposeItem(t),this.count--,this.cachedBytes-=i.bytes}).catch(()=>{}):(this.disposeItem(e),this.count--,this.cachedBytes-=i.bytes),delete s[t]};e?n():queueMicrotask(()=>{0===i.count&&n()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}class Ni{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const t=this._levels;for(let e=0;e<t.length;e++)if(null!==t[e])return e;return-1}get contentBounds(){var t;return this._contentBounds??(null==(t=this.projection)?void 0:t.getBounds())??[0,0,1,1]}get aspectRatio(){const{pixelWidth:t,pixelHeight:e}=this.getLevel(this.maxLevel);return t/e}constructor(){this.flipY=!1,this.pixelOverlap=0,this._contentBounds=null,this.projection=null,this._levels=[]}setLevel(t,e={}){const s=this._levels;for(;s.length<t;)s.push(null);const{tilePixelWidth:i=256,tilePixelHeight:n=256,tileCountX:r=2**t,tileCountY:o=2**t,tileBounds:a=null}=e,{pixelWidth:l=i*r,pixelHeight:c=n*o}=e;s[t]={tilePixelWidth:i,tilePixelHeight:n,pixelWidth:l,pixelHeight:c,tileCountX:r,tileCountY:o,tileBounds:a}}generateLevels(t,e,s,i={}){const{minLevel:n=0,tilePixelWidth:r=256,tilePixelHeight:o=256}=i,a=t-1,{pixelWidth:l=r*e*2**a,pixelHeight:c=o*s*2**a}=i;for(let h=n;h<t;h++){const e=t-h-1,s=Math.ceil(l*2**-e),i=Math.ceil(c*2**-e),n=Math.ceil(s/r),a=Math.ceil(i/o);this.setLevel(h,{tilePixelWidth:r,tilePixelHeight:o,pixelWidth:s,pixelHeight:i,tileCountX:n,tileCountY:a})}}getLevel(t){return this._levels[t]}setContentBounds(t,e,s,i){this._contentBounds=[t,e,s,i]}setProjection(t){this.projection=t}getTileAtPoint(t,e,s,i=!1){const{flipY:n}=this,{tileCountX:r,tileCountY:a,tileBounds:l}=this.getLevel(s),c=1/r,h=1/a;if(i||([t,e]=this.toNormalizedPoint(t,e)),l){const s=this.toNormalizedRange(l);t=o.mapLinear(t,s[0],s[2],0,1),e=o.mapLinear(e,s[1],s[3],0,1)}const u=Math.floor(t/c);let d=Math.floor(e/h);return n&&(d=a-1-d),[u,d]}getTilesInRange(t,e,s,i,n,r=!1){[t,e,s,i]=this.clampToContentBounds([t,e,s,i],r);const a=this.getTileAtPoint(t,e,n,r),l=this.getTileAtPoint(s,i,n,r);this.flipY&&([a[1],l[1]]=[l[1],a[1]]);const{tileCountX:c,tileCountY:h}=this.getLevel(n),[u,d]=a,[p,m]=l;return p<0||m<0||u>=c||d>=h?[0,0,-1,-1]:[o.clamp(u,0,c-1),o.clamp(d,0,h-1),o.clamp(p,0,c-1),o.clamp(m,0,h-1)]}getTileExists(t,e,s){const[i,n,r,o]=this.contentBounds,[a,l,c,h]=this.getTileBounds(t,e,s);return!(a>=c||l>=h)&&a<=r&&l<=o&&c>=i&&h>=n}getContentBounds(t=!1){const{projection:e}=this,s=[...this.contentBounds];return e&&t&&(s[0]=e.convertLongitudeToProjection(s[0]),s[1]=e.convertLatitudeToProjection(s[1]),s[2]=e.convertLongitudeToProjection(s[2]),s[3]=e.convertLatitudeToProjection(s[3])),s}getTileContentUVBounds(t,e,s){const[i,n,r,a]=this.getTileBounds(t,e,s,!0,!0),[l,c,h,u]=this.getTileBounds(t,e,s,!0,!1);return[o.mapLinear(i,l,h,0,1),o.mapLinear(n,c,u,0,1),o.mapLinear(r,l,h,0,1),o.mapLinear(a,c,u,0,1)]}getTileBounds(t,e,s,i=!1,n=!0){const{flipY:r,pixelOverlap:a,projection:l}=this,{tilePixelWidth:c,tilePixelHeight:h,pixelWidth:u,pixelHeight:d,tileBounds:p}=this.getLevel(s);let m=c*t-a,g=h*e-a,f=m+c+2*a,y=g+h+2*a;if(m=Math.max(m,0),g=Math.max(g,0),f=Math.min(f,u),y=Math.min(y,d),m/=u,f/=u,g/=d,y/=d,r){const t=(y-g)/2,e=1-(g+y)/2;g=e-t,y=e+t}let b=[m,g,f,y];if(p){const t=this.toNormalizedRange(p);b[0]=o.mapLinear(b[0],0,1,t[0],t[2]),b[2]=o.mapLinear(b[2],0,1,t[0],t[2]),b[1]=o.mapLinear(b[1],0,1,t[1],t[3]),b[3]=o.mapLinear(b[3],0,1,t[1],t[3])}return n&&(b=this.clampToProjectionBounds(b,!0)),l&&!i&&(b[0]=l.convertProjectionToLongitude(b[0]),b[1]=l.convertProjectionToLatitude(b[1]),b[2]=l.convertProjectionToLongitude(b[2]),b[3]=l.convertProjectionToLatitude(b[3])),b}toNormalizedPoint(t,e){const{projection:s}=this,i=[t,e];return this.projection&&(i[0]=s.convertLongitudeToProjection(i[0]),i[1]=s.convertLatitudeToProjection(i[1])),i}toNormalizedRange(t){return[...this.toNormalizedPoint(t[0],t[1]),...this.toNormalizedPoint(t[2],t[3])]}toCartographicPoint(t,e){const{projection:s}=this,i=[t,e];if(!this.projection)throw new Error("TilingScheme: Projection not available.");return i[0]=s.convertProjectionToLongitude(i[0]),i[1]=s.convertProjectionToLatitude(i[1]),i}toCartographicRange(t){return[...this.toCartographicPoint(t[0],t[1]),...this.toCartographicPoint(t[2],t[3])]}clampToContentBounds(t,e=!1){const s=[...t],[i,n,r,a]=this.getContentBounds(e);return s[0]=o.clamp(s[0],i,r),s[1]=o.clamp(s[1],n,a),s[2]=o.clamp(s[2],i,r),s[3]=o.clamp(s[3],n,a),s}clampToProjectionBounds(t,e=!1){const s=[...t],{projection:i}=this;let n;n=e||!i?[0,0,1,1]:i.getBounds();const[r,a,l,c]=n;return s[0]=o.clamp(s[0],r,l),s[1]=o.clamp(s[1],a,c),s[2]=o.clamp(s[2],r,l),s[3]=o.clamp(s[3],a,c),s}}class ji extends Bi{constructor(){super(),this.tiling=new Ni,this.fetchOptions={},this.fetchData=(...t)=>fetch(...t)}init(){}async processBufferToTexture(t){const e=new Blob([t]),s=await createImageBitmap(e,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),i=new j(s);return i.generateMipmaps=!1,i.colorSpace=W,i.needsUpdate=!0,i}getMemoryUsage(t){const{TextureUtils:e}=h;if(!e)return 0;const{format:s,type:i,image:n,generateMipmaps:r}=t,{width:o,height:a}=n,l=e.getByteLength(o,a,s,i);return r?4*l/3:l}fetchItem(t,e){const s={...this.fetchOptions,signal:e},i=this.getUrl(...t);return this.fetchData(i,s).then(t=>t.arrayBuffer()).then(t=>this.processBufferToTexture(t))}disposeItem(t){t.dispose(),t.image instanceof ImageBitmap&&t.image.close()}getUrl(...t){}}class Wi extends ji{constructor(t={}){const{url:e=null}=t;super(),this.tileSets=null,this.extension=null,this.url=e}getUrl(t,e,s){const{url:i,extension:n,tileSets:r,tiling:o}=this;return new URL(`${parseInt(r[s-o.minLevel].href)}/${t}/${e}.${n}`,i).toString()}init(){const{url:t}=this;return this.fetchData(new URL("tilemapresource.xml",t),this.fetchOptions).then(t=>t.text()).then(e=>{const{tiling:s}=this,i=(new DOMParser).parseFromString(e,"text/xml"),n=i.querySelector("BoundingBox"),r=i.querySelector("TileFormat"),a=[...i.querySelector("TileSets").querySelectorAll("TileSet")].map(t=>({href:parseInt(t.getAttribute("href")),unitsPerPixel:parseFloat(t.getAttribute("units-per-pixel")),order:parseInt(t.getAttribute("order"))})).sort((t,e)=>t.order-e.order),l=parseFloat(n.getAttribute("minx"))*o.DEG2RAD,c=parseFloat(n.getAttribute("maxx"))*o.DEG2RAD,h=parseFloat(n.getAttribute("miny"))*o.DEG2RAD,u=parseFloat(n.getAttribute("maxy"))*o.DEG2RAD,d=parseInt(r.getAttribute("width")),p=parseInt(r.getAttribute("height")),m=r.getAttribute("extension"),g=i.querySelector("SRS").textContent;this.extension=m,this.url=t,this.tileSets=a,s.setProjection(new Vi(g)),s.setContentBounds(l,h,c,u),a.forEach(({order:t})=>{s.setLevel(t,{tileCountX:s.projection.tileCountX*2**t,tilePixelWidth:d,tilePixelHeight:p})})})}}class Gi extends Oi{constructor(t={}){const{url:e,...s}=t;super(s),this.name="TMS_TILES_PLUGIN",this.imageSource=new Wi({url:e})}}const Hi=new t,qi=new B,Zi=new t,Yi=new t;class Xi extends vi{constructor(t=T){super(),this.manager=t,this.ellipsoid=new Yt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(t){const{ellipsoid:e,solid:s,skirtLength:i,smoothSkirtNormals:n,minLat:r,maxLat:a,minLon:l,maxLon:c}=this,{header:h,indices:u,vertexData:d,edgeIndices:p,extensions:m}=super.parse(t),g=new P,f=new O,y=new L(g,f);y.position.set(...h.center);const b="octvertexnormals"in m,x=d.u.length,_=[],T=[],v=[],w=[];let C=0,S=0;for(let o=0;o<x;o++)E(o,Zi),U(Zi.x,Zi.y,Zi.z,Yi),T.push(Zi.x,Zi.y),_.push(...Yi);for(let o=0,P=u.length;o<P;o++)v.push(u[o]);if(b){const t=m.octvertexnormals.normals;for(let e=0,s=t.length;e<s;e++)w.push(t[e])}if(g.addGroup(C,u.length,S),C+=u.length,S++,s){const t=_.length/3;for(let e=0;e<x;e++)E(e,Zi),U(Zi.x,Zi.y,Zi.z,Yi,-i),T.push(Zi.x,Zi.y),_.push(...Yi);for(let e=u.length-1;e>=0;e--)v.push(u[e]+t);if(b){const t=m.octvertexnormals.normals;for(let e=0,s=t.length;e<s;e++)w.push(-t[e])}g.addGroup(C,u.length,S),C+=u.length,S++}if(i>0){const{westIndices:t,eastIndices:e,southIndices:s,northIndices:i}=p;let n;const r=D(t);n=_.length/3,T.push(...r.uv),_.push(...r.positions);for(let c=0,h=r.indices.length;c<h;c++)v.push(r.indices[c]+n);const o=D(e);n=_.length/3,T.push(...o.uv),_.push(...o.positions);for(let c=0,h=o.indices.length;c<h;c++)v.push(o.indices[c]+n);const a=D(s);n=_.length/3,T.push(...a.uv),_.push(...a.positions);for(let c=0,h=a.indices.length;c<h;c++)v.push(a.indices[c]+n);const l=D(i);n=_.length/3,T.push(...l.uv),_.push(...l.positions);for(let c=0,h=l.indices.length;c<h;c++)v.push(l.indices[c]+n);b&&(w.push(...r.normals),w.push(...o.normals),w.push(...a.normals),w.push(...l.normals)),g.addGroup(C,u.length,S),C+=u.length,S++}for(let o=0,P=_.length;o<P;o+=3)_[o+0]-=h.center[0],_[o+1]-=h.center[1],_[o+2]-=h.center[2];const A=_.length/3>65535?new Uint32Array(v):new Uint16Array(v);if(g.setIndex(new M(A,1,!1)),g.setAttribute("position",new M(new Float32Array(_),3,!1)),g.setAttribute("uv",new M(new Float32Array(T),2,!1)),b&&g.setAttribute("normal",new M(new Float32Array(w),3,!1)),"watermask"in m){const{mask:t,size:e}=m.watermask,s=new Uint8Array(2*e*e);for(let n=0,r=t.length;n<r;n++){const e=255===t[n]?0:255;s[2*n+0]=e,s[2*n+1]=e}const i=new V(s,e,e,I,R);i.flipY=!0,i.minFilter=z,i.magFilter=F,i.needsUpdate=!0,f.roughnessMap=i}return y.userData.minHeight=h.minHeight,y.userData.maxHeight=h.maxHeight,"metadata"in m&&(y.userData.metadata=m.metadata.json),y;function E(t,e){return e.x=d.u[t],e.y=d.v[t],e.z=d.height[t],e}function U(t,s,i,n,u=0){const d=o.lerp(h.minHeight,h.maxHeight,i),p=o.lerp(l,c,t),m=o.lerp(r,a,s);return e.getCartographicToPosition(m,p,d+u,n),n}function D(t){const e=[],s=[],r=[],o=[],a=[];for(let n=0,h=t.length;n<h;n++)E(t[n],Zi),e.push(Zi.x,Zi.y),r.push(Zi.x,Zi.y),U(Zi.x,Zi.y,Zi.z,Yi),s.push(...Yi),U(Zi.x,Zi.y,Zi.z,Yi,-i),o.push(...Yi);const l=t.length-1;for(let i=0;i<l;i++){const e=i,s=i+1,n=i+t.length,r=i+t.length+1;a.push(e,n,s),a.push(s,n,r)}let c=null;if(b){const e=(s.length+o.length)/3;if(n){c=new Array(3*e);const s=m.octvertexnormals.normals,i=c.length/2;for(let n=0,r=e/2;n<r;n++){const e=t[n],r=3*n,o=s[3*e+0],a=s[3*e+1],l=s[3*e+2];c[r+0]=o,c[r+1]=a,c[r+2]=l,c[i+r+0]=o,c[i+r+1]=a,c[i+r+2]=l}}else{c=[],qi.a.fromArray(s,0),qi.b.fromArray(o,0),qi.c.fromArray(s,3),qi.getNormal(Hi);for(let t=0;t<e;t++)c.push(...Hi)}}return{uv:[...e,...r],positions:[...s,...o],indices:a,normals:c}}}}const $i=["a","b","c"],Qi=new G,Ji=new G,Ki=new G,tn=new G;class en{constructor(){this.attributeList=null,this.splitOperations=[],this.trianglePool=new sn}forEachSplitPermutation(t){const{splitOperations:e}=this,s=(i=0)=>{i>=e.length?t():(e[i].keepPositive=!0,s(i+1),e[i].keepPositive=!1,s(i+1))};s()}addSplitOperation(t,e=!0){this.splitOperations.push({callback:t,keepPositive:e})}clearSplitOperations(){this.splitOperations.length=0}clipObject(t){const e=t.clone(),s=[];return e.traverse(t=>{t.isMesh&&(t.geometry=this.clip(t).geometry,0==(t.geometry.index?t.geometry.index.count/3:t.attributes.position.count/3)&&s.push(t))}),s.forEach(t=>{t.removeFromParent()}),e}clip(t,e=null){const s=this.getClippedData(t,e);return this.constructMesh(s.attributes,s.index,t)}getClippedData(t,e=null,s={}){const{trianglePool:i,splitOperations:n,attributeList:r}=this,o=t.geometry,a=o.attributes.position,l=o.index;let c=0;const h={};s.index=s.index||[],s.vertexIsClipped=s.vertexIsClipped||[],s.attributes=s.attributes||{};for(const m in o.attributes){if(null!==r){if(r instanceof Function&&!r(m))continue;if(Array.isArray(r)&&!r.includes(m))continue}s.attributes[m]=[]}let u=0,d=l?l.count:a.count;null!==e&&(u=e.start,d=e.count);for(let m=u,g=u+d;m<g;m+=3){let e=m+0,s=m+1,r=m+2;l&&(e=l.getX(e),s=l.getX(s),r=l.getX(r));const a=i.get();a.initFromIndices(e,s,r);let c=[a];for(let i=0;i<n.length;i++){const{keepPositive:e,callback:s}=n[i],r=[];for(let i=0;i<c.length;i++){const n=c[i],{indices:a,barycoord:l}=n;n.clipValues.a=s(o,a.a,a.b,a.c,l.a,t.matrixWorld),n.clipValues.b=s(o,a.a,a.b,a.c,l.b,t.matrixWorld),n.clipValues.c=s(o,a.a,a.b,a.c,l.c,t.matrixWorld),this.splitTriangle(n,!e,r)}c=r}for(let t=0,i=c.length;t<i;t++){p(c[t],o)}i.reset()}return s;function p(t,e){for(let i=0;i<3;i++){const n=t.getVertexHash(i,e);n in h||(h[n]=c,c++,t.getVertexData(i,e,s.attributes),s.vertexIsClipped.push(0===t.clipValues[$i[i]]));const r=h[n];s.index.push(r)}}}constructMesh(t,e,s){const i=s.geometry,n=new P,r=t.position.length/3>65535?new Uint32Array(e):new Uint16Array(e);n.setIndex(new M(r,1,!1));for(const a in t){const e=i.getAttribute(a),s=new e.array.constructor(t[a]),r=new M(s,e.itemSize,e.normalized);r.gpuType=e.gpuType,n.setAttribute(a,r)}const o=new L(n,s.material.clone());return o.position.copy(s.position),o.quaternion.copy(s.quaternion),o.scale.copy(s.scale),o}splitTriangle(t,e,s){const{trianglePool:i}=this,n=[],r=[],a=[];for(let l=0;l<3;l++){const e=$i[l],s=$i[(l+1)%3],i=t.clipValues[e],c=t.clipValues[s];(i<0!=c<0||0===i)&&(n.push(l),r.push([e,s]),i===c?a.push(0):a.push(o.mapLinear(0,i,c,0,1)))}if(2!==n.length)Math.min(t.clipValues.a,t.clipValues.b,t.clipValues.c)<0===e&&s.push(t);else if(2===n.length){const o=i.get().initFromTriangle(t),l=i.get().initFromTriangle(t),c=i.get().initFromTriangle(t);let h,u;(n[0]+1)%3===n[1]?(o.lerpVertexFromEdge(t,r[0][0],r[0][1],a[0],"a"),o.copyVertex(t,r[0][1],"b"),o.lerpVertexFromEdge(t,r[1][0],r[1][1],a[1],"c"),o.clipValues.a=0,o.clipValues.c=0,l.lerpVertexFromEdge(t,r[0][0],r[0][1],a[0],"a"),l.copyVertex(t,r[1][1],"b"),l.copyVertex(t,r[0][0],"c"),l.clipValues.a=0,c.lerpVertexFromEdge(t,r[0][0],r[0][1],a[0],"a"),c.lerpVertexFromEdge(t,r[1][0],r[1][1],a[1],"b"),c.copyVertex(t,r[1][1],"c"),c.clipValues.a=0,c.clipValues.b=0):(o.lerpVertexFromEdge(t,r[0][0],r[0][1],a[0],"a"),o.lerpVertexFromEdge(t,r[1][0],r[1][1],a[1],"b"),o.copyVertex(t,r[0][0],"c"),o.clipValues.a=0,o.clipValues.b=0,l.lerpVertexFromEdge(t,r[0][0],r[0][1],a[0],"a"),l.copyVertex(t,r[0][1],"b"),l.lerpVertexFromEdge(t,r[1][0],r[1][1],a[1],"c"),l.clipValues.a=0,l.clipValues.c=0,c.copyVertex(t,r[0][1],"a"),c.copyVertex(t,r[1][0],"b"),c.lerpVertexFromEdge(t,r[1][0],r[1][1],a[1],"c"),c.clipValues.c=0),h=Math.min(o.clipValues.a,o.clipValues.b,o.clipValues.c),u=h<0,u===e&&s.push(o),h=Math.min(l.clipValues.a,l.clipValues.b,l.clipValues.c),u=h<0,u===e&&s.push(l),h=Math.min(c.clipValues.a,c.clipValues.b,c.clipValues.c),u=h<0,u===e&&s.push(c)}}}class sn{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const t=new nn;this.pool.push(t)}const t=this.pool[this.index];return this.index++,t}reset(){this.index=0}}class nn{constructor(){this.indices={a:-1,b:-1,c:-1},this.clipValues={a:-1,b:-1,c:-1},this.barycoord=new B}getVertexHash(t,e){const{barycoord:s,indices:i}=this,n=s[$i[t]];if(1===n.x)return i[$i[0]];if(1===n.y)return i[$i[1]];if(1===n.z)return i[$i[2]];{const{attributes:t}=e;let s="";for(const e in t){const r=t[e];switch(rn(r,i.a,i.b,i.c,n,Qi),("normal"===e||"tangent"===e||"bitangent"===e)&&Qi.normalize(),r.itemSize){case 4:s+=on(Qi.x,Qi.y,Qi.z,Qi.w);break;case 3:s+=on(Qi.x,Qi.y,Qi.z);break;case 2:s+=on(Qi.x,Qi.y);break;case 1:s+=on(Qi.x)}s+="|"}return s}}getVertexData(t,e,s){const{barycoord:i,indices:n}=this,r=i[$i[t]],{attributes:o}=e;for(const a in o){if(!s[a])continue;const t=o[a],e=s[a];switch(rn(t,n.a,n.b,n.c,r,Qi),("normal"===a||"tangent"===a||"bitangent"===a)&&Qi.normalize(),t.itemSize){case 4:e.push(Qi.x,Qi.y,Qi.z,Qi.w);break;case 3:e.push(Qi.x,Qi.y,Qi.z);break;case 2:e.push(Qi.x,Qi.y);break;case 1:e.push(Qi.x)}}}initFromTriangle(t){return this.initFromIndices(t.indices.a,t.indices.b,t.indices.c)}initFromIndices(t,e,s){return this.indices.a=t,this.indices.b=e,this.indices.c=s,this.clipValues.a=-1,this.clipValues.b=-1,this.clipValues.c=-1,this.barycoord.a.set(1,0,0),this.barycoord.b.set(0,1,0),this.barycoord.c.set(0,0,1),this}lerpVertexFromEdge(t,e,s,i,n){this.clipValues[n]=o.lerp(t.clipValues[e],t.clipValues[s],i),this.barycoord[n].lerpVectors(t.barycoord[e],t.barycoord[s],i)}copyVertex(t,e,s){this.clipValues[s]=t.clipValues[e],this.barycoord[s].copy(t.barycoord[e])}}function rn(t,e,s,i,n,r){switch(Ji.fromBufferAttribute(t,e),Ki.fromBufferAttribute(t,s),tn.fromBufferAttribute(t,i),r.set(0,0,0,0).addScaledVector(Ji,n.x).addScaledVector(Ki,n.y).addScaledVector(tn,n.z),t.itemSize){case 3:Qi.w=0;break;case 2:Qi.w=0,Qi.z=0;break;case 1:Qi.w=0,Qi.z=0,Qi.y=0}return r}function on(...t){let e="";for(let s=0,i=t.length;s<i;s++)e+=~~(1e5*t[s]+.5),s!==i-1&&(e+="_");return e}const an={},ln=new t,cn=new t,hn=new t,un=new t,dn=new t,pn=new t,mn=new t,gn=new p,fn=new p,yn=new p;class bn extends en{constructor(){super(),this.ellipsoid=new Yt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI,this.attributeList=["position","normal","uv"]}clipToQuadrant(t,e,s){const{solid:i,skirtLength:n,ellipsoid:r,smoothSkirtNormals:o}=this;let a,l;this.clearSplitOperations(),this.addSplitOperation(xn("x"),!e),this.addSplitOperation(xn("y"),!s);const c=t.geometry.groups[0],h=this.getClippedData(t,c);if(this.adjustVertices(h,t.position,0),i){a={index:h.index.slice().reverse(),attributes:{}};for(const t in h.attributes)a.attributes[t]=h.attributes[t].slice();const e=a.attributes.normal;if(e)for(let t=0;t<e.length;t+=3)e[t+0]*=-1,e[t+1]*=-1,e[t+2]*=-1;this.adjustVertices(a,t.position,-n)}if(n>0){l={index:[],attributes:{position:[],normal:[],uv:[]}};let e=0;const s={},i=(t,i,n)=>{const r=on(...t,...n,...i);r in s||(s[r]=e,e++,l.attributes.position.push(...t),l.attributes.normal.push(...n),l.attributes.uv.push(...i)),l.index.push(s[r])},a=h.index,c=h.attributes.uv,u=h.attributes.position,d=h.attributes.normal,p=h.index.length/3;for(let l=0;l<p;l++){const e=3*l;for(let s=0;s<3;s++){const l=(s+1)%3,h=a[e+s],p=a[e+l];if(gn.fromArray(c,2*h),fn.fromArray(c,2*p),gn.x===fn.x&&(0===gn.x||.5===gn.x||1===gn.x)||gn.y===fn.y&&(0===gn.y||.5===gn.y||1===gn.y)){cn.fromArray(u,3*h),hn.fromArray(u,3*p);const e=cn,s=hn,a=un.copy(cn),l=dn.copy(hn);pn.copy(a).add(t.position),r.getPositionToNormal(pn,pn),a.addScaledVector(pn,-n),pn.copy(l).add(t.position),r.getPositionToNormal(pn,pn),l.addScaledVector(pn,-n),o&&d?(pn.fromArray(d,3*h),mn.fromArray(d,3*p)):(pn.subVectors(e,s),mn.subVectors(e,a).cross(pn).normalize(),pn.copy(mn)),i(s,fn,mn),i(e,gn,pn),i(a,gn,pn),i(s,fn,mn),i(a,gn,pn),i(l,fn,mn)}}}}const u=h.index.length,d=h;if(a){const{index:t,attributes:e}=a,s=d.attributes.position.length/3;for(let i=0,n=t.length;i<n;i++)d.index.push(t[i]+s);for(const i in h.attributes)d.attributes[i].push(...e[i])}if(l){const{index:t,attributes:e}=l,s=d.attributes.position.length/3;for(let i=0,n=t.length;i<n;i++)d.index.push(t[i]+s);for(const i in h.attributes)d.attributes[i].push(...e[i])}const p=e?0:-.5,m=s?0:-.5,g=d.attributes.uv;for(let x=0,_=g.length;x<_;x+=2)g[x]=2*(g[x]+p),g[x+1]=2*(g[x+1]+m);const f=this.constructMesh(d.attributes,d.index,t);f.userData.minHeight=t.userData.minHeight,f.userData.maxHeight=t.userData.maxHeight;let y=0,b=0;return f.geometry.addGroup(b,u,y),b+=u,y++,a&&(f.geometry.addGroup(b,a.index.length,y),b+=a.index.length,y++),l&&(f.geometry.addGroup(b,l.index.length,y),b+=l.index.length,y++),f}adjustVertices(t,e,s){const{ellipsoid:i,minLat:n,maxLat:r,minLon:a,maxLon:l}=this,{attributes:c,vertexIsClipped:h}=t,u=c.position,d=c.uv,p=u.length/3;for(let m=0;m<p;m++){const t=gn.fromArray(d,2*m);h&&h[m]&&(Math.abs(t.x-.5)<1e-10&&(t.x=.5),Math.abs(t.y-.5)<1e-10&&(t.y=.5),gn.toArray(d,2*m));const c=o.lerp(n,r,t.y),p=o.lerp(a,l,t.x),g=ln.fromArray(u,3*m).add(e);i.getPositionToCartographic(g,an),i.getCartographicToPosition(c,p,an.height+s,g),g.sub(e),g.toArray(u,3*m)}}}function xn(t){return(e,s,i,n,r)=>{const o=e.attributes.uv;return gn.fromBufferAttribute(o,s),fn.fromBufferAttribute(o,i),yn.fromBufferAttribute(o,n),gn[t]*r.x+fn[t]*r.y+yn[t]*r.z-.5}}const _n=Symbol("TILE_X"),Tn=Symbol("TILE_Y"),vn=Symbol("TILE_LEVEL"),wn=Symbol("TILE_AVAILABLE"),Pn=1e4,Mn=new t;function Cn(t){const{available:e=null,maxzoom:s=null}=t;return null===s?e.length-1:s}function Sn(t,e){const s=t[vn],i=function(t){const{metadataAvailability:e=-1}=t;return e}(e);return s<Cn(e)&&-1!==i&&s%i===0}class An{constructor(t={}){const{useRecommendedSettings:e=!0,skirtLength:s=null,smoothSkirtNormals:i=!0,solid:n=!1}=t;this.name="QUANTIZED_MESH_PLUGIN",this.priority=-1e3,this.tiles=null,this.layer=null,this.useRecommendedSettings=e,this.skirtLength=s,this.smoothSkirtNormals=i,this.solid=n,this.attribution=null,this.tiling=new Ni,this.projection=new Vi}init(t){t.fetchOptions.headers=t.fetchOptions.headers||{},t.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(t.errorTarget=2),this.tiles=t}loadRootTileSet(){const{tiles:t}=this;let e=new URL("layer.json",new URL(t.rootURL,location.href));return t.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e),t.invokeOnePlugin(t=>t.fetchData&&t.fetchData(e,this.tiles.fetchOptions)).then(t=>t.json()).then(t=>{this.layer=t;const{projection:e="EPSG:4326",extensions:s=[],attribution:i="",available:n=null}=t,{tiling:r,tiles:o,projection:a}=this;i&&(this.attribution={value:i,type:"string",collapsible:!0}),s.length>0&&(o.fetchOptions.headers.Accept+=`;extensions=${s.join("-")}`),a.setScheme(e);const{tileCountX:l,tileCountY:c}=a;r.setProjection(a),r.generateLevels(Cn(t)+1,l,c);const h=[];for(let p=0;p<l;p++){const t=this.createChild(0,p,0,n);t&&h.push(t)}const u={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getContentBounds(),-Pn,Pn]},children:h,[wn]:n,[vn]:-1}};let d=o.rootURL;return o.invokeAllPlugins(t=>d=t.preprocessURL?t.preprocessURL(d,null):d),o.preprocessTileSet(u,d),u})}parseToMesh(t,e,s,i){const{skirtLength:n,solid:r,smoothSkirtNormals:o,tiles:a}=this,l=a.ellipsoid;let c;if("quantized_tile_split"===s){const t=new URL(i).searchParams,s="true"===t.get("left"),a="true"===t.get("bottom"),h=new bn;h.ellipsoid.copy(l),h.solid=r,h.smoothSkirtNormals=o,h.skirtLength=null===n?e.geometricError:n;const[u,d,p,m]=e.parent.boundingVolume.region;h.minLat=d,h.maxLat=m,h.minLon=u,h.maxLon=p,c=h.clipToQuadrant(e.parent.cached.scene,s,a)}else{if("terrain"!==s)return;{const s=new Xi(a.manager);s.ellipsoid.copy(l),s.solid=r,s.smoothSkirtNormals=o,s.skirtLength=null===n?e.geometricError:n;const[i,h,u,d]=e.boundingVolume.region;s.minLat=h,s.maxLat=d,s.minLon=i,s.maxLon=u,c=s.parse(t)}}const{minHeight:h,maxHeight:u,metadata:d}=c.userData;return e.boundingVolume.region[4]=h,e.boundingVolume.region[5]=u,e.cached.boundingVolume.setRegionData(l,...e.boundingVolume.region),d&&("geometricerror"in d&&(e.geometricError=d.geometricerror),Sn(e,this.layer)&&"available"in d&&0===e.children.length&&(e[wn]=[...new Array(e[vn]+1).fill(null),...d.available])),this.expandChildren(e),c}getAttributions(t){this.attribution&&t.push(this.attribution)}createChild(t,e,s,i){const{tiles:n,layer:r,tiling:o,projection:a}=this,l=n.ellipsoid,c=null===i&&0===t||function(t,e,s,i){if(t&&e<t.length){const n=t[e];for(let t=0,e=n.length;t<e;t++){const{startX:e,startY:r,endX:o,endY:a}=n[t];if(s>=e&&s<=o&&i>=r&&i<=a)return!0}}return!1}(i,t,e,s),h=function(t,e,s,i,n){return n.tiles[0].replace(/{\s*z\s*}/g,s).replace(/{\s*x\s*}/g,t).replace(/{\s*y\s*}/g,e).replace(/{\s*version\s*}/g,i)}(e,s,t,1,r),u=[...o.getTileBounds(e,s,t),-Pn,Pn],[,d,,p,,m]=u,g=d>0!=p>0?0:Math.min(Math.abs(d),Math.abs(p));l.getCartographicToPosition(g,0,m,Mn),Mn.z=0;const f=a.tileCountX,y=2*Math.max(...l.radius)*Math.PI*.25/(65*f)/2**t,b={[wn]:null,[vn]:t,[_n]:e,[Tn]:s,refine:"REPLACE",geometricError:y,boundingVolume:{region:u},content:c?{uri:h}:null,children:[]};return Sn(b,r)||(b[wn]=i),b}expandChildren(t){const e=t[vn],s=t[_n],i=t[Tn],n=t[wn];if(e>=this.tiling.maxLevel)return;let r=!1;for(let o=0;o<2;o++)for(let a=0;a<2;a++){const l=this.createChild(e+1,2*s+o,2*i+a,n);null!==l.content?(t.children.push(l),r=!0):(t.children.push(l),l.content={uri:`tile.quantized_tile_split?bottom=${0===a}&left=${0===o}`})}r||(t.children.length=0)}fetchData(t,e){if(/quantized_tile_split/.test(t))return new ArrayBuffer}disposeTile(t){Sn(t,this.layer)&&(t[wn]=null),wn in t&&(t.children.forEach(t=>{this.tiles.processNodeQueue.remove(t)}),t.children.length=0,t.__childrenProcessed=0)}}class En{get apiToken(){return this.auth.apiToken}set apiToken(t){this.auth.apiToken=t}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(t){this.auth.autoRefreshToken=t}constructor({apiToken:t,assetId:e=null,autoRefreshToken:s=!1,useRecommendedSettings:i=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.auth=new _i({apiToken:t,autoRefreshToken:s}),this.assetId=e,this.autoRefreshToken=s,this.useRecommendedSettings=i,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(t){null!==this.assetId&&(t.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=t,this.auth.authURL=t.rootURL,t.resetFailedTiles()}loadRootTileSet(){return this.auth.refreshToken().then(t=>(this._initializeFromAsset(t),this.tiles.invokeOnePlugin(t=>t!==this&&t.loadRootTileSet&&t.loadRootTileSet()))).catch(t=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:t,url:this.auth.authURL})})}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&-1!=this._tileSetVersion&&t.searchParams.set("v",this._tileSetVersion),t.toString()}fetchData(t,e){return null!==this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")?null:this.auth.fetch(t,e)}getAttributions(t){this.tiles.visibleTiles.size>0&&t.push(...this._attributions)}_initializeFromAsset(t){const e=this.tiles;if("externalType"in t){const s=new URL(t.options.url);e.rootURL=t.options.url,e.registerPlugin(new Mi({apiToken:s.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{"TERRAIN"===t.type&&null===e.getPluginByName("QUANTIZED_MESH_PLUGIN")?e.registerPlugin(new An({useRecommendedSettings:this.useRecommendedSettings})):"IMAGERY"===t.type&&null===e.getPluginByName("TMS_TILES_PLUGIN")&&e.registerPlugin(new Gi({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),e.rootURL=t.url;const s=new URL(t.url);s.searchParams.has("v")&&-1===this._tileSetVersion&&(this._tileSetVersion=s.searchParams.get("v")),t.attributions&&(this._attributions=t.attributions.map(t=>({value:t.html,type:"html",collapsible:t.collapsible})))}}}const Ln=new e;class Un{constructor(){this.name="UPDATE_ON_CHANGE_PLUGIN",this.tiles=null,this.needsUpdate=!1,this.cameraMatrices=new Map}init(t){this.tiles=t,this._needsUpdateCallback=()=>{this.needsUpdate=!0},this._onCameraAdd=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.set(t,new e)},this._onCameraDelete=({camera:t})=>{this.needsUpdate=!0,this.cameraMatrices.delete(t)},t.addEventListener("needs-update",this._needsUpdateCallback),t.addEventListener("add-camera",this._onCameraAdd),t.addEventListener("delete-camera",this._onCameraDelete),t.addEventListener("camera-resolution-change",this._needsUpdateCallback),t.cameras.forEach(t=>{this._onCameraAdd({camera:t})})}doTilesNeedUpdate(){const t=this.tiles;let e=!1;this.cameraMatrices.forEach((s,i)=>{Ln.copy(t.group.matrixWorld).premultiply(i.matrixWorldInverse).premultiply(i.projectionMatrixInverse),e=e||!Ln.equals(s),s.copy(Ln)});const s=this.needsUpdate;return this.needsUpdate=!1,s||e}preprocessNode(){this.needsUpdate=!0}dispose(){const t=this.tiles;t.removeEventListener("camera-resolution-change",this._needsUpdateCallback),t.removeEventListener("needs-update",this._needsUpdateCallback),t.removeEventListener("add-camera",this._onCameraAdd),t.removeEventListener("delete-camera",this._onCameraDelete)}}const Dn=new t;function Fn(t,e){if(t.isInterleavedBufferAttribute||t.array instanceof e)return t;const s=e===Int8Array||e===Int16Array||e===Int32Array?-1:0,i=new e(t.count*t.itemSize),n=new M(i,t.itemSize,!0),r=t.itemSize,a=t.count;for(let l=0;l<a;l++)for(let e=0;e<r;e++){const i=o.clamp(t.getComponent(l,e),s,1);n.setComponent(l,e,i)}return n}class In{constructor(t){this._options={generateNormals:!1,disableMipmaps:!0,compressIndex:!0,compressNormals:!1,compressUvs:!1,compressPosition:!1,uvType:Int8Array,normalType:Int8Array,positionType:Int16Array,...t},this.name="TILES_COMPRESSION_PLUGIN",this.priority=-100}processTileModel(t,e){const{generateNormals:s,disableMipmaps:i,compressIndex:n,compressUvs:r,compressNormals:a,compressPosition:l,uvType:c,normalType:h,positionType:u}=this._options;t.traverse(t=>{if(t.material&&i){const e=t.material;for(const t in e){const s=e[t];s&&s.isTexture&&s.generateMipmaps&&(s.generateMipmaps=!1,s.minFilter=F)}}if(t.geometry){const e=t.geometry,i=e.attributes;if(r){const{uv:t,uv1:e,uv2:s,uv3:n}=i;t&&(i.uv=Fn(t,c)),e&&(i.uv1=Fn(e,c)),s&&(i.uv2=Fn(s,c)),n&&(i.uv3=Fn(n,c))}if(s&&!i.normals&&e.computeVertexNormals(),a&&i.normals&&(i.normals=Fn(i.normals,h)),l&&function(t,e=Int16Array){const s=t.geometry,i=s.attributes,n=i.position;if(n.isInterleavedBufferAttribute||n.array instanceof e)return n;const r=new e(n.count*n.itemSize),a=new M(r,n.itemSize,!1),l=n.itemSize,c=n.count;s.computeBoundingBox();const h=s.boundingBox,{min:u,max:d}=h,p=2**(8*e.BYTES_PER_ELEMENT-1)-1,m=-p;for(let g=0;g<c;g++)for(let t=0;t<l;t++){const e=0===t?"x":1===t?"y":"z",s=u[e],i=d[e],r=o.mapLinear(n.getComponent(g,t),s,i,m,p);a.setComponent(g,t,r)}h.getCenter(Dn).multiply(t.scale).applyQuaternion(t.quaternion),t.position.add(Dn),t.scale.x*=.5*(d.x-u.x)/p,t.scale.y*=.5*(d.y-u.y)/p,t.scale.z*=.5*(d.z-u.z)/p,i.position=a,t.geometry.boundingBox=null,t.geometry.boundingSphere=null,t.updateMatrixWorld()}(t,u),n&&e.index){const t=i.position.count,s=e.index,n=t>65535?Uint32Array:t>255?Uint16Array:Uint8Array;if(!(s.array instanceof n)){const t=new n(e.index.count);t.set(s.array);const i=new M(t,1);e.setIndex(i)}}}})}}function Rn(t,e,s){return t&&e in t?t[e]:s}function kn(t){return"BOOLEAN"!==t&&"STRING"!==t&&"ENUM"!==t}function On(t){return/^VEC/.test(t)}function Vn(t){return/^MAT/.test(t)}function zn(t,e,s,i=null){return Vn(s)||On(s)?i.fromArray(t,e):t[e]}function Bn(s){const{type:i,componentType:n}=s;switch(i){case"SCALAR":return"INT64"===n?0n:0;case"VEC2":return new p;case"VEC3":return new t;case"VEC4":return new G;case"MAT2":return new J;case"MAT3":return new E;case"MAT4":return new e;case"BOOLEAN":return!1;case"STRING":return"";case"ENUM":return 0}}function Nn(t,e){if(null==e)return!1;switch(t){case"SCALAR":case"ENUM":return"number"==typeof e||"bigint"==typeof e;case"VEC2":return e.isVector2;case"VEC3":return e.isVector3;case"VEC4":return e.isVector4;case"MAT2":return e.isMatrix2;case"MAT3":return e.isMatrix3;case"MAT4":return e.isMatrix4;case"BOOLEAN":return"boolean"==typeof e;case"STRING":return"string"==typeof e}throw new Error("ClassProperty: invalid type.")}function jn(t,e=null){switch(t){case"INT8":return Int8Array;case"INT16":return Int16Array;case"INT32":return Int32Array;case"INT64":return BigInt64Array;case"UINT8":return Uint8Array;case"UINT16":return Uint16Array;case"UINT32":return Uint32Array;case"UINT64":return BigUint64Array;case"FLOAT32":return Float32Array;case"FLOAT64":return Float64Array}switch(e){case"BOOLEAN":case"STRING":return Uint8Array}throw new Error("ClassProperty: invalid type.")}function Wn(t,e=null){const s=t.default,i=t.type;if(e=e||Bn(t),null===s){switch(i){case"SCALAR":return 0;case"VEC2":return e.set(0,0);case"VEC3":return e.set(0,0,0);case"VEC4":return e.set(0,0,0,0);case"MAT2":case"MAT3":case"MAT4":return e.identity();case"BOOLEAN":return!1;case"STRING":case"ENUM":return""}throw new Error("ClassProperty: invalid type.")}if(Vn(i))e.fromArray(s);else{if(!On(i))return s;e.fromArray(s)}}function Gn(t,e){if(null===t.noData)return e;const s=t.noData,i=t.type;if(Array.isArray(e))for(let r=0,o=e.length;r<o;r++)e[r]=n(e[r]);else e=n(e);return e;function n(e){return function(t){if(Vn(i)){const e=t.elements;for(let t=0,i=s.length;t<i;t++)if(s[t]!==e[t])return!1;return!0}if(On(i)){for(let e=0,i=s.length;e<i;e++)if(s[e]!==t.getComponent(e))return!1;return!0}return s===t}(e)&&(e=Wn(t,e)),e}}function Hn(t,e){const{type:s,componentType:i,scale:n,offset:r,normalized:o}=t;if(Array.isArray(e))for(let c=0,h=e.length;c<h;c++)e[c]=a(e[c]);else e=a(e);return e;function a(t){return t=Vn(s)?function(t){const e=t.elements;for(let s=0,i=e.length;s<i;s++)e[s]=l(e[s]);return t}(t):On(s)?function(t){return t.x=l(t.x),t.y=l(t.y),"z"in t&&(t.z=l(t.z)),"w"in t&&(t.w=l(t.w)),t}(t):l(t),t}function l(t){return o&&(t=function(t,e){switch(t){case"INT8":return Math.max(e/127,-1);case"INT16":return Math.max(e,32767,-1);case"INT32":return Math.max(e/2147483647,-1);case"INT64":return Math.max(Number(e)/0x8000000000000000,-1);case"UINT8":return e/255;case"UINT16":return e/65535;case"UINT32":return e/4294967295;case"UINT64":return Number(e)/0x10000000000000000}}(i,t)),(o||function(t){return/^FLOAT/.test(t)}(i))&&(t=t*n+r),t}}function qn(t,e,s=null){if(t.array){Array.isArray(e)||(e=new Array(t.count||0)),e.length=null!==s?s:t.count;for(let s=0,i=e.length;s<i;s++)Nn(t.type,e[s])||(e[s]=Bn(t))}else Nn(t.type,e)||(e=Bn(t));return e}function Zn(t,e){for(const s in e)s in t||delete e[s];for(const s in t){const i=t[s];e[s]=qn(i,e[s])}}class Yn{constructor(t,e,s=null){this.name=e.name||null,this.description=e.description||null,this.type=e.type,this.componentType=e.componentType||null,this.enumType=e.enumType||null,this.array=e.array||!1,this.count=e.count||0,this.normalized=e.normalized||!1,this.offset=e.offset||0,this.scale=Rn(e,"scale",1),this.max=Rn(e,"max",1/0),this.min=Rn(e,"min",-1/0),this.required=e.required||!1,this.noData=Rn(e,"noData",null),this.default=Rn(e,"default",null),this.semantic=Rn(e,"semantic",null),this.enumSet=null,this.accessorProperty=s,s&&(this.offset=Rn(s,"offset",this.offset),this.scale=Rn(s,"scale",this.scale),this.max=Rn(s,"max",this.max),this.min=Rn(s,"min",this.min)),"ENUM"===e.type&&(this.enumSet=t[this.enumType],null===this.componentType&&(this.componentType=Rn(this.enumSet,"valueType","UINT16")))}shapeToProperty(t,e=null){return qn(this,t,e)}resolveDefaultElement(t){return Wn(this,t)}resolveDefault(t){return function(t,e=null){if(t.array){(e=e&&Array.isArray(e)?e:[]).length=t.count;for(let s=0,i=e.length;s<i;s++)e[s]=Wn(t,e[s])}else e=Wn(t,e);return e}(this,t)}resolveNoData(t){return Gn(this,t)}resolveEnumsToStrings(t){const e=this.enumSet;if("ENUM"===this.type)if(Array.isArray(t))for(let i=0,n=t.length;i<n;i++)t[i]=s(t[i]);else t=s(t);return t;function s(t){const s=e.values.find(e=>e.value===t);return null===s?"":s.name}}adjustValueScaleOffset(t){return kn(this.type)?Hn(this,t):t}}class Xn{constructor(t,e={},s={},i=null){this.definition=t,this.class=e[t.class],this.className=t.class,this.enums=s,this.data=i,this.name="name"in t?t.name:null,this.properties=null}getPropertyNames(){return Object.keys(this.class.properties)}includesData(t){return!!this.definition.properties[t]}dispose(){}_initProperties(t=Yn){const e={};for(const s in this.class.properties)e[s]=new t(this.enums,this.class.properties[s],this.definition.properties[s]);this.properties=e}}class $n extends Yn{constructor(t,e,s=null){super(t,e,s),this.attribute=(null==s?void 0:s.attribute)??null}}class Qn extends Xn{constructor(...t){super(...t),this.isPropertyAttributeAccessor=!0,this._initProperties($n)}getData(t,e,s={}){const i=this.properties;Zn(i,s);for(const n in i)s[n]=this.getPropertyValue(n,t,e,s[n]);return s}getPropertyValue(t,e,s,i=null){if(e>=this.count)throw new Error("PropertyAttributeAccessor: Requested index is outside the range of the buffer.");const n=this.properties[t],r=n.type;if(!n)throw new Error("PropertyAttributeAccessor: Requested class property does not exist.");if(!this.definition.properties[t])return n.resolveDefault(i);i=n.shapeToProperty(i);const o=s.getAttribute(n.attribute.toLowerCase());if(Vn(r)){const t=i.elements;for(let s=0,i=t.length;s<i;s<i)t[s]=o.getComponent(e,s)}else if(On(r))i.fromBufferAttribute(o,e);else{if("SCALAR"!==r&&"ENUM"!==r)throw new Error("StructuredMetadata.PropertyAttributeAccessor: BOOLEAN and STRING types are not supported by property attributes.");i=o.getX(e)}return i=n.adjustValueScaleOffset(i),i=n.resolveEnumsToStrings(i),i=n.resolveNoData(i)}}class Jn extends Yn{constructor(t,e,s=null){super(t,e,s),this.values=(null==s?void 0:s.values)??null,this.valueLength=function(t){switch(t){case"ENUM":case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return-1}}(this.type),this.arrayOffsets=Rn(s,"arrayOffsets",null),this.stringOffsets=Rn(s,"stringOffsets",null),this.arrayOffsetType=Rn(s,"arrayOffsetType","UINT32"),this.stringOffsetType=Rn(s,"stringOffsetType","UINT32")}getArrayLengthFromId(t,e){let s=this.count;if(null!==this.arrayOffsets){const{arrayOffsets:i,arrayOffsetType:n}=this,r=new(jn(n))(t[i]);s=r[e+1]-r[e]}return s}getIndexOffsetFromId(t,e){let s=e;if(this.arrayOffsets){const{arrayOffsets:e,arrayOffsetType:i}=this;s=new(jn(i))(t[e])[s]}else this.array&&(s*=this.count);return s}}class Kn extends Xn{constructor(...t){super(...t),this.isPropertyTableAccessor=!0,this.count=this.definition.count,this._initProperties(Jn)}getData(t,e={}){const s=this.properties;Zn(s,e);for(const i in s)e[i]=this.getPropertyValue(i,t,e[i]);return e}_readValueAtIndex(t,e,s,i=null){const n=this.properties[t],{componentType:r,type:o}=n,a=this.data,l=a[n.values],c=new(jn(r,o))(l),h=n.getIndexOffsetFromId(a,e);if(kn(o)||"ENUM"===o)return zn(c,(h+s)*n.valueLength,o,i);if("STRING"===o){let t=h+s,e=0;if(null!==n.stringOffsets){const{stringOffsets:s,stringOffsetType:i}=n,r=new(jn(i))(a[s]);e=r[t+1]-r[t],t=r[t]}const r=new Uint8Array(c.buffer,t,e);i=(new TextDecoder).decode(r)}else if("BOOLEAN"===o){const t=h+s,e=t%8;i=1==(c[Math.floor(t/8)]>>e&1)}return i}getPropertyValue(t,e,s=null){if(e>=this.count)throw new Error("PropertyTableAccessor: Requested index is outside the range of the table.");const i=this.properties[t];if(!i)throw new Error("PropertyTableAccessor: Requested property does not exist.");if(!this.definition.properties[t])return i.resolveDefault(s);const n=i.array,r=this.data,o=i.getArrayLengthFromId(r,e);if(s=i.shapeToProperty(s,o),n)for(let a=0,l=s.length;a<l;a++)s[a]=this._readValueAtIndex(t,e,a,s[a]);else s=this._readValueAtIndex(t,e,0,s);return s=i.adjustValueScaleOffset(s),s=i.resolveEnumsToStrings(s),s=i.resolveNoData(s)}}const tr=new Q;class er{constructor(){this._renderer=new H,this._target=new q(1,1),this._texTarget=new q,this._quad=new Z(new D({blending:$,blendDst:X,blendSrc:Y,uniforms:{map:{value:null},pixel:{value:new p}},vertexShader:"\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform ivec2 pixel;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texelFetch( map, pixel, 0 );\n\n\t\t\t\t}\n\t\t\t"}))}increaseSizeTo(t){this._target.setSize(Math.max(this._target.width,t),1)}readDataAsync(t){const{_renderer:e,_target:s}=this;return e.readRenderTargetPixelsAsync(s,0,0,t.length/4,1,t)}readData(t){const{_renderer:e,_target:s}=this;e.readRenderTargetPixels(s,0,0,t.length/4,1,t)}renderPixelToTarget(t,e,s){const{_renderer:i,_target:n}=this;tr.min.copy(e),tr.max.copy(e),tr.max.x+=1,tr.max.y+=1,i.initRenderTarget(n),i.copyTextureToTexture(t,n.texture,tr,s,0)}}const sr=new class{constructor(){let t=null;Object.getOwnPropertyNames(er.prototype).forEach(e=>{"constructor"!==e&&(this[e]=(...s)=>(t=t||new er,t[e](...s)))})}},ir=new p,nr=new p,rr=new p;function or(t,e,s=new Array(3)){let i=3*e,n=3*e+1,r=3*e+2;return t.index&&(i=t.index.getX(i),n=t.index.getX(n),r=t.index.getX(r)),s[0]=i,s[1]=n,s[2]=r,s}function ar(t,e,s,i,n){const[r,o,a]=i,l=function(t,e){return 0===e?t.getAttribute("uv"):t.getAttribute(`uv${e}`)}(t,e);ir.fromBufferAttribute(l,r),nr.fromBufferAttribute(l,o),rr.fromBufferAttribute(l,a),n.set(0,0,0).addScaledVector(ir,s.x).addScaledVector(nr,s.y).addScaledVector(rr,s.z)}function lr(t,e,s,i){const n=t.x-Math.floor(t.x),r=t.y-Math.floor(t.y),o=Math.floor(n*e%e),a=Math.floor(r*s%s);return i.set(o,a),i}const cr=new p,hr=new p,ur=new p;class dr extends Yn{constructor(t,e,s=null){super(t,e,s),this.channels=Rn(s,"channels",[0]),this.index=Rn(s,"index",null),this.texCoord=Rn(s,"texCoord",null),this.valueLength=parseInt(this.type.replace(/[^0-9]/g,""))||1}readDataFromBuffer(t,e,s=null){const i=this.type;if("BOOLEAN"===i||"STRING"===i)throw new Error("PropertyTextureAccessor: BOOLEAN and STRING types not supported.");return zn(t,e*this.valueLength,i,s)}}class pr extends Xn{constructor(...t){super(...t),this.isPropertyTextureAccessor=!0,this._asyncRead=!1,this._initProperties(dr)}getData(t,e,s,i={}){const n=this.properties;Zn(n,i);const r=Object.keys(n),o=r.map(t=>i[t]);return this.getPropertyValuesAtTexel(r,t,e,s,o),r.forEach((t,e)=>i[t]=o[e]),i}async getDataAsync(t,e,s,i={}){const n=this.properties;Zn(n,i);const r=Object.keys(n),o=r.map(t=>i[t]);return await this.getPropertyValuesAtTexelAsync(r,t,e,s,o),r.forEach((t,e)=>i[t]=o[e]),i}getPropertyValuesAtTexelAsync(...t){this._asyncRead=!0;const e=this.getPropertyValuesAtTexel(...t);return this._asyncRead=!1,e}getPropertyValuesAtTexel(t,e,s,i,n=[]){for(;n.length<t.length;)n.push(null);n.length=t.length,sr.increaseSizeTo(n.length);const r=this.data,o=this.definition.properties,a=this.properties,l=or(i,e);for(let u=0,d=t.length;u<d;u++){const e=t[u];if(!o[e])continue;const n=a[e],c=r[n.index];ar(i,n.texCoord,s,l,cr),lr(cr,c.image.width,c.image.height,hr),ur.set(u,0),sr.renderPixelToTarget(c,hr,ur)}const c=new Uint8Array(4*t.length);return this._asyncRead?sr.readDataAsync(c).then(()=>(h.call(this),n)):(sr.readData(c),h.call(this),n);function h(){for(let e=0,s=t.length;e<s;e++){const s=t[e],i=a[s],r=i.type;if(n[e]=qn(i,n[e]),!i)throw new Error("PropertyTextureAccessor: Requested property does not exist.");if(!o[s]){n[e]=i.resolveDefault(n);continue}const l=i.valueLength*(i.count||1),h=i.channels.map(t=>c[4*e+t]),u=new(jn(i.componentType,r))(l);if(new Uint8Array(u.buffer).set(h),i.array){const t=n[e];for(let e=0,s=t.length;e<s;e++)t[e]=i.readDataFromBuffer(u,e,t[e])}else n[e]=i.readDataFromBuffer(u,0,n[e]);n[e]=i.adjustValueScaleOffset(n[e]),n[e]=i.resolveEnumsToStrings(n[e]),n[e]=i.resolveNoData(n[e])}}}dispose(){this.data.forEach(t=>{t&&(t.dispose(),t.image instanceof ImageBitmap&&t.image.close())})}}class mr{constructor(t,e,s,i=null,n=null){const{schema:r,propertyTables:o=[],propertyTextures:a=[],propertyAttributes:l=[]}=t,{enums:c,classes:h}=r,u=o.map(t=>new Kn(t,h,c,s));let d=[],p=[];i&&(i.propertyTextures&&(d=i.propertyTextures.map(t=>new pr(a[t],h,c,e))),i.propertyAttributes&&(p=i.propertyAttributes.map(t=>new Qn(l[t],h,c)))),this.schema=r,this.tableAccessors=u,this.textureAccessors=d,this.attributeAccessors=p,this.object=n,this.textures=e,this.nodeMetadata=i}getPropertyTableData(t,e,s=null){if(Array.isArray(t)&&Array.isArray(e)){s=s||[];const i=Math.min(t.length,e.length);s.length=i;for(let n=0;n<i;n++){const i=this.tableAccessors[t[n]];s[n]=i.getData(e[n],s[n])}}else s=s||{},s=this.tableAccessors[t].getData(e,s);return s}getPropertyTableInfo(t=null){if(null===t&&(t=this.tableAccessors.map((t,e)=>e)),Array.isArray(t))return t.map(t=>{const e=this.tableAccessors[t];return{name:e.name,className:e.definition.class}});{const e=this.tableAccessors[t];return{name:e.name,className:e.definition.class}}}getPropertyTextureData(t,e,s=[]){const i=this.textureAccessors;s.length=i.length;for(let n=0;n<i.length;n++){const r=i[n];s[n]=r.getData(t,e,this.object.geometry,s[n])}return s}async getPropertyTextureDataAsync(t,e,s=[]){const i=this.textureAccessors;s.length=i.length;const n=[];for(let r=0;r<i.length;r++){const o=i[r].getDataAsync(t,e,this.object.geometry,s[r]).then(t=>{s[r]=t});n.push(o)}return await Promise.all(n),s}getPropertyTextureInfo(){return this.textureAccessors}getPropertyAttributeData(t,e=[]){const s=this.attributeAccessors;e.length=s.length;for(let i=0;i<s.length;i++){const n=s[i];e[i]=n.getData(t,this.object.geometry,e[i])}return e}getPropertyAttributeInfo(){return this.attributeAccessors.map(t=>({name:t.name,className:t.definition.class}))}dispose(){this.textureAccessors.forEach(t=>t.dispose()),this.tableAccessors.forEach(t=>t.dispose()),this.attributeAccessors.forEach(t=>t.dispose())}}const gr="EXT_structural_metadata";function fr(t,e=[]){var s;const i=(null==(s=t.json.textures)?void 0:s.length)||0,n=new Array(i).fill(null);return e.forEach(({properties:e})=>{for(const s in e){const{index:i}=e[s];null===n[i]&&(n[i]=t.loadTexture(i))}}),Promise.all(n)}function yr(t,e=[]){var s;const i=(null==(s=t.json.bufferViews)?void 0:s.length)||0,n=new Array(i).fill(null);return e.forEach(({properties:e})=>{for(const s in e){const{values:i,arrayOffsets:r,stringOffsets:o}=e[s];null===n[i]&&(n[i]=t.loadBufferView(i)),null===n[r]&&(n[r]=t.loadBufferView(r)),null===n[o]&&(n[o]=t.loadBufferView(o))}}),Promise.all(n)}class br{constructor(t){this.parser=t,this.name=gr}async afterRoot({scene:t,parser:e}){const s=e.json.extensionsUsed;if(!s||!s.includes(gr))return;let i=null,n=e.json.extensions[gr];if(n.schemaUri){const{manager:t,path:s,requestHeader:r,crossOrigin:o}=e.options,a=new URL(n.schemaUri,s).toString(),l=new k(t);l.setCrossOrigin(o),l.setResponseType("json"),l.setRequestHeader(r),i=l.loadAsync(a).then(t=>{n={...n,schema:t}})}const[r,o]=await Promise.all([fr(e,n.propertyTextures),yr(e,n.propertyTables),i]),a=new mr(n,r,o);t.userData.structuralMetadata=a,t.traverse(t=>{var s;if(e.associations.has(t)){const{meshes:i,primitives:l}=e.associations.get(t),c=null==(s=e.json.meshes[i])?void 0:s.primitives[l];if(c&&c.extensions&&c.extensions[gr]){const e=c.extensions[gr];t.userData.structuralMetadata=new mr(n,r,o,e,t)}else t.userData.structuralMetadata=a}})}}const xr=new p,_r=new p,Tr=new p;class vr{constructor(t,e,s){this.geometry=t,this.textures=e,this.data=s,this._asyncRead=!1,this.featureIds=s.featureIds.map(t=>{const{texture:e,...s}=t,i={label:null,propertyTable:null,nullFeatureId:null,...s};return e&&(i.texture={texCoord:0,channels:[0],...e}),i})}getTextures(){return this.textures}getFeatureInfo(){return this.featureIds}getFeaturesAsync(...t){this._asyncRead=!0;const e=this.getFeatures(...t);return this._asyncRead=!1,e}getFeatures(t,e){const{geometry:s,textures:i,featureIds:n}=this,r=new Array(n.length).fill(null),o=n.length;sr.increaseSizeTo(o);const a=or(s,t),l=a[(c=e,c.x>c.y&&c.x>c.z?0:c.y>c.z?1:2)];var c;for(let d=0,p=n.length;d<p;d++){const t=n[d],o="nullFeatureId"in t?t.nullFeatureId:null;if("texture"in t){const n=i[t.texture.index];ar(s,t.texture.texCoord,e,a,xr),lr(xr,n.image.width,n.image.height,_r),Tr.set(d,0),sr.renderPixelToTarget(i[t.texture.index],_r,Tr)}else if("attribute"in t){const e=s.getAttribute(`_feature_id_${t.attribute}`).getX(l);e!==o&&(r[d]=e)}else{const t=l;t!==o&&(r[d]=t)}}const h=new Uint8Array(4*o);return this._asyncRead?sr.readDataAsync(h).then(()=>(u(),r)):(sr.readData(h),u(),r);function u(){const t=new Uint32Array(1);for(let e=0,s=n.length;e<s;e++){const s=n[e],i="nullFeatureId"in s?s.nullFeatureId:null;if("texture"in s){const{channels:n}=s.texture,o=n.map(t=>h[4*e+t]);new Uint8Array(t.buffer).set(o);const a=t[0];a!==i&&(r[e]=a)}}}}dispose(){this.textures.forEach(t=>{t&&(t.dispose(),t.image instanceof ImageBitmap&&t.image.close())})}}const wr="EXT_mesh_features";function Pr(t,e,s){t.traverse(t=>{var i;if(e.associations.has(t)){const{meshes:n,primitives:r}=e.associations.get(t),o=null==(i=e.json.meshes[n])?void 0:i.primitives[r];o&&o.extensions&&o.extensions[wr]&&s(t,o.extensions[wr])}})}class Mr{constructor(t){this.parser=t,this.name=wr}async afterRoot({scene:t,parser:e}){var s;const i=e.json.extensionsUsed;if(!i||!i.includes(wr))return;const n=(null==(s=e.json.textures)?void 0:s.length)||0,r=new Array(n).fill(null);Pr(t,e,(t,{featureIds:s})=>{s.forEach(t=>{if(t.texture&&null===r[t.texture.index]){const s=t.texture.index;r[s]=e.loadTexture(s)}})});const o=await Promise.all(r);Pr(t,e,(t,e)=>{t.userData.meshFeatures=new vr(t.geometry,o,e)})}}class Cr{constructor(){this.name="CESIUM_RTC"}afterRoot(t){if(t.parser.json.extensions&&t.parser.json.extensions.CESIUM_RTC){const{center:e}=t.parser.json.extensions.CESIUM_RTC;e&&(t.scene.position.x+=e[0],t.scene.position.y+=e[1],t.scene.position.z+=e[2])}}}class Sr{constructor(t){t={metadata:!0,rtc:!0,plugins:[],dracoLoader:null,ktxLoader:null,meshoptDecoder:null,autoDispose:!0,...t},this.tiles=null,this.metadata=t.metadata,this.rtc=t.rtc,this.plugins=t.plugins,this.dracoLoader=t.dracoLoader,this.ktxLoader=t.ktxLoader,this.meshoptDecoder=t.meshoptDecoder,this._gltfRegex=/\.(gltf|glb)$/g,this._dracoRegex=/\.drc$/g,this._loader=null}init(t){const e=new m(t.manager);this.dracoLoader&&(e.setDRACOLoader(this.dracoLoader),t.manager.addHandler(this._dracoRegex,this.dracoLoader)),this.ktxLoader&&e.setKTX2Loader(this.ktxLoader),this.meshoptDecoder&&e.setMeshoptDecoder(this.meshoptDecoder),this.rtc&&e.register(()=>new Cr),this.metadata&&(e.register(()=>new br),e.register(()=>new Mr)),this.plugins.forEach(t=>e.register(t)),t.manager.addHandler(this._gltfRegex,e),this.tiles=t,this._loader=e}dispose(){this.tiles.manager.removeHandler(this._gltfRegex),this.tiles.manager.removeHandler(this._dracoRegex),this.autoDispose&&(this.ktxLoader.dispose(),this.dracoLoader.dispose())}}class Ar{set delay(t){this.deferCallbacks.delay=t}get delay(){return this.deferCallbacks.delay}set bytesTarget(t){this.lruCache.minBytesSize=t}get bytesTarget(){return this.lruCache.minBytesSize}get estimatedGpuBytes(){return this.lruCache.cachedBytes}constructor(t={}){const{delay:e=0,bytesTarget:s=0}=t;this.name="UNLOAD_TILES_PLUGIN",this.tiles=null,this.lruCache=new K,this.deferCallbacks=new Er,this.delay=e,this.bytesTarget=s}init(t){this.tiles=t;const{lruCache:e,deferCallbacks:s}=this;s.callback=t=>{e.markUnused(t),e.scheduleUnload(!1)};const i=e=>{const s=e.cached.scene;t.visibleTiles.has(e)||t.invokeOnePlugin(t=>t.unloadTileFromGPU&&t.unloadTileFromGPU(s,e))};this._onUpdateBefore=()=>{e.unloadPriorityCallback=t.lruCache.unloadPriorityCallback,e.computeMemoryUsageCallback=t.lruCache.computeMemoryUsageCallback,e.minSize=1/0,e.maxSize=1/0,e.maxBytesSize=1/0,e.unloadPercent=1,e.autoMarkUnused=!1},this._onVisibilityChangeCallback=({tile:n,visible:r})=>{r?(e.add(n,i),t.markTileUsed(n),s.cancel(n)):s.run(n)},t.forEachLoadedModel((e,s)=>{const i=t.visibleTiles.has(s);this._onVisibilityChangeCallback({scene:e,visible:i})}),t.addEventListener("tile-visibility-change",this._onVisibilityChangeCallback),t.addEventListener("update-before",this._onUpdateBefore)}unloadTileFromGPU(t,e){t&&t.traverse(t=>{if(t.material){const e=t.material;e.dispose();for(const t in e){const s=e[t];s&&s.isTexture&&s.dispose()}}t.geometry&&t.geometry.dispose()})}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._onVisibilityChangeCallback),this.tiles.removeEventListener("update-before",this._onUpdateBefore),this.deferCallbacks.cancelAll()}}class Er{constructor(t=()=>{}){this.map=new Map,this.callback=t,this.delay=0}run(t){const{map:e,delay:s}=this;if(e.has(t))throw new Error("DeferCallbackManager: Callback already initialized.");0===s?this.callback(t):e.set(t,setTimeout(()=>this.callback(t),s))}cancel(t){const{map:e}=this;e.has(t)&&(clearTimeout(e.get(t)),e.delete(t))}cancelAll(){this.map.forEach((t,e)=>{this.cancel(e)})}}const{clamp:Lr}=o;class Ur{constructor(){this.duration=250,this.fadeCount=0,this._lastTick=-1,this._fadeState=new Map,this.onFadeComplete=null,this.onFadeStart=null,this.onFadeSetComplete=null,this.onFadeSetStart=null}deleteObject(t){t&&this.completeFade(t)}guaranteeState(t){const e=this._fadeState;if(e.has(t))return!1;return e.set(t,{fadeInTarget:0,fadeOutTarget:0,fadeIn:0,fadeOut:0}),!0}completeFade(t){const e=this._fadeState;if(!e.has(t))return;const s=0===e.get(t).fadeOutTarget;e.delete(t),this.fadeCount--,this.onFadeComplete&&this.onFadeComplete(t,s),0===this.fadeCount&&this.onFadeSetComplete&&this.onFadeSetComplete()}completeAllFades(){this._fadeState.forEach((t,e)=>{this.completeFade(e)})}forEachObject(t){this._fadeState.forEach((e,s)=>{t(s,e)})}fadeIn(t){const e=this.guaranteeState(t),s=this._fadeState.get(t);s.fadeInTarget=1,s.fadeOutTarget=0,s.fadeOut=0,e&&(this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(t))}fadeOut(t){const e=this.guaranteeState(t),s=this._fadeState.get(t);s.fadeOutTarget=1,e&&(s.fadeInTarget=1,s.fadeIn=1,this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(t))}isFading(t){return this._fadeState.has(t)}isFadingOut(t){const e=this._fadeState.get(t);return e&&1===e.fadeOutTarget}update(){const t=window.performance.now();-1===this._lastTick&&(this._lastTick=t);const e=Lr((t-this._lastTick)/this.duration,0,1);this._lastTick=t,this._fadeState.forEach((t,s)=>{const{fadeOutTarget:i,fadeInTarget:n}=t;let{fadeOut:r,fadeIn:o}=t;const a=Math.sign(n-o);o=Lr(o+a*e,0,1);const l=Math.sign(i-r);r=Lr(r+l*e,0,1),t.fadeIn=o,t.fadeOut=r,((1===r||0===r)&&(1===o||0===o)||r>=o)&&this.completeFade(s)})}}const Dr=Symbol("FADE_PARAMS");function Fr(t,e){if(t[Dr])return t[Dr];const s={fadeIn:{value:0},fadeOut:{value:0},fadeTexture:{value:null}};return t[Dr]=s,t.defines={...t.defines||{},FEATURE_FADE:0},t.onBeforeCompile=t=>{e&&e(t),t.uniforms={...t.uniforms,...s},t.vertexShader=t.vertexShader.replace(/void\s+main\(\)\s+{/,t=>`\n\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\tvarying float vBatchId;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t${t}\n\n\t\t\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t\t\t// add 0.5 to the value to avoid floating error that may cause flickering\n\t\t\t\t\t\tvBatchId = getIndirectIndex( gl_DrawID ) + 0.5;\n\n\t\t\t\t\t\t#endif\n\t\t\t\t`),t.fragmentShader=t.fragmentShader.replace(/void main\(/,t=>`\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\t\tfloat bayerDither2x2( vec2 v ) {\n\n\t\t\t\t\treturn mod( 3.0 * v.y + 2.0 * v.x, 4.0 );\n\n\t\t\t\t}\n\n\t\t\t\tfloat bayerDither4x4( vec2 v ) {\n\n\t\t\t\t\tvec2 P1 = mod( v, 2.0 );\n\t\t\t\t\tvec2 P2 = floor( 0.5 * mod( v, 4.0 ) );\n\t\t\t\t\treturn 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );\n\n\t\t\t\t}\n\n\t\t\t\t// the USE_BATCHING define is not available in fragment shaders\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\t// functions for reading the fade state of a given batch id\n\t\t\t\tuniform sampler2D fadeTexture;\n\t\t\t\tvarying float vBatchId;\n\t\t\t\tvec2 getFadeValues( const in float i ) {\n\n\t\t\t\t\tint size = textureSize( fadeTexture, 0 ).x;\n\t\t\t\t\tint j = int( i );\n\t\t\t\t\tint x = j % size;\n\t\t\t\t\tint y = j / size;\n\t\t\t\t\treturn texelFetch( fadeTexture, ivec2( x, y ), 0 ).rg;\n\n\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\tuniform float fadeIn;\n\t\t\t\tuniform float fadeOut;\n\n\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t${t}\n\t\t\t`).replace(/#include <dithering_fragment>/,t=>`\n\n\t\t\t\t${t}\n\n\t\t\t\t#if FEATURE_FADE\n\n\t\t\t\t#ifdef USE_BATCHING_FRAG\n\n\t\t\t\tvec2 fadeValues = getFadeValues( vBatchId );\n\t\t\t\tfloat fadeIn = fadeValues.r;\n\t\t\t\tfloat fadeOut = fadeValues.g;\n\n\t\t\t\t#endif\n\n\t\t\t\tfloat bayerValue = bayerDither4x4( floor( mod( gl_FragCoord.xy, 4.0 ) ) );\n\t\t\t\tfloat bayerBins = 16.0;\n\t\t\t\tfloat dither = ( 0.5 + bayerValue ) / bayerBins;\n\t\t\t\tif ( dither >= fadeIn ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\tif ( dither < fadeOut ) {\n\n\t\t\t\t\tdiscard;\n\n\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t`)},s}class Ir{constructor(){this._fadeParams=new WeakMap,this.fading=0}setFade(t,e,s){if(!t)return;const i=this._fadeParams;t.traverse(t=>{const n=t.material;if(n&&i.has(n)){const t=i.get(n);t.fadeIn.value=e,t.fadeOut.value=s;const r=+(!(0===e||1===e)||!(0===s||1===s));n.defines.FEATURE_FADE!==r&&(this.fading+=1===r?1:-1,n.defines.FEATURE_FADE=r,n.needsUpdate=!0)}})}prepareScene(t){t.traverse(t=>{t.material&&this.prepareMaterial(t.material)})}deleteScene(t){if(!t)return;this.setFade(t,1,0);const e=this._fadeParams;t.traverse(t=>{const s=t.material;s&&e.delete(s)})}prepareMaterial(t){const e=this._fadeParams;e.has(t)||e.set(t,Fr(t,t.onBeforeCompile))}}class Rr{constructor(t,e=new N){this.other=t,this.material=e,this.visible=!0,this.parent=null,this._instanceInfo=[],this._visibilityChanged=!0;const s=new Proxy(this,{get(e,i){if(i in e)return e[i];{const n=t[i];return n instanceof Function?(...t)=>(e.syncInstances(),n.call(s,...t)):t[i]}},set:(e,s,i)=>(s in e?e[s]=i:t[s]=i,!0),deleteProperty:(e,s)=>s in e?delete e[s]:delete t[s]});return s}syncInstances(){const t=this._instanceInfo,e=this.other._instanceInfo;for(;e.length>t.length;){const s=t.length;t.push(new Proxy({visible:!1},{get:(t,i)=>i in t?t[i]:e[s][i],set:(t,i,n)=>(i in t?t[i]=n:e[s][i]=n,!0)}))}}}class kr extends Rr{constructor(...t){super(...t);const e=this.material,s=Fr(e,e.onBeforeCompile);e.defines.FEATURE_FADE=1,e.defines.USE_BATCHING_FRAG=1,e.needsUpdate=!0,this.fadeTexture=null,this._fadeParams=s}setFadeAt(t,e,s){this._initFadeTexture(),this.fadeTexture.setValueAt(t,255*e,255*s)}_initFadeTexture(){let t=Math.sqrt(this._maxInstanceCount);t=Math.ceil(t);const e=t*t*2,s=this.fadeTexture;if(!s||s.image.data.length!==e){const i=new Uint8Array(e),n=new Or(i,t,t,I,R);if(s){s.dispose();const t=s.image.data,e=this.fadeTexture.image.data,i=Math.min(t.length,e.length);e.set(new t.constructor(t.buffer,0,i))}this.fadeTexture=n,this._fadeParams.fadeTexture.value=n,n.needsUpdate=!0}}dispose(){this.fadeTexture&&this.fadeTexture.dispose()}}class Or extends V{setValueAt(t,...e){const{data:s,width:i,height:n}=this.image,r=Math.floor(s.length/(i*n));let o=!1;for(let a=0;a<r;a++){const i=t*r+a,n=s[i],l=e[a]||0;n!==l&&(s[i]=l,o=!0)}o&&(this.needsUpdate=!0)}}const Vr=Symbol("HAS_POPPED_IN"),zr=new t,Br=new t,Nr=new x,jr=new x,Wr=new t;function Gr(){const t=this._fadeManager,e=this.tiles;this._fadingBefore=t.fadeCount,this._displayActiveTiles=e.displayActiveTiles,e.displayActiveTiles=!0}function Hr(){const t=this._fadeManager,e=this._fadeMaterialManager,s=this._displayActiveTiles,i=this._fadingBefore,n=this._prevCameraTransforms,{tiles:r,maximumFadeOutTiles:o,batchedMesh:a}=this,{cameras:l}=r;r.displayActiveTiles=s,t.update();const c=t.fadeCount;if(0!==i&&0!==c&&(r.dispatchEvent({type:"fade-change"}),r.dispatchEvent({type:"needs-render"})),s||r.visibleTiles.forEach(t=>{const e=t.cached.scene;e&&(e.visible=t.__inFrustum),this.forEachBatchIds(t,(e,s,i)=>{s.setVisibleAt(e,t.__inFrustum),i.batchedMesh.setVisibleAt(e,t.__inFrustum)})}),o<this._fadingOutCount){let e=!0;l.forEach(t=>{if(!n.has(t))return;const s=t.matrixWorld,i=n.get(t);s.decompose(Br,jr,Wr),i.decompose(zr,Nr,Wr);const r=jr.angleTo(Nr),o=Br.distanceTo(zr);e=e&&(r>.25||o>.1)}),e&&t.completeAllFades()}if(l.forEach(t=>{n.get(t).copy(t.matrixWorld)}),t.forEachObject((s,{fadeIn:i,fadeOut:n})=>{const o=s.cached.scene,a=t.isFadingOut(s);r.markTileUsed(s),o&&(e.setFade(o,i,n),a&&(o.visible=!0)),this.forEachBatchIds(s,(t,e,s)=>{e.setFadeAt(t,i,n),e.setVisibleAt(t,!0),s.batchedMesh.setVisibleAt(t,!1)})}),a){const t=r.getPluginByName("BATCHED_TILES_PLUGIN").batchedMesh.material;a.material.map=t.map}}class qr{get fadeDuration(){return this._fadeManager.duration}set fadeDuration(t){this._fadeManager.duration=Number(t)}get fadingTiles(){return this._fadeManager.fadeCount}constructor(t){t={maximumFadeOutTiles:50,fadeRootTiles:!1,fadeDuration:250,...t},this.name="FADE_TILES_PLUGIN",this.priority=-2,this.tiles=null,this.batchedMesh=null,this._quickFadeTiles=new Set,this._fadeManager=new Ur,this._fadeMaterialManager=new Ir,this._prevCameraTransforms=null,this._fadingOutCount=0,this.maximumFadeOutTiles=t.maximumFadeOutTiles,this.fadeRootTiles=t.fadeRootTiles,this.fadeDuration=t.fadeDuration}init(t){this._onLoadModel=({scene:t})=>{this._fadeMaterialManager.prepareScene(t)},this._onDisposeModel=({tile:t,scene:e})=>{this.tiles.visibleTiles.has(t)&&this._quickFadeTiles.add(t.parent),this._fadeManager.deleteObject(t),this._fadeMaterialManager.deleteScene(e)},this._onAddCamera=({camera:t})=>{this._prevCameraTransforms.set(t,new e)},this._onDeleteCamera=({camera:t})=>{this._prevCameraTransforms.delete(t)},this._onTileVisibilityChange=({tile:t,visible:e})=>{const s=t.cached.scene;s&&(s.visible=!0),this.forEachBatchIds(t,(t,e,s)=>{e.setFadeAt(t,0,0),e.setVisibleAt(t,!1),s.batchedMesh.setVisibleAt(t,!1)})},this._onUpdateBefore=()=>{Gr.call(this)},this._onUpdateAfter=()=>{Hr.call(this)},t.addEventListener("load-model",this._onLoadModel),t.addEventListener("dispose-model",this._onDisposeModel),t.addEventListener("add-camera",this._onAddCamera),t.addEventListener("delete-camera",this._onDeleteCamera),t.addEventListener("update-before",this._onUpdateBefore),t.addEventListener("update-after",this._onUpdateAfter),t.addEventListener("tile-visibility-change",this._onTileVisibilityChange);const s=this._fadeManager;s.onFadeSetStart=()=>{t.dispatchEvent({type:"fade-start"}),t.dispatchEvent({type:"needs-render"})},s.onFadeSetComplete=()=>{t.dispatchEvent({type:"fade-end"}),t.dispatchEvent({type:"needs-render"})},s.onFadeComplete=(e,s)=>{this._fadeMaterialManager.setFade(e.cached.scene,0,0),this.forEachBatchIds(e,(t,e,i)=>{e.setFadeAt(t,0,0),e.setVisibleAt(t,!1),i.batchedMesh.setVisibleAt(t,s)}),s||(t.invokeOnePlugin(t=>t!==this&&t.setTileVisible&&t.setTileVisible(e,!1)),this._fadingOutCount--)};const i=new Map;t.cameras.forEach(t=>{i.set(t,new e)}),t.forEachLoadedModel((t,e)=>{this._onLoadModel({scene:t})}),this.tiles=t,this._fadeManager=s,this._prevCameraTransforms=i}initBatchedMesh(){var t;const e=null==(t=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"))?void 0:t.batchedMesh;if(e){if(null===this.batchedMesh){this._onBatchedMeshDispose=()=>{this.batchedMesh.dispose(),this.batchedMesh.removeFromParent(),this.batchedMesh=null,e.removeEventListener("dispose",this._onBatchedMeshDispose)};const t=e.material.clone();t.onBeforeCompile=e.material.onBeforeCompile,this.batchedMesh=new kr(e,t),this.tiles.group.add(this.batchedMesh)}}else null!==this.batchedMesh&&(this._onBatchedMeshDispose(),this._onBatchedMeshDispose=null)}setTileVisible(t,e){const s=this._fadeManager,i=s.isFading(t);if(s.isFadingOut(t)&&this._fadingOutCount--,e?1===t.__depthFromRenderedParent?((t[Vr]||this.fadeRootTiles)&&this._fadeManager.fadeIn(t),t[Vr]=!0):this._fadeManager.fadeIn(t):(this._fadingOutCount++,s.fadeOut(t)),this._quickFadeTiles.has(t)&&(this._fadeManager.completeFade(t),this._quickFadeTiles.delete(t)),i)return!0;const n=this._fadeManager.isFading(t);return!(e||!n)}dispose(){const t=this.tiles;this._fadeManager.completeAllFades(),null!==this.batchedMesh&&this._onBatchedMeshDispose(),t.removeEventListener("load-model",this._onLoadModel),t.removeEventListener("dispose-model",this._onDisposeModel),t.removeEventListener("add-camera",this._onAddCamera),t.removeEventListener("delete-camera",this._onDeleteCamera),t.removeEventListener("update-before",this._onUpdateBefore),t.removeEventListener("update-after",this._onUpdateAfter),t.removeEventListener("tile-visibility-change",this._onTileVisibilityChange),t.forEachLoadedModel((t,e)=>{this._fadeManager.deleteObject(e),t&&(t.visible=!0)})}forEachBatchIds(t,e){if(this.initBatchedMesh(),this.batchedMesh){const s=this.tiles.getPluginByName("BATCHED_TILES_PLUGIN"),i=s.getTileBatchIds(t);i&&i.forEach(t=>{e(t,this.batchedMesh,s)})}}}new e,new t,new t,new L,new Z(new N);new V(new Uint8Array([255,255,255,255]),1,1).needsUpdate=!0,new t;export{as as A,En as B,In as D,ai as F,qr as N,Sr as O,Un as U,fi as W,Ar as a};
