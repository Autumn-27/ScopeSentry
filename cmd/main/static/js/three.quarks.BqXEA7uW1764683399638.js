import{cy as e,a2 as t,aN as i,f as n,bm as r,l as s,an as a,aK as o,aJ as l,bE as d,cu as m,B as f,S as c,I as h,aw as p,o as u,aI as v,cz as g,cA as y,at as _,cB as S,au as x,av as M,c2 as T,O as E,g as U,a1 as A,k as P,cC as w,cD as b,p as B,a3 as C,y as O,a6 as R,bJ as N,C as z,bu as I,cE as L,bc as D,bb as F,bK as V,q as k,i as H,j as G,u as j,ar as X,af as W,x as Y,V as J}from"./three.BbguFgn81764683399638.js";import{E as q,C as Z,A as K,V as Q,M as $,a as ee,b as te,S as ie,Q as ne,T as re,c as se,d as ae,e as oe,f as le,G as de,B as me,g as fe,l as ce}from"./quarks.core.C3xH0YPO1764683399638.js";class he{get geometry(){return this._geometry}set geometry(e){if(this._geometry=e,void 0===e)return;if("string"==typeof e)return;const t=new Y;this._triangleIndexToArea.length=0;let i=0;if(!e.getIndex())return;const n=e.getIndex().array,r=n.length/3;this._triangleIndexToArea.push(0);for(let s=0;s<r;s++)t.setFromAttributeAndIndices(e.getAttribute("position"),n[3*s],n[3*s+1],n[3*s+2]),i+=t.getArea(),this._triangleIndexToArea.push(i);e.userData.triangleIndexToArea=this._triangleIndexToArea}constructor(e){this.type="mesh_surface",this._triangleIndexToArea=[],this._tempA=new J,this._tempB=new J,this._tempC=new J,e&&(this.geometry=e)}initialize(e){const t=this._geometry;if(!t||null===t.getIndex())return e.position.set(0,0,0),void e.velocity.set(0,0,1).multiplyScalar(e.startSpeed);const i=this._triangleIndexToArea.length-1;let n=0,r=i;const s=Math.random()*this._triangleIndexToArea[i];for(;n+1<r;){const e=Math.floor((n+r)/2);s<this._triangleIndexToArea[e]?r=e:n=e}let a=Math.random(),o=Math.random();a+o>1&&(a=1-a,o=1-o);const l=t.getIndex().array[3*n],d=t.getIndex().array[3*n+1],m=t.getIndex().array[3*n+2],f=t.getAttribute("position");this._tempA.fromBufferAttribute(f,l),this._tempB.fromBufferAttribute(f,d),this._tempC.fromBufferAttribute(f,m),this._tempB.sub(this._tempA),this._tempC.sub(this._tempA),this._tempA.addScaledVector(this._tempB,a).addScaledVector(this._tempC,o),e.position.copy(this._tempA),this._tempA.copy(this._tempB).cross(this._tempC).normalize(),e.velocity.copy(this._tempA).normalize().multiplyScalar(e.startSpeed)}toJSON(){return{type:"mesh_surface",mesh:this._geometry?this._geometry.uuid:""}}static fromJSON(e,t){return new he(t.geometries[e.geometry])}clone(){return new he(this._geometry)}update(e,t){}}const pe={id:"three.quarks",emitterShapes:[{type:"mesh_surface",params:[["geometry",["geometry"]]],constructor:he,loadJSON:he.fromJSON}],behaviors:[]};const ue=W;class ve extends t{constructor(e){super(),this.type="ParticleEmitter",this.system=e}clone(){const e=this.system.clone();return e.emitter.copy(this,!0),e.emitter}dispose(){}extractFromCache(e){const t=[];for(const i in e){const n=e[i];delete n.metadata,t.push(n)}return t}toJSON(e,t={}){const i=this.children;this.children=this.children.filter(e=>"ParticleSystemPreview"!==e.type);const n=super.toJSON(e);return this.children=i,null!==this.system&&(n.object.ps=this.system.toJSON(e,t)),n}}var ge;!function(e){e[e.BillBoard=0]="BillBoard",e[e.StretchedBillBoard=1]="StretchedBillBoard",e[e.Mesh=2]="Mesh",e[e.Trail=3]="Trail",e[e.HorizontalBillBoard=4]="HorizontalBillBoard",e[e.VerticalBillBoard=5]="VerticalBillBoard"}(ge||(ge={}));class ye extends u{constructor(e){super(),this.type="VFXBatch",this.maxParticles=1e3,this.systems=new Set;const t=new C;t.mask=e.layers.mask;const i=e.material.clone();i.defines={},Object.assign(i.defines,e.material.defines),this.settings={instancingGeometry:e.instancingGeometry,renderMode:e.renderMode,renderOrder:e.renderOrder,material:i,uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softNearFade:e.softNearFade,softFarFade:e.softFarFade,layers:t},this.frustumCulled=!1,this.renderOrder=this.settings.renderOrder}addSystem(e){this.systems.add(e)}removeSystem(e){this.systems.delete(e)}applyDepthTexture(e){const t=this.material.uniforms.depthTexture;t&&t.value!==e&&(t.value=e,this.material.needsUpdate=!0)}getVisibleSystems(){return Array.from(this.systems).filter(e=>e.emitter.visible)}}const _e=new Q(0,0,1),Se=new ne,xe=new Q,Me=new Q;new Q;const Te=new B(1,1,1,1);class Ee{set time(e){this.emissionState.time=e}get time(){return this.emissionState.time}get layers(){return this.rendererSettings.layers}get texture(){return this.rendererSettings.material.map}set texture(e){this.rendererSettings.material.map=e,this.neededToUpdateRender=!0}get material(){return this.rendererSettings.material}set material(e){this.rendererSettings.material=e,this.neededToUpdateRender=!0}get uTileCount(){return this.rendererSettings.uTileCount}set uTileCount(e){this.rendererSettings.uTileCount=e,this.neededToUpdateRender=!0}get vTileCount(){return this.rendererSettings.vTileCount}set vTileCount(e){this.rendererSettings.vTileCount=e,this.neededToUpdateRender=!0}get blendTiles(){return this.rendererSettings.blendTiles}set blendTiles(e){this.rendererSettings.blendTiles=e,this.neededToUpdateRender=!0}get softParticles(){return this.rendererSettings.softParticles}set softParticles(e){this.rendererSettings.softParticles=e,this.neededToUpdateRender=!0}get softNearFade(){return this.rendererSettings.softNearFade}set softNearFade(e){this.rendererSettings.softNearFade=e,this.neededToUpdateRender=!0}get softFarFade(){return this.rendererSettings.softFarFade}set softFarFade(e){this.rendererSettings.softFarFade=e,this.neededToUpdateRender=!0}get instancingGeometry(){return this.rendererSettings.instancingGeometry}set instancingGeometry(e){this.restart(),this.particles.length=0,this.rendererSettings.instancingGeometry=e,this.neededToUpdateRender=!0}get renderMode(){return this.rendererSettings.renderMode}set renderMode(e){if(this.rendererSettings.renderMode!==e){let t=!1;switch(this.rendererSettings.renderMode===ge.Trail&&(t=!0),this.rendererSettings.renderMode===ge.Mesh&&(this.startRotation=new Z(0)),e){case ge.Trail:this.rendererEmitterSettings={startLength:new Z(30),followLocalOrigin:!1},t=!0;break;case ge.Mesh:this.rendererEmitterSettings={geometry:Te},this.startRotation=new K(new Q(0,1,0),new Z(0));break;case ge.StretchedBillBoard:this.rendererEmitterSettings={speedFactor:0,lengthFactor:2},this.rendererSettings.instancingGeometry=Te;break;case ge.BillBoard:case ge.VerticalBillBoard:case ge.HorizontalBillBoard:this.rendererEmitterSettings={},this.rendererSettings.instancingGeometry=Te}this.rendererSettings.renderMode=e,t&&(this.restart(),this.particles.length=0),this.neededToUpdateRender=!0}}get renderOrder(){return this.rendererSettings.renderOrder}set renderOrder(e){this.rendererSettings.renderOrder=e,this.neededToUpdateRender=!0}get blending(){return this.rendererSettings.material.blending}set blending(e){this.rendererSettings.material.blending=e,this.neededToUpdateRender=!0}constructor(e){if(this.temp=new Q,this.travelDistance=0,this.normalMatrix=new $,this.memory=[],this.listeners={},this.firstTimeUpdate=!0,this.autoDestroy=void 0!==e.autoDestroy&&e.autoDestroy,this.duration=e.duration??1,this.looping=void 0===e.looping||e.looping,this.prewarm=void 0!==e.prewarm&&e.prewarm,this.startLife=e.startLife??new Z(5),this.startSpeed=e.startSpeed??new Z(0),this.startRotation=e.startRotation??new Z(0),this.startSize=e.startSize??new Z(1),this.startColor=e.startColor??new ee(new te(1,1,1,1)),this.emissionOverTime=e.emissionOverTime??new Z(10),this.emissionOverDistance=e.emissionOverDistance??new Z(0),this.emissionBursts=e.emissionBursts??[],this.onlyUsedByOther=e.onlyUsedByOther??!1,this.emitterShape=e.shape??new ie,this.behaviors=e.behaviors??new Array,this.worldSpace=e.worldSpace??!1,this.rendererEmitterSettings=e.rendererEmitterSettings??{},e.renderMode===ge.StretchedBillBoard){const t=this.rendererEmitterSettings;void 0!==e.speedFactor&&(t.speedFactor=e.speedFactor),t.speedFactor=t.speedFactor??0,t.lengthFactor=t.lengthFactor??0}this.rendererSettings={instancingGeometry:e.instancingGeometry??Te,renderMode:e.renderMode??ge.BillBoard,renderOrder:e.renderOrder??0,material:e.material,uTileCount:e.uTileCount??1,vTileCount:e.vTileCount??1,blendTiles:e.blendTiles??!1,softParticles:e.softParticles??!1,softNearFade:e.softNearFade??0,softFarFade:e.softFarFade??0,layers:e.layers??new C},this.neededToUpdateRender=!0,this.particles=new Array,this.startTileIndex=e.startTileIndex||new Z(0),this.emitter=new ve(this),this.paused=!1,this.particleNum=0,this.emissionState={isBursting:!1,burstParticleIndex:0,burstParticleCount:0,burstIndex:0,burstWaveIndex:0,time:0,waitEmiting:0,travelDistance:0},this.emissionBursts.forEach(e=>e.count.startGen(this.memory)),this.emissionOverDistance.startGen(this.memory),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1}pause(){this.paused=!0}play(){this.paused=!1}stop(){this.restart(),this.pause()}spawn(e,t,i){Se.setFromRotationMatrix(i);const n=xe,r=Se,s=Me;i.decompose(n,r,s);for(let a=0;a<e;a++){for(t.burstParticleIndex=a,this.particleNum++;this.particles.length<this.particleNum;)this.rendererSettings.renderMode===ge.Trail?this.particles.push(new re):this.particles.push(new se);const e=this.particles[this.particleNum-1];if(e.reset(),e.speedModifier=1,this.startColor.startGen(e.memory),this.startColor.genColor(e.memory,e.startColor,this.emissionState.time),e.color.copy(e.startColor),this.startSpeed.startGen(e.memory),e.startSpeed=this.startSpeed.genValue(e.memory,t.time/this.duration),this.startLife.startGen(e.memory),e.life=this.startLife.genValue(e.memory,t.time/this.duration),e.age=0,this.startSize.startGen(e.memory),"vec3function"===this.startSize.type)this.startSize.genValue(e.memory,e.startSize,t.time/this.duration);else{const i=this.startSize.genValue(e.memory,t.time/this.duration);e.startSize.set(i,i,i)}if(this.startTileIndex.startGen(e.memory),e.uvTile=this.startTileIndex.genValue(e.memory),e.size.copy(e.startSize),this.rendererSettings.renderMode===ge.Mesh||this.rendererSettings.renderMode===ge.BillBoard||this.rendererSettings.renderMode===ge.VerticalBillBoard||this.rendererSettings.renderMode===ge.HorizontalBillBoard||this.rendererSettings.renderMode===ge.StretchedBillBoard){const i=e;this.startRotation.startGen(e.memory),this.rendererSettings.renderMode===ge.Mesh?(i.rotation instanceof ne||(i.rotation=new ne),"rotation"===this.startRotation.type?this.startRotation.genValue(e.memory,i.rotation,1,t.time/this.duration):i.rotation.setFromAxisAngle(_e,this.startRotation.genValue(i.memory,t.time/this.duration))):"rotation"===this.startRotation.type?i.rotation=0:i.rotation=this.startRotation.genValue(i.memory,t.time/this.duration)}else if(this.rendererSettings.renderMode===ge.Trail){const i=e;this.rendererEmitterSettings.startLength.startGen(i.memory),i.length=this.rendererEmitterSettings.startLength.genValue(i.memory,t.time/this.duration)}if(this.emitterShape.initialize(e,t),this.rendererSettings.renderMode===ge.Trail&&this.rendererEmitterSettings.followLocalOrigin){const t=e;t.localPosition=(new Q).copy(t.position)}this.worldSpace?(e.position.applyMatrix4(i),e.startSize.multiply(s).abs(),e.size.copy(e.startSize),e.velocity.multiply(s).applyMatrix3(this.normalMatrix),e.rotation&&e.rotation instanceof ne&&e.rotation.multiplyQuaternions(Se,e.rotation)):this.onlyUsedByOther&&(e.parentMatrix=i);for(let t=0;t<this.behaviors.length;t++)this.behaviors[t].initialize(e,this)}}endEmit(){this.emitEnded=!0,this.autoDestroy&&(this.markForDestroy=!0),this.fire({type:"emitEnd",particleSystem:this})}dispose(){this._renderer&&this._renderer.deleteSystem(this),this.emitter.dispose(),this.emitter.parent&&this.emitter.parent.remove(this.emitter),this.fire({type:"destroy",particleSystem:this})}restart(){this.memory.length=0,this.paused=!1,this.particleNum=0,this.emissionState.isBursting=!1,this.emissionState.burstIndex=0,this.emissionState.burstWaveIndex=0,this.emissionState.time=0,this.emissionState.waitEmiting=0,this.behaviors.forEach(e=>{e.reset()}),this.emitEnded=!1,this.markForDestroy=!1,this.prewarmed=!1,this.emissionBursts.forEach(e=>e.count.startGen(this.memory)),this.emissionOverDistance.startGen(this.memory)}update(e){if(this.paused)return;let t=this.emitter;for(;t.parent;)t=t.parent;if("Scene"===t.type)if(this.firstTimeUpdate&&(this.firstTimeUpdate=!1,this.emitter.updateWorldMatrix(!0,!1)),this.emitEnded&&0===this.particleNum)this.markForDestroy&&this.emitter.parent&&this.dispose();else{if(this.looping&&this.prewarm&&!this.prewarmed){this.prewarmed=!0;for(let e=0;e<60*this.duration;e++)this.update(1/60)}e>.1&&(e=.1),this.neededToUpdateRender&&(this._renderer&&this._renderer.updateSystem(this),this.neededToUpdateRender=!1),this.onlyUsedByOther||this.emit(e,this.emissionState,this.emitter.matrixWorld),this.emitterShape.update(this,e);for(let t=0;t<this.behaviors.length;t++){this.behaviors[t].frameUpdate(e);for(let i=0;i<this.particleNum;i++)this.particles[i].died||this.behaviors[t].update(this.particles[i],e)}for(let t=0;t<this.particleNum;t++)this.rendererEmitterSettings.followLocalOrigin&&this.particles[t].localPosition?(this.particles[t].position.copy(this.particles[t].localPosition),this.particles[t].parentMatrix?this.particles[t].position.applyMatrix4(this.particles[t].parentMatrix):this.particles[t].position.applyMatrix4(this.emitter.matrixWorld)):this.particles[t].position.addScaledVector(this.particles[t].velocity,e*this.particles[t].speedModifier),this.particles[t].age+=e;if(this.rendererSettings.renderMode===ge.Trail)for(let e=0;e<this.particleNum;e++){this.particles[e].update()}for(let e=0;e<this.particleNum;e++){const t=this.particles[e];!t.died||t instanceof re&&0!==t.previous.length||(this.particles[e]=this.particles[this.particleNum-1],this.particles[this.particleNum-1]=t,this.particleNum--,e--,this.fire({type:"particleDied",particleSystem:this,particle:t}))}}else this.dispose()}emit(e,t,i){t.time>this.duration&&(this.looping?(t.time-=this.duration,t.burstIndex=0,this.behaviors.forEach(e=>{e.reset()})):this.emitEnded||this.onlyUsedByOther||this.endEmit()),this.normalMatrix.getNormalMatrix(i);const n=Math.ceil(t.waitEmiting);for(this.spawn(n,t,i),t.waitEmiting-=n;t.burstIndex<this.emissionBursts.length&&this.emissionBursts[t.burstIndex].time<=t.time;){if(Math.random()<this.emissionBursts[t.burstIndex].probability){const e=this.emissionBursts[t.burstIndex].count.genValue(this.memory,this.time);t.isBursting=!0,t.burstParticleCount=e,this.spawn(e,t,i),t.isBursting=!1}t.burstIndex++}if(!this.emitEnded&&(t.waitEmiting+=e*this.emissionOverTime.genValue(this.memory,t.time/this.duration),null!=t.previousWorldPos)){this.temp.set(i.elements[12],i.elements[13],i.elements[14]),t.travelDistance+=t.previousWorldPos.distanceTo(this.temp);const e=this.emissionOverDistance.genValue(this.memory,t.time/this.duration);if(t.travelDistance*e>0){const i=Math.floor(t.travelDistance*e);t.travelDistance-=i/e,t.waitEmiting+=i}}void 0===t.previousWorldPos&&(t.previousWorldPos=new Q),t.previousWorldPos.set(i.elements[12],i.elements[13],i.elements[14]),t.time+=e}toJSON(e,t={}){if((void 0===e||"string"==typeof e)&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}}),e.materials[this.rendererSettings.material.uuid]=this.rendererSettings.material.toJSON(e),t.useUrlForImage&&void 0!==this.texture?.source){const t=this.texture.source;e.images[t.uuid]={uuid:t.uuid,url:this.texture.image.url}}let i;i=this.renderMode===ge.Trail?{startLength:this.rendererEmitterSettings.startLength.toJSON(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===ge.Mesh?{}:this.renderMode===ge.StretchedBillBoard?{speedFactor:this.rendererEmitterSettings.speedFactor,lengthFactor:this.rendererEmitterSettings.lengthFactor}:{};const n=this.rendererSettings.instancingGeometry;return e.geometries&&!e.geometries[n.uuid]&&(e.geometries[n.uuid]=n.toJSON()),{version:"3.0",autoDestroy:this.autoDestroy,looping:this.looping,prewarm:this.prewarm,duration:this.duration,shape:this.emitterShape.toJSON(),startLife:this.startLife.toJSON(),startSpeed:this.startSpeed.toJSON(),startRotation:this.startRotation.toJSON(),startSize:this.startSize.toJSON(),startColor:this.startColor.toJSON(),emissionOverTime:this.emissionOverTime.toJSON(),emissionOverDistance:this.emissionOverDistance.toJSON(),emissionBursts:this.emissionBursts.map(e=>({time:e.time,count:e.count.toJSON(),probability:e.probability,interval:e.interval,cycle:e.cycle})),onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry.uuid,renderOrder:this.renderOrder,renderMode:this.renderMode,rendererEmitterSettings:i,material:this.rendererSettings.material.uuid,layers:this.layers.mask,startTileIndex:this.startTileIndex.toJSON(),uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.rendererSettings.softParticles,softFarFade:this.rendererSettings.softFarFade,softNearFade:this.rendererSettings.softNearFade,behaviors:this.behaviors.map(e=>e.toJSON()),worldSpace:this.worldSpace}}static fromJSON(e,t,i){const n=ae(e.shape,t);let r;if(e.renderMode===ge.Trail){const t=e.rendererEmitterSettings;r={startLength:null!=t.startLength?oe(t.startLength):new Z(30),followLocalOrigin:t.followLocalOrigin}}else e.renderMode===ge.Mesh?r={}:e.renderMode===ge.StretchedBillBoard?(r=e.rendererEmitterSettings,null!=e.speedFactor&&(r.speedFactor=e.speedFactor)):r={};const s=new C;e.layers&&(s.mask=e.layers);const a=new Ee({autoDestroy:e.autoDestroy,looping:e.looping,prewarm:e.prewarm,duration:e.duration,shape:n,startLife:oe(e.startLife),startSpeed:oe(e.startSpeed),startRotation:de(e.startRotation),startSize:de(e.startSize),startColor:le(e.startColor),emissionOverTime:oe(e.emissionOverTime),emissionOverDistance:oe(e.emissionOverDistance),emissionBursts:e.emissionBursts?.map(e=>({time:e.time,count:"number"==typeof e.count?new Z(e.count):oe(e.count),probability:e.probability??1,interval:e.interval??.1,cycle:e.cycle??1})),onlyUsedByOther:e.onlyUsedByOther,instancingGeometry:t.geometries[e.instancingGeometry],renderMode:e.renderMode,rendererEmitterSettings:r,renderOrder:e.renderOrder,layers:s,material:e.material?t.materials[e.material]:e.texture?new O({map:t.textures[e.texture],transparent:e.transparent??!0,blending:e.blending,side:R}):new O({color:16777215,transparent:!0,blending:N,side:R}),startTileIndex:"number"==typeof e.startTileIndex?new Z(e.startTileIndex):oe(e.startTileIndex),uTileCount:e.uTileCount,vTileCount:e.vTileCount,blendTiles:e.blendTiles,softParticles:e.softParticles,softFarFade:e.softFarFade,softNearFade:e.softNearFade,behaviors:[],worldSpace:e.worldSpace});return a.behaviors=e.behaviors.map(e=>{const t=me(e,a);return t&&"EmitSubParticleSystem"===t.type&&(i[e.subParticleSystem]=t),t}).filter(e=>null!==e),a}addBehavior(e){this.behaviors.push(e)}getRendererSettings(){return this.rendererSettings}addEventListener(e,t){this.listeners[e]||(this.listeners[e]=[]),this.listeners[e].push(t)}removeAllEventListeners(e){this.listeners[e]&&(this.listeners[e]=[])}removeEventListener(e,t){if(this.listeners[e]){const i=this.listeners[e].indexOf(t);-1!==i&&this.listeners[e].splice(i,1)}}fire(e){this.listeners[e.type]&&this.listeners[e.type].forEach(t=>t(e))}clone(){const e=[];for(const r of this.emissionBursts){const t={};Object.assign(t,r),e.push(t)}const t=[];for(const r of this.behaviors)t.push(r.clone());let i;i=this.renderMode===ge.Trail?{startLength:this.rendererEmitterSettings.startLength.clone(),followLocalOrigin:this.rendererEmitterSettings.followLocalOrigin}:this.renderMode===ge.StretchedBillBoard?{lengthFactor:this.rendererEmitterSettings.lengthFactor,speedFactor:this.rendererEmitterSettings.speedFactor}:{};const n=new C;return n.mask=this.layers.mask,new Ee({autoDestroy:this.autoDestroy,looping:this.looping,duration:this.duration,shape:this.emitterShape.clone(),startLife:this.startLife.clone(),startSpeed:this.startSpeed.clone(),startRotation:this.startRotation.clone(),startSize:this.startSize.clone(),startColor:this.startColor.clone(),emissionOverTime:this.emissionOverTime.clone(),emissionOverDistance:this.emissionOverDistance.clone(),emissionBursts:e,onlyUsedByOther:this.onlyUsedByOther,instancingGeometry:this.rendererSettings.instancingGeometry,renderMode:this.renderMode,renderOrder:this.renderOrder,rendererEmitterSettings:i,material:this.rendererSettings.material,startTileIndex:this.startTileIndex,uTileCount:this.uTileCount,vTileCount:this.vTileCount,blendTiles:this.blendTiles,softParticles:this.softParticles,softFarFade:this.softFarFade,softNearFade:this.softNearFade,behaviors:t,worldSpace:this.worldSpace,layers:n})}}var Ue="\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n#include <alphatest_pars_fragment>\n\n#include <tile_pars_fragment>\n#include <soft_pars_fragment>\n\nvoid main() {\n\n    #include <clipping_planes_fragment>\n    \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vColor;\n    \n    #include <logdepthbuf_fragment>\n    \n    #include <tile_fragment>\n    #include <alphatest_fragment>\n\n    outgoingLight = diffuseColor.rgb;\n    \n    #ifdef USE_COLOR_AS_ALPHA\n    gl_FragColor = vec4( outgoingLight, diffuseColor.r );\n    #else\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    #endif\n    \n    #include <soft_fragment>\n    #include <tonemapping_fragment>\n}\n",Ae="\n#define STANDARD\n\n#ifdef PHYSICAL\n#define IOR\n#define USE_SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\nuniform float ior;\n#endif\n\n#ifdef USE_SPECULAR\nuniform float specularIntensity;\nuniform vec3 specularColor;\n\n#ifdef USE_SPECULAR_COLORMAP\nuniform sampler2D specularColorMap;\n#endif\n\n#ifdef USE_SPECULAR_INTENSITYMAP\nuniform sampler2D specularIntensityMap;\n#endif\n#endif\n\n#ifdef USE_CLEARCOAT\nuniform float clearcoat;\nuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_DISPERSION\nuniform float dispersion;\n#endif\n\n#ifdef USE_IRIDESCENCE\nuniform float iridescence;\nuniform float iridescenceIOR;\nuniform float iridescenceThicknessMinimum;\nuniform float iridescenceThicknessMaximum;\n#endif\n\n#ifdef USE_SHEEN\nuniform vec3 sheenColor;\nuniform float sheenRoughness;\n\n#ifdef USE_SHEEN_COLORMAP\nuniform sampler2D sheenColorMap;\n#endif\n\n#ifdef USE_SHEEN_ROUGHNESSMAP\nuniform sampler2D sheenRoughnessMap;\n#endif\n#endif\n\n#ifdef USE_ANISOTROPY\nuniform vec2 anisotropyVector;\n\n#ifdef USE_ANISOTROPYMAP\nuniform sampler2D anisotropyMap;\n#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\nvec4 diffuseColor = vec4( diffuse, opacity );\n#include <clipping_planes_fragment>\n\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\nvec3 totalEmissiveRadiance = emissive;\n\n#include <logdepthbuf_fragment>\n#include <map_fragment>\n#include <color_fragment>\n#include <alphamap_fragment>\n#include <alphatest_fragment>\n#include <alphahash_fragment>\n#include <roughnessmap_fragment>\n#include <metalnessmap_fragment>\n#include <normal_fragment_begin>\n#include <normal_fragment_maps>\n#include <clearcoat_normal_fragment_begin>\n#include <clearcoat_normal_fragment_maps>\n#include <emissivemap_fragment>\n\n// accumulation\n#include <lights_physical_fragment>\n#include <lights_fragment_begin>\n#include <lights_fragment_maps>\n#include <lights_fragment_end>\n\n// modulation\n#include <aomap_fragment>\n\nvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\nvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n#include <transmission_fragment>\n\nvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n#ifdef USE_SHEEN\n\n// Sheen energy compensation approximation calculation can be found at the end of\n// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\nfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\noutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\n#endif\n\n#ifdef USE_CLEARCOAT\n\nfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\nvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\noutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\n#endif\n\n#include <opaque_fragment>\n#include <tonemapping_fragment>\n#include <colorspace_fragment>\n#include <fog_fragment>\n#include <premultiplied_alpha_fragment>\n#include <dithering_fragment>\n}",Pe="\n#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n#include <tile_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n    #include <tile_vertex>\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n\n    mat4 particleMatrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n\n#include <color_vertex>\n#include <morphinstance_vertex>\n#include <morphcolor_vertex>\n#include <batching_vertex>\n\n#include <beginnormal_vertex>\n#include <morphnormal_vertex>\n#include <skinbase_vertex>\n#include <skinnormal_vertex>\n\n\t// replace defaultnormal_vertex\n\tvec3 transformedNormal = objectNormal;\n    mat3 m = mat3( particleMatrix );\n    transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n    transformedNormal = m * transformedNormal;\n    transformedNormal = normalMatrix * transformedNormal;\n    #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n    #endif\n    #ifdef USE_TANGENT\n        vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n        #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n        #endif\n    #endif\n\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\n\t// replace include <project_vertex>\n  vec4 mvPosition = vec4( transformed, 1.0 );\n  mvPosition = modelViewMatrix * (particleMatrix * mvPosition);\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n\tvViewPosition = - mvPosition.xyz;\n\t\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n    vWorldPosition = worldPosition.xyz;\n#endif\n}\n";function we(e){return 0===e?"uv":`uv${e}`}class be extends j{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Pe,e.fragmentShader=Ae}}class Be extends X{constructor(e){super(e)}onBeforeCompile(e,t){super.onBeforeCompile(e,t),e.vertexShader=Pe,e.fragmentShader=Ae}}class Ce extends ye{constructor(e){super(e),this.vector_=new Q,this.vector2_=new Q,this.vector3_=new Q,this.quaternion_=new ne,this.quaternion2_=new ne,this.quaternion3_=new ne,this.rotationMat_=new $,this.rotationMat2_=new $,this.maxParticles=1e3,this.setupBuffers(),this.rebuildMaterial()}buildExpandableBuffers(){this.offsetBuffer=new p(new Float32Array(3*this.maxParticles),3),this.offsetBuffer.setUsage(D),this.geometry.setAttribute("offset",this.offsetBuffer),this.colorBuffer=new p(new Float32Array(4*this.maxParticles),4),this.colorBuffer.setUsage(D),this.geometry.setAttribute("color",this.colorBuffer),this.settings.renderMode===ge.Mesh?(this.rotationBuffer=new p(new Float32Array(4*this.maxParticles),4),this.rotationBuffer.setUsage(D),this.geometry.setAttribute("rotation",this.rotationBuffer)):this.settings.renderMode!==ge.BillBoard&&this.settings.renderMode!==ge.HorizontalBillBoard&&this.settings.renderMode!==ge.VerticalBillBoard&&this.settings.renderMode!==ge.StretchedBillBoard||(this.rotationBuffer=new p(new Float32Array(this.maxParticles),1),this.rotationBuffer.setUsage(D),this.geometry.setAttribute("rotation",this.rotationBuffer)),this.sizeBuffer=new p(new Float32Array(3*this.maxParticles),3),this.sizeBuffer.setUsage(D),this.geometry.setAttribute("size",this.sizeBuffer),this.uvTileBuffer=new p(new Float32Array(this.maxParticles),1),this.uvTileBuffer.setUsage(D),this.geometry.setAttribute("uvTile",this.uvTileBuffer),this.settings.renderMode===ge.StretchedBillBoard&&(this.velocityBuffer=new p(new Float32Array(4*this.maxParticles),4),this.velocityBuffer.setUsage(D),this.geometry.setAttribute("velocity",this.velocityBuffer))}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new F,this.geometry.setIndex(this.settings.instancingGeometry.getIndex()),this.settings.instancingGeometry.hasAttribute("normal")&&this.geometry.setAttribute("normal",this.settings.instancingGeometry.getAttribute("normal")),this.geometry.setAttribute("position",this.settings.instancingGeometry.getAttribute("position")),this.settings.instancingGeometry.hasAttribute("uv")&&this.geometry.setAttribute("uv",this.settings.instancingGeometry.getAttribute("uv")),this.buildExpandableBuffers()}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={},t={};"MeshStandardMaterial"!==this.settings.material.type&&"MeshPhysicalMaterial"!==this.settings.material.type&&(e.map=new V(this.settings.material.map)),this.settings.material.alphaTest&&(t.USE_ALPHATEST="",e.alphaTest=new V(this.settings.material.alphaTest)),t.USE_UV="";const i=this.settings.uTileCount,n=this.settings.vTileCount;let r;if((i>1||n>1)&&(t.UV_TILE="",e.tileCount=new V(new fe(i,n))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.material.normalMap&&(t.USE_NORMALMAP="",t.NORMALMAP_UV=we(this.settings.material.normalMap.channel),e.normalMapTransform=new V((new $).copy(this.settings.material.normalMap.matrix))),this.settings.material.map&&(t.USE_MAP="",this.settings.blendTiles&&(t.TILE_BLEND=""),t.MAP_UV=we(this.settings.material.map.channel),e.mapTransform=new V((new $).copy(this.settings.material.map.matrix))),t.USE_COLOR_ALPHA="",this.settings.softParticles){t.SOFT_PARTICLES="";const i=this.settings.softNearFade,n=1/(this.settings.softFarFade-this.settings.softNearFade);e.softParams=new V(new fe(i,n)),e.depthTexture=new V(null);const s=e.projParams=new V(new te);r=(e,t,i)=>{s.value.set(i.near,i.far,0,0)}}let s=!1;if(this.settings.renderMode===ge.BillBoard||this.settings.renderMode===ge.VerticalBillBoard||this.settings.renderMode===ge.HorizontalBillBoard||this.settings.renderMode===ge.Mesh){let i,n;this.settings.renderMode===ge.Mesh?"MeshStandardMaterial"===this.settings.material.type||"MeshPhysicalMaterial"===this.settings.material.type?(t.USE_COLOR="",i=Pe,n=Ae,s=!0):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute vec4 rotation;\nattribute vec3 size;\n// attribute vec4 color;\n\nvoid main() {\n\n    float x2 = rotation.x + rotation.x, y2 = rotation.y + rotation.y, z2 = rotation.z + rotation.z;\n    float xx = rotation.x * x2, xy = rotation.x * y2, xz = rotation.x * z2;\n    float yy = rotation.y * y2, yz = rotation.y * z2, zz = rotation.z * z2;\n    float wx = rotation.w * x2, wy = rotation.w * y2, wz = rotation.w * z2;\n    float sx = size.x, sy = size.y, sz = size.z;\n    \n    mat4 matrix = mat4(( 1.0 - ( yy + zz ) ) * sx, ( xy + wz ) * sx, ( xz - wy ) * sx, 0.0,  // 1. column\n                      ( xy - wz ) * sy, ( 1.0 - ( xx + zz ) ) * sy, ( yz + wx ) * sy, 0.0,  // 2. column\n                      ( xz + wy ) * sz, ( yz - wx ) * sz, ( 1.0 - ( xx + yy ) ) * sz, 0.0,  // 3. column\n                      offset.x, offset.y, offset.z, 1.0);\n    \n    vec4 mvPosition = modelViewMatrix * (matrix * vec4( position, 1.0 ));\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n    #include <tile_vertex>\n    #include <soft_vertex>\n}\n",n=Ue):(i="\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\n\nvoid main() {\n\t\n    vec2 alignedPosition = position.xy * size.xy;\n    \n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n    rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n#ifdef HORIZONTAL\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.x += rotatedPosition.x;\n    mvPosition.z -= rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n#elif defined(VERTICAL)\n    vec4 mvPosition = modelMatrix * vec4( offset, 1.0 );\n    mvPosition.y += rotatedPosition.y;\n    mvPosition = viewMatrix * mvPosition;\n    mvPosition.x += rotatedPosition.x;\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    mvPosition.xy += rotatedPosition;\n#endif\n\n\tvColor = color;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\n\t#include <clipping_planes_vertex>\n\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",n=Ue),this.settings.renderMode===ge.VerticalBillBoard?t.VERTICAL="":this.settings.renderMode===ge.HorizontalBillBoard&&(t.HORIZONTAL="");let r=!1;this.settings.renderMode===ge.Mesh&&("MeshStandardMaterial"===this.settings.material.type?(this.material=new be({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0):"MeshPhysicalMaterial"===this.settings.material.type&&(this.material=new Be({}),this.material.copy(this.settings.material),this.material.uniforms=e,this.material.defines=t,r=!0)),r||(this.material=new k({uniforms:e,defines:t,vertexShader:i,fragmentShader:n,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest,lights:s}))}else{if(this.settings.renderMode!==ge.StretchedBillBoard)throw new Error("render mode unavailable");e.speedFactor=new V(1),this.material=new k({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#include <tile_pars_vertex>\n#include <soft_pars_vertex>\n\nattribute vec3 offset;\nattribute float rotation;\nattribute vec3 size;\nattribute vec4 velocity;\n\nuniform float speedFactor;\n\nvoid main() {\n    float lengthFactor = velocity.w;\n    float avgSize = (size.x + size.y) * 0.5;\n#ifdef USE_SKEW\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n\n    vec3 scaledPos = vec3(position.xy * size.xy, position.z);\n    float vlength = length(viewVelocity);\n    vec3 projVelocity =  dot(scaledPos, viewVelocity) * viewVelocity / vlength;\n    mvPosition.xyz += scaledPos + projVelocity * (speedFactor / avgSize + lengthFactor / vlength);\n#else\n    vec4 mvPosition = modelViewMatrix * vec4( offset, 1.0 );\n    vec3 viewVelocity = normalMatrix * velocity.xyz;\n    float vlength = length(viewVelocity); \n    mvPosition.xyz += position.y * normalize(cross(mvPosition.xyz, viewVelocity)) * avgSize; // switch the cross to  match unity implementation\n    mvPosition.xyz -= (position.x + 0.5) * viewVelocity * (1.0 + lengthFactor / vlength) * avgSize; // minus position.x to match unity implementation\n#endif\n\tvColor = color;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <tile_vertex>\n\t#include <soft_vertex>\n}\n",fragmentShader:Ue,transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,blending:this.settings.material.blending,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha,side:this.settings.material.side,alphaTest:this.settings.material.alphaTest,depthTest:this.settings.material.depthTest})}this.material&&r&&(this.material.onBeforeRender=r)}update(){let e=0,t=0;const i=this.getVisibleSystems();for(const n of i)t+=n.particleNum;t>this.maxParticles&&this.expandBuffers(t);for(const n of i){n.emitter.updateMatrixWorld&&(n.emitter.updateWorldMatrix(!0,!1),n.emitter.updateMatrixWorld(!0));const t=n.particles,i=n.particleNum,r=this.quaternion2_,s=this.vector2_,a=this.vector3_;n.emitter.matrixWorld.decompose(s,r,a),this.rotationMat_.setFromMatrix4(n.emitter.matrixWorld);for(let o=0;o<i;o++,e++){const i=t[o];if(this.settings.renderMode===ge.Mesh){let t;if(n.worldSpace)t=i.rotation;else{let e;e=i.parentMatrix?this.quaternion3_.setFromRotationMatrix(i.parentMatrix):r,t=this.quaternion_,t.copy(e).multiply(i.rotation)}this.rotationBuffer.setXYZW(e,t.x,t.y,t.z,t.w)}else this.settings.renderMode!==ge.StretchedBillBoard&&this.settings.renderMode!==ge.VerticalBillBoard&&this.settings.renderMode!==ge.HorizontalBillBoard&&this.settings.renderMode!==ge.BillBoard||this.rotationBuffer.setX(e,i.rotation);let s;if(n.worldSpace?s=i.position:(s=this.vector_,i.parentMatrix?s.copy(i.position).applyMatrix4(i.parentMatrix):s.copy(i.position).applyMatrix4(n.emitter.matrixWorld)),this.offsetBuffer.setXYZ(e,s.x,s.y,s.z),this.colorBuffer.setXYZW(e,i.color.x,i.color.y,i.color.z,i.color.w),n.worldSpace||i.parentMatrix?this.sizeBuffer.setXYZ(e,i.size.x,i.size.y,i.size.z):this.sizeBuffer.setXYZ(e,i.size.x*Math.abs(a.x),i.size.y*Math.abs(a.y),i.size.z*Math.abs(a.z)),this.uvTileBuffer.setX(e,i.uvTile),this.settings.renderMode===ge.StretchedBillBoard&&this.velocityBuffer){let t=n.rendererEmitterSettings.speedFactor;0===t&&(t=.001);const r=n.rendererEmitterSettings.lengthFactor;let s;n.worldSpace?s=i.velocity:(s=this.vector_,i.parentMatrix?(this.rotationMat2_.setFromMatrix4(i.parentMatrix),s.copy(i.velocity).applyMatrix3(this.rotationMat2_)):s.copy(i.velocity).applyMatrix3(this.rotationMat_)),this.velocityBuffer.setXYZW(e,s.x*t,s.y*t,s.z*t,r)}}}this.geometry.instanceCount=e,e>0&&(this.offsetBuffer.clearUpdateRanges(),this.offsetBuffer.addUpdateRange(0,3*e),this.offsetBuffer.needsUpdate=!0,this.sizeBuffer.clearUpdateRanges(),this.sizeBuffer.addUpdateRange(0,3*e),this.sizeBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.uvTileBuffer.clearUpdateRanges(),this.uvTileBuffer.addUpdateRange(0,e),this.uvTileBuffer.needsUpdate=!0,this.settings.renderMode===ge.StretchedBillBoard&&this.velocityBuffer&&(this.velocityBuffer.clearUpdateRanges(),this.velocityBuffer.addUpdateRange(0,4*e),this.velocityBuffer.needsUpdate=!0),this.settings.renderMode===ge.Mesh?(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,4*e),this.rotationBuffer.needsUpdate=!0):this.settings.renderMode!==ge.StretchedBillBoard&&this.settings.renderMode!==ge.HorizontalBillBoard&&this.settings.renderMode!==ge.VerticalBillBoard&&this.settings.renderMode!==ge.BillBoard||(this.rotationBuffer.clearUpdateRanges(),this.rotationBuffer.addUpdateRange(0,e),this.rotationBuffer.needsUpdate=!0))}dispose(){this.geometry.dispose()}}class Oe extends ye{constructor(e){super(e),this.vector_=new Q,this.vector2_=new Q,this.vector3_=new Q,this.quaternion_=new ne,this.maxParticles=1e4,this.setupBuffers(),this.rebuildMaterial()}setupBuffers(){this.geometry&&this.geometry.dispose(),this.geometry=new H,this.indexBuffer=new G(new Uint32Array(6*this.maxParticles),1),this.indexBuffer.setUsage(D),this.geometry.setIndex(this.indexBuffer),this.positionBuffer=new G(new Float32Array(6*this.maxParticles),3),this.positionBuffer.setUsage(D),this.geometry.setAttribute("position",this.positionBuffer),this.previousBuffer=new G(new Float32Array(6*this.maxParticles),3),this.previousBuffer.setUsage(D),this.geometry.setAttribute("previous",this.previousBuffer),this.nextBuffer=new G(new Float32Array(6*this.maxParticles),3),this.nextBuffer.setUsage(D),this.geometry.setAttribute("next",this.nextBuffer),this.widthBuffer=new G(new Float32Array(2*this.maxParticles),1),this.widthBuffer.setUsage(D),this.geometry.setAttribute("width",this.widthBuffer),this.sideBuffer=new G(new Float32Array(2*this.maxParticles),1),this.sideBuffer.setUsage(D),this.geometry.setAttribute("side",this.sideBuffer),this.uvBuffer=new G(new Float32Array(4*this.maxParticles),2),this.uvBuffer.setUsage(D),this.geometry.setAttribute("uv",this.uvBuffer),this.colorBuffer=new G(new Float32Array(8*this.maxParticles),4),this.colorBuffer.setUsage(D),this.geometry.setAttribute("color",this.colorBuffer)}expandBuffers(e){for(;e>=this.maxParticles;)this.maxParticles*=2;this.setupBuffers()}rebuildMaterial(){this.layers.mask=this.settings.layers.mask;const e={lineWidth:{value:1},map:{value:null},useMap:{value:0},alphaMap:{value:null},useAlphaMap:{value:0},resolution:{value:new fe(1,1)},sizeAttenuation:{value:1},visibility:{value:1},alphaTest:{value:0}},t={USE_UV:"",USE_COLOR_ALPHA:""};if(this.settings.material.map&&(t.USE_MAP="",t.MAP_UV=we(this.settings.material.map.channel),e.map=new V(this.settings.material.map),e.mapTransform=new V((new $).copy(this.settings.material.map.matrix))),this.settings.material.defines&&void 0!==this.settings.material.defines.USE_COLOR_AS_ALPHA&&(t.USE_COLOR_AS_ALPHA=""),this.settings.renderMode!==ge.Trail)throw new Error("render mode unavailable");this.material=new k({uniforms:e,defines:t,vertexShader:"\n#include <common>\n#include <tile_pars_vertex>\n#include <color_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <fog_pars_vertex>\n\nattribute vec3 previous;\nattribute vec3 next;\nattribute float side;\nattribute float width;\n\nuniform vec2 resolution;\nuniform float lineWidth;\nuniform float sizeAttenuation;\n    \nvec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n    \nvoid main() {\n\n    #include <tile_vertex>\n    \n    float aspect = resolution.x / resolution.y;\n\n    vColor = color;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4( position, 1.0 );\n    vec4 prevPos = m * vec4( previous, 1.0 );\n    vec4 nextPos = m * vec4( next, 1.0 );\n\n    vec2 currentP = fix( finalPosition, aspect );\n    vec2 prevP = fix( prevPos, aspect );\n    vec2 nextP = fix( nextPos, aspect );\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\n    else {\n        vec2 dir1 = normalize( currentP - prevP );\n        vec2 dir2 = normalize( nextP - currentP );\n        dir = normalize( dir1 + dir2 );\n\n        vec2 perp = vec2( -dir1.y, dir1.x );\n        vec2 miter = vec2( -dir.y, dir.x );\n        //w = clamp( w / dot( miter, perp ), 0., 4., * lineWidth * width );\n\n    }\n\n    //vec2 normal = ( cross( vec3( dir, 0. ) vec3( 0., 0., 1. ) ) ).xy;\n    vec4 normal = vec4( -dir.y, dir.x, 0., 1. );\n    normal.xy *= .5 * w;\n    normal *= projectionMatrix;\n    if( sizeAttenuation == 0. ) {\n        normal.xy *= finalPosition.w;\n        normal.xy /= ( vec4( resolution, 0., 1. ) * projectionMatrix ).xy;\n    }\n\n    finalPosition.xy += normal.xy * side;\n\n    gl_Position = finalPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    \n\t#include <fog_vertex>\n}",fragmentShader:"\n\n#include <common>\n#include <tile_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nuniform sampler2D alphaMap;\nuniform float useAlphaMap;\nuniform float visibility;\nuniform float alphaTest;\n\nvarying vec4 vColor;\n    \nvoid main() {\n    #include <clipping_planes_fragment>\n    #include <logdepthbuf_fragment>\n\n    vec4 diffuseColor = vColor;\n    \n    #ifdef USE_MAP\n    #include <tile_fragment>\n    #ifndef USE_COLOR_AS_ALPHA\n    #endif\n    #endif\n    if( useAlphaMap == 1. ) diffuseColor.a *= texture2D( alphaMap, vUv).a;\n    if( diffuseColor.a < alphaTest ) discard;\n    gl_FragColor = diffuseColor;\n\n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n}",transparent:this.settings.material.transparent,depthWrite:!this.settings.material.transparent,side:this.settings.material.side,blending:this.settings.material.blending||N,blendDst:this.settings.material.blendDst,blendSrc:this.settings.material.blendSrc,blendEquation:this.settings.material.blendEquation,premultipliedAlpha:this.settings.material.premultipliedAlpha})}update(){let e=0,t=0,i=0;const n=this.getVisibleSystems();for(const r of n)for(let e=0;e<r.particleNum;e++)i+=2*r.particles[e].previous.length;i>this.maxParticles&&this.expandBuffers(i);for(const r of n){r.emitter.updateMatrixWorld&&(r.emitter.updateWorldMatrix(!0,!1),r.emitter.updateMatrixWorld(!0));const i=this.quaternion_,n=this.vector2_,s=this.vector3_;r.emitter.matrixWorld.decompose(n,i,s);const a=r.particles,o=r.particleNum,l=this.settings.uTileCount,d=this.settings.vTileCount,m=1/l,f=1/d;for(let c=0;c<o;c++){const i=a[c],n=i.uvTile%d,o=Math.floor(i.uvTile/d+.001),l=i.previous.values();let h,p=l.next(),u=p.value,v=u;p.done||(p=l.next()),h=void 0!==p.value?p.value:v;for(let a=0;a<i.previous.length;a++,e+=2){if(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z),r.worldSpace?(this.positionBuffer.setXYZ(e,v.position.x,v.position.y,v.position.z),this.positionBuffer.setXYZ(e+1,v.position.x,v.position.y,v.position.z)):(i.parentMatrix?this.vector_.copy(v.position).applyMatrix4(i.parentMatrix):this.vector_.copy(v.position).applyMatrix4(r.emitter.matrixWorld),this.positionBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.positionBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),r.worldSpace?(this.previousBuffer.setXYZ(e,u.position.x,u.position.y,u.position.z),this.previousBuffer.setXYZ(e+1,u.position.x,u.position.y,u.position.z)):(i.parentMatrix?this.vector_.copy(u.position).applyMatrix4(i.parentMatrix):this.vector_.copy(u.position).applyMatrix4(r.emitter.matrixWorld),this.previousBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.previousBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),r.worldSpace?(this.nextBuffer.setXYZ(e,h.position.x,h.position.y,h.position.z),this.nextBuffer.setXYZ(e+1,h.position.x,h.position.y,h.position.z)):(i.parentMatrix?this.vector_.copy(h.position).applyMatrix4(i.parentMatrix):this.vector_.copy(h.position).applyMatrix4(r.emitter.matrixWorld),this.nextBuffer.setXYZ(e,this.vector_.x,this.vector_.y,this.vector_.z),this.nextBuffer.setXYZ(e+1,this.vector_.x,this.vector_.y,this.vector_.z)),this.sideBuffer.setX(e,1),this.sideBuffer.setX(e+1,-1),r.worldSpace)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else if(i.parentMatrix)this.widthBuffer.setX(e,v.size),this.widthBuffer.setX(e+1,v.size);else{const t=(Math.abs(s.x)+Math.abs(s.y)+Math.abs(s.z))/3;this.widthBuffer.setX(e,v.size*t),this.widthBuffer.setX(e+1,v.size*t)}this.uvBuffer.setXY(e,(a/i.previous.length+n)*m,(d-o-1)*f),this.uvBuffer.setXY(e+1,(a/i.previous.length+n)*m,(d-o)*f),this.colorBuffer.setXYZW(e,v.color.x,v.color.y,v.color.z,v.color.w),this.colorBuffer.setXYZW(e+1,v.color.x,v.color.y,v.color.z,v.color.w),a+1<i.previous.length&&(this.indexBuffer.setX(3*t,e),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+2),t++,this.indexBuffer.setX(3*t,e+2),this.indexBuffer.setX(3*t+1,e+1),this.indexBuffer.setX(3*t+2,e+3),t++),u=v,v=h,p.done||(p=l.next(),void 0!==p.value&&(h=p.value))}}}this.positionBuffer.clearUpdateRanges(),this.positionBuffer.addUpdateRange(0,3*e),this.positionBuffer.needsUpdate=!0,this.previousBuffer.clearUpdateRanges(),this.previousBuffer.addUpdateRange(0,3*e),this.previousBuffer.needsUpdate=!0,this.nextBuffer.clearUpdateRanges(),this.nextBuffer.addUpdateRange(0,3*e),this.nextBuffer.needsUpdate=!0,this.sideBuffer.clearUpdateRanges(),this.sideBuffer.addUpdateRange(0,e),this.sideBuffer.needsUpdate=!0,this.widthBuffer.clearUpdateRanges(),this.widthBuffer.addUpdateRange(0,e),this.widthBuffer.needsUpdate=!0,this.uvBuffer.clearUpdateRanges(),this.uvBuffer.addUpdateRange(0,2*e),this.uvBuffer.needsUpdate=!0,this.colorBuffer.clearUpdateRanges(),this.colorBuffer.addUpdateRange(0,4*e),this.colorBuffer.needsUpdate=!0,this.indexBuffer.clearUpdateRanges(),this.indexBuffer.addUpdateRange(0,3*t),this.indexBuffer.needsUpdate=!0,this.geometry.setDrawRange(0,3*t)}dispose(){this.geometry.dispose()}}class Re extends t{constructor(){super(),this.batches=[],this.systemToBatchIndex=new Map,this.type="BatchedRenderer",this.depthTexture=null}static equals(e,t){return e.material.side===t.material.side&&e.material.blending===t.material.blending&&e.material.blendSrc===t.material.blendSrc&&e.material.blendDst===t.material.blendDst&&e.material.blendEquation===t.material.blendEquation&&e.material.premultipliedAlpha===t.material.premultipliedAlpha&&e.material.transparent===t.material.transparent&&e.material.depthTest===t.material.depthTest&&e.material.type===t.material.type&&e.material.alphaTest===t.material.alphaTest&&e.material.map===t.material.map&&e.renderMode===t.renderMode&&e.blendTiles===t.blendTiles&&e.softParticles===t.softParticles&&e.softFarFade===t.softFarFade&&e.softNearFade===t.softNearFade&&e.uTileCount===t.uTileCount&&e.vTileCount===t.vTileCount&&e.instancingGeometry===t.instancingGeometry&&e.renderOrder===t.renderOrder&&e.layers.mask===t.layers.mask}addSystem(e){e._renderer=this;const t=e.getRendererSettings();for(let n=0;n<this.batches.length;n++)if(Re.equals(this.batches[n].settings,t))return this.batches[n].addSystem(e),void this.systemToBatchIndex.set(e,n);let i;switch(t.renderMode){case ge.Trail:i=new Oe(t);break;case ge.Mesh:case ge.BillBoard:case ge.VerticalBillBoard:case ge.HorizontalBillBoard:case ge.StretchedBillBoard:i=new Ce(t)}this.depthTexture&&i.applyDepthTexture(this.depthTexture),i.addSystem(e),this.batches.push(i),this.systemToBatchIndex.set(e,this.batches.length-1),this.add(i)}deleteSystem(e){const t=this.systemToBatchIndex.get(e);null!=t&&(this.batches[t].removeSystem(e),this.systemToBatchIndex.delete(e))}setDepthTexture(e){this.depthTexture=e;for(const t of this.batches)t.applyDepthTexture(e)}updateSystem(e){this.deleteSystem(e),this.addSystem(e)}update(e){this.systemToBatchIndex.forEach((t,i)=>{i.update(e)});for(let t=0;t<this.batches.length;t++)this.batches[t].update()}}class Ne extends n{constructor(){super(),this.type="QuarksPrefab",this.animationData=[],this.isPlaying=!1,this.currentTime=-1e-5,this.timeScale=1,this.duration=0,this._mixers=new Map,this._tempAnimationJSON=[],this._clock=new z(!0)}registerBatchedRenderer(e){this._batchedRenderer=e}getOrCreateMixer(e){if(!this._mixers.has(e)){const t=new I(e);this._mixers.set(e,t)}return this._mixers.get(e)}addThreeAnimation(e,t,i=0,n=t.duration,r=!1){const s=this.getOrCreateMixer(e),a=s.clipAction(t);r||(a.setLoop(L,1),a.clampWhenFinished=!0);const o={startTime:i,duration:n,type:"three",loop:r,target:e,clip:t,mixer:s,action:a};return this.animationData.push(o),this.updateDuration(),o}addParticleSystemAnimation(e,t=0,i=0,n=!1){i<=0&&(i=e.system.duration);const r={startTime:t,duration:i,type:"ps",loop:n,target:e};return this.animationData.push(r),this.pause(),this.updateDuration(),r}removeAnimation(e){this.animationData.splice(e,1),this.updateDuration()}play(){this.isPlaying||(this.isPlaying=!0)}pause(){this.isPlaying&&(this.isPlaying=!1,this.animationData.forEach(e=>{e.target&&("ps"!==e.type||e.target.system.paused?"three"===e.type&&e.action&&e.action.isRunning()&&(e.action.paused=!0):e.target.system.pause())}))}stop(){this.pause(),this.currentTime=-1e-5,this.animationData.forEach(e=>{"ps"===e.type&&e.target?e.target.system.stop():"three"===e.type&&e.mixer&&e.action&&e.action.reset()})}update(e){if(!this.isPlaying)return;const t=void 0!==e?e:this._clock.getDelta();this.currentTime+=t*this.timeScale,this.currentTime>this.duration&&this.stop();const i=new Set;this.animationData.forEach(e=>{const{startTime:n,duration:r,type:s,loop:a,target:o,action:l,mixer:d}=e,m=n+r,f=this.currentTime>=n,c=this.currentTime>m,h=Math.abs(this.currentTime-n)<t;"three"===s&&l&&d?f&&!c?(h?(l.reset(),l.play()):l.paused&&(l.paused=!1,l.play()),this.currentTime,i.add(d)):c&&(l.paused=!0):"ps"===s&&o&&(f&&!c?h&&e.target.system.restart():c&&e.target.system.endEmit())}),i.forEach(e=>{e.update(t)})}setTime(e){const t=this.currentTime;this.currentTime=e,this.animationData.forEach(i=>{const{startTime:n,duration:r,type:s,target:a,action:o,mixer:l}=i;if("three"===s&&o&&l){if(o.reset(),e>=n&&e<n+r){const t=e-n;o.time=t,o.play(),l.update(0),o.paused=!this.isPlaying}}else"ps"===s&&a&&(e>=n&&e<n+r?(t<n||t>=n+r)&&a.system.restart():a.system.endEmit())})}getDuration(){return this.duration}updateDuration(){let e=0;this.animationData.forEach(t=>{const i=t.startTime+t.duration;i>e&&(e=i)}),this.duration=e}resolveReferences(e){this._tempAnimationJSON.forEach(t=>{let i;if(e.traverse(e=>{e.uuid===t.targetUUID&&(i=e)}),i)if("three"===t.type&&t.clipUUID){let e;i.animations&&(e=i.animations.find(e=>e.uuid===t.clipUUID)),e&&this.addThreeAnimation(i,e,t.startTime,t.duration,t.loop)}else"ps"===t.type&&this.addParticleSystemAnimation(i,t.startTime,t.duration,t.loop)}),this.updateDuration(),this._tempAnimationJSON=[]}toJSON(){const e=super.toJSON();return e.object.animationData=this.animationData.map(e=>({startTime:e.startTime,duration:e.duration,type:e.type,targetUUID:e.target.uuid,clipUUID:e.clip?.uuid,loop:e.loop})),e}static fromJSON(e){const t=new Ne;return e.animationData&&(t._tempAnimationJSON=e.animationData),t}}class ze extends e{constructor(e){super(e)}linkReference(e){const t={};e.traverse(function(e){t[e.uuid]=e}),e.traverse(function(e){if("ParticleEmitter"===e.type){const i=e.system;i.emitterShape;for(let e=0;e<i.behaviors.length;e++)i.behaviors[e]instanceof q&&(i.behaviors[e].subParticleSystem=t[i.behaviors[e].subParticleSystem])}})}parse(e,t){const i=super.parse(e,t);return this.linkReference(i),i}parseObject(e,B,C,O,R){let N,z,I;function L(e){return void 0===B[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),B[e]}function D(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let i=0,n=e.length;i<n;i++){const n=e[i];void 0===C[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),t.push(C[n])}return t}return void 0===C[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),C[e]}}function F(e){return void 0===O[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e),O[e]}const V={textures:O,geometries:B,materials:C},k={};switch(e.type){case"QuarksPrefab":N=Ne.fromJSON(e);break;case"ParticleEmitter":N=Ee.fromJSON(e.ps,V,k).emitter;break;case"Scene":N=new A,void 0!==e.background&&(Number.isInteger(e.background)?N.background=new P(e.background):N.background=F(e.background)),void 0!==e.environment&&(N.environment=F(e.environment)),void 0!==e.fog&&("Fog"===e.fog.type?N.fog=new w(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(N.fog=new b(e.fog.color,e.fog.density)),""!==e.fog.name&&(N.fog.name=e.fog.name)),void 0!==e.backgroundBlurriness&&(N.backgroundBlurriness=e.backgroundBlurriness),void 0!==e.backgroundIntensity&&(N.backgroundIntensity=e.backgroundIntensity),void 0!==e.backgroundRotation&&N.backgroundRotation.fromArray(e.backgroundRotation),void 0!==e.environmentIntensity&&(N.environmentIntensity=e.environmentIntensity),void 0!==e.environmentRotation&&N.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":N=new U(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(N.focus=e.focus),void 0!==e.zoom&&(N.zoom=e.zoom),void 0!==e.filmGauge&&(N.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(N.filmOffset=e.filmOffset),void 0!==e.view&&(N.view=Object.assign({},e.view));break;case"OrthographicCamera":N=new E(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(N.zoom=e.zoom),void 0!==e.view&&(N.view=Object.assign({},e.view));break;case"AmbientLight":N=new T(e.color,e.intensity);break;case"DirectionalLight":N=new M(e.color,e.intensity);break;case"PointLight":N=new x(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":N=new S(e.color,e.intensity,e.width,e.height);break;case"SpotLight":N=new _(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":N=new y(e.color,e.groundColor,e.intensity);break;case"LightProbe":N=(new g).fromJSON(e);break;case"SkinnedMesh":z=L(e.geometry),I=D(e.material),N=new v(z,I),void 0!==e.bindMode&&(N.bindMode=e.bindMode),void 0!==e.bindMatrix&&N.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(N.skeleton=e.skeleton);break;case"Mesh":z=L(e.geometry),I=D(e.material),N=new u(z,I);break;case"InstancedMesh":{z=L(e.geometry),I=D(e.material);const t=e.count,i=e.instanceMatrix,n=e.instanceColor;N=new h(z,I,t),N.instanceMatrix=new p(new Float32Array(i.array),16),void 0!==n&&(N.instanceColor=new p(new Float32Array(n.array),n.itemSize));break}case"BatchedMesh":z=L(e.geometry),I=D(e.material),N=new m(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,I),N.geometry=z,N.perObjectFrustumCulled=e.perObjectFrustumCulled,N.sortObjects=e.sortObjects,N._drawRanges=e.drawRanges,N._reservedRanges=e.reservedRanges,N._visibility=e.visibility,N._active=e.active,N._bounds=e.bounds.map(e=>{const t=new f;t.min.fromArray(e.boxMin),t.max.fromArray(e.boxMax);const i=new c;return i.radius=e.sphereRadius,i.center.fromArray(e.sphereCenter),{boxInitialized:e.boxInitialized,box:t,sphereInitialized:e.sphereInitialized,sphere:i}}),N._maxGeometryCount=e.maxGeometryCount,N._maxVertexCount=e.maxVertexCount,N._maxIndexCount=e.maxIndexCount,N._geometryInitialized=e.geometryInitialized,N._geometryCount=e.geometryCount,N._matricesTexture=F(e.matricesTexture.uuid);break;case"LOD":N=new d;break;case"Line":N=new l(L(e.geometry),D(e.material));break;case"LineLoop":N=new o(L(e.geometry),D(e.material));break;case"LineSegments":N=new a(L(e.geometry),D(e.material));break;case"PointCloud":case"Points":N=new s(L(e.geometry),D(e.material));break;case"Sprite":N=new r(D(e.material));break;case"Group":N=new n;break;case"Bone":N=new i;break;default:N=new t}if(N.uuid=e.uuid,void 0!==e.name&&(N.name=e.name),void 0!==e.matrix?(N.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(N.matrixAutoUpdate=e.matrixAutoUpdate),N.matrixAutoUpdate&&(N.matrix.decompose(N.position,N.quaternion,N.scale),isNaN(N.quaternion.x)&&N.quaternion.set(0,0,0,1))):(void 0!==e.position&&N.position.fromArray(e.position),void 0!==e.rotation&&N.rotation.fromArray(e.rotation),void 0!==e.quaternion&&N.quaternion.fromArray(e.quaternion),void 0!==e.scale&&N.scale.fromArray(e.scale)),void 0!==e.up&&N.up.fromArray(e.up),void 0!==e.castShadow&&(N.castShadow=e.castShadow),void 0!==e.receiveShadow&&(N.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(N.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(N.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(N.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&N.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(N.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(N.visible=e.visible),void 0!==e.frustumCulled&&(N.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(N.renderOrder=e.renderOrder),void 0!==e.userData&&(N.userData=e.userData),void 0!==e.layers&&(N.layers.mask=e.layers),void 0!==e.children){const t=e.children;for(let e=0;e<t.length;e++)N.add(this.parseObject(t[e],B,C,O,R))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const i=t[e];N.animations.push(R[i])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(N.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const i=t[e],n=N.getObjectByProperty("uuid",i.object);void 0!==n&&N.addLevel(n,i.distance)}}else"QuarksPrefab"===e.type&&N.resolveReferences(N);return N}}ue.tile_pars_vertex="\n#ifdef UV_TILE\n    attribute float uvTile;\n    uniform vec2 tileCount;\n    \n    mat3 makeTileTransform(float uvTile) {\n        float col = mod(uvTile, tileCount.x);\n        float row = (tileCount.y - floor(uvTile / tileCount.x) - 1.0);\n        \n        return mat3(\n          1.0 / tileCount.x, 0.0, 0.0,\n          0.0, 1.0 / tileCount.y, 0.0, \n          col / tileCount.x, row / tileCount.y, 1.0);\n    }\n#else\n    mat3 makeTileTransform(float uvTile) {\n        return mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",ue.tile_vertex="\n#ifdef UV_TILE\n    mat3 tileTransform = makeTileTransform(floor(uvTile));\n    #ifdef TILE_BLEND\n        mat3 nextTileTransform = makeTileTransform(ceil(uvTile));\n        vUvBlend = fract(uvTile);\n    #endif\n#else\n    mat3 tileTransform = makeTileTransform(0.0);\n#endif\n\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\nvUv = (tileTransform *vec3( uv, 1 )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vUvNext = (nextTileTransform *vec3( uv, 1 )).xy;\n#endif\n\n#endif\n#ifdef USE_MAP\n\nvMapUv = ( tileTransform * (mapTransform * vec3( MAP_UV, 1 ) )).xy;\n#if defined( TILE_BLEND ) && defined( UV_TILE )\n    vMapUvNext = (nextTileTransform * (mapTransform * vec3( MAP_UV, 1 ))).xy;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\nvAlphaMapUv = ( tileTransform * (alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) )).xy;\n    \n#endif\n#ifdef USE_LIGHTMAP\n\nvLightMapUv = ( tileTransform * (lightMapTransform * vec3( LIGHTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_AOMAP\n\nvAoMapUv = ( tileTransform * (aoMapTransform * vec3( AOMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_BUMPMAP\n\nvBumpMapUv = ( tileTransform * (bumpMapTransform * vec3( BUMPMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_NORMALMAP\n\nvNormalMapUv = ( tileTransform * (normalMapTransform * vec3( NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\nvDisplacementMapUv = ( tileTransform * (displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\nvEmissiveMapUv = ( tileTransform * (emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_METALNESSMAP\n\nvMetalnessMapUv = ( tileTransform * (metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\nvRoughnessMapUv = ( tileTransform * (roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\nvAnisotropyMapUv = ( tileTransform * (anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\nvClearcoatMapUv = ( tileTransform * (clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\nvClearcoatNormalMapUv = ( tileTransform * (clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\nvClearcoatRoughnessMapUv = ( tileTransform * (clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\nvIridescenceMapUv = ( tileTransform * (iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\nvIridescenceThicknessMapUv = ( tileTransform * (iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\nvSheenColorMapUv = ( tileTransform * (sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\nvSheenRoughnessMapUv = ( tileTransform * (sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULARMAP\n\nvSpecularMapUv = ( tileTransform * (specularMapTransform * vec3( SPECULARMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\nvSpecularColorMapUv = ( tileTransform * (specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\nvSpecularIntensityMapUv = ( tileTransform * (specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\nvTransmissionMapUv = ( tileTransform * transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) )).xy;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\nvThicknessMapUv = ( tileTransform * thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) )).xy;\n\n#endif\n\n",ue.tile_pars_fragment="\n#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\n\tvarying vec2 vUv;\n#ifdef TILE_BLEND\n    varying vec2 vUvNext;\n    varying float vUvBlend;\n#endif\n\n#endif\n#ifdef USE_MAP\n\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#ifdef TILE_BLEND\n    varying vec2 vMapUvNext;\n#endif\n\n#endif\n#ifdef USE_ALPHAMAP\n\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n\n#endif\n#ifdef USE_LIGHTMAP\n\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n\n#endif\n#ifdef USE_AOMAP\n\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n\n#endif\n#ifdef USE_BUMPMAP\n\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n\n#endif\n#ifdef USE_NORMALMAP\n\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n\n#endif\n#ifdef USE_EMISSIVEMAP\n\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n\n#endif\n#ifdef USE_METALNESSMAP\n\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n\n#endif\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n\n#endif\n#ifdef USE_ANISOTROPYMAP\n\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n\n#endif\n#ifdef USE_CLEARCOATMAP\n\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n\n#endif\n#ifdef USE_SPECULARMAP\n\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n\n#endif\n#ifdef USE_THICKNESSMAP\n\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n\n#endif\n",ue.tile_fragment="\n#ifdef USE_MAP\n    vec4 texelColor = texture2D( map, vUv);\n    #ifdef TILE_BLEND\n        texelColor = mix( texelColor, texture2D( map, vUvNext ), vUvBlend );\n    #endif\n    diffuseColor *= texelColor;\n#endif\n",ue.soft_pars_vertex="\n#ifdef SOFT_PARTICLES\n    varying vec4 projPosition;\n    varying float linearDepth;\n#endif\n",ue.soft_vertex="\n#ifdef SOFT_PARTICLES\n    projPosition = gl_Position;\n    linearDepth = -mvPosition.z;\n#endif\n",ue.soft_pars_fragment="\n#ifdef SOFT_PARTICLES\n\n    uniform sampler2D depthTexture;\n    uniform vec4 projParams;\n    uniform vec2 softParams;\n\n    varying vec4 projPosition;\n    varying float linearDepth;\n\n    #define SOFT_NEAR_FADE softParams.x\n    #define SOFT_INV_FADE_DISTANCE softParams.y\n\n    #define zNear projParams.x\n    #define zFar projParams.y\n\n    float linearize_depth(float d)\n    {\n        return (zFar * zNear) / (zFar - d * (zFar - zNear));\n    }\n\n#endif\n",ue.soft_fragment="\n#ifdef SOFT_PARTICLES\n\n    /* #ifdef LOGDEPTH\n    float distSample = linearize_depth_log(sampleDepth, near, far);\n    #else\n    float distSample = ortho ? linearize_depth_ortho(sampleDepth, near, far) : linearize_depth(sampleDepth, near, far);\n    #endif */\n\n    vec2 p2 = projPosition.xy / projPosition.w;\n    \n    p2 = 0.5 * p2 + 0.5;\n\n    float readDepth = texture2D(depthTexture, p2.xy).r;\n    float viewDepth = linearize_depth(readDepth);\n\n    float softParticlesFade = saturate(SOFT_INV_FADE_DISTANCE * ((viewDepth - SOFT_NEAR_FADE) - linearDepth));\n    \n    gl_FragColor *= softParticlesFade;\n\n    //gl_FragColor = vec4(softParticlesFade , 0, 0, 1);\n#endif\n",ce(pe),console.log("%c Particle system powered by three.quarks. https://quarks.art/","font-size: 14px; font-weight: bold;");export{Re as B,Ee as P,ze as Q,ge as R};
