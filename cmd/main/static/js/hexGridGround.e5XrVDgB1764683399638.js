import{n as e,_ as i,o as a,K as n}from"./@tresjs.CJvYCGUA1764683399638.js";import{P as r}from"./tweakpane.CqZAnw7f1764683399638.js";import{_ as s}from"./reflectorDUDV.vue_vue_type_script_setup_true_lang.u89pth7i1764683399638.js";import{d as o,w as t,e as d,o as l,u,G as m,I as v,h as c,m as f,r as p,b as g,f as h}from"./@vue.DjQnunkc1764683399638.js";import{y as x,a6 as w}from"./three.BbguFgn81764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./dither.glsl.tNAdkJUa1764683399638.js";import"./Reflector.DiEbG3XV1764683399638.js";import"./index.DM693cYN1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";const j=o({__name:"hexGridMaterial",props:{baseMaterial:{default:x},speed:{default:1},gridWeight:{default:.03},raisedBottom:{default:.05},waveFrequency:{default:.2},wavePow:{default:4},division:{default:32},divisionScaleX:{default:1},direction:{default:4},isReversed:{default:!1},hasMaskTexture:{default:!1},maskTexture:{default:""}},setup(n){const r=n,s={gridWeight:{value:r.gridWeight},raisedBottom:{value:r.raisedBottom},waveFrequency:{value:r.waveFrequency},wavePow:{value:r.wavePow},direction:{value:r.direction},isReversed:{value:r.isReversed},hasMaskTexture:{value:r.hasMaskTexture},maskTexture:{value:null},division:{value:r.division},divisionScaleX:{value:r.divisionScaleX},time:{value:0}};if(r.maskTexture){const{state:i}=e(r.maskTexture);s.maskTexture=i}t(()=>[r.gridWeight,r.raisedBottom,r.waveFrequency,r.wavePow,r.division,r.divisionScaleX,r.direction,r.isReversed,r.hasMaskTexture],([e,i,a,n,r,o,t,d,l])=>{s.gridWeight.value=e,s.raisedBottom.value=i,s.waveFrequency.value=a,s.wavePow.value=n,s.division.value=r,s.divisionScaleX.value=o,s.direction.value=t,s.isReversed.value=d,s.hasMaskTexture.value=l});const{onBeforeRender:o}=i();return o(({delta:e})=>{s.time.value+=e*r.speed}),(e,i)=>(l(),d(u(a),{baseMaterial:n.baseMaterial,vertexShader:"\nvarying vec2 uvPosition;\nvoid main() {\n    uvPosition = uv;\n}\n",side:w,transparent:"",fragmentShader:u("varying vec2 uvPosition;\n\nuniform float time;\n\nuniform float raisedBottom;\r\nuniform float waveFrequency;\r\nuniform float wavePow;\r\nuniform int direction;\n\nuniform float division;\r\nuniform float divisionScaleX;\n\nuniform bool hasMaskTexture;\r\nuniform sampler2D maskTexture;\n\nuniform bool isReversed;\n\nuniform float gridWeight;\n\nfloat hexDist(vec2 p) {\r\n  p = abs(p);\r\n  float d = dot(p, normalize(vec2(1.0, 1.73)));\r\n  return max(d, p.x);\r\n}\r\nvec4 hexCoords(vec2 uv) {\r\n  vec2 r = vec2(1.0, 1.73);\r\n  vec2 h = r * 0.5;\r\n  vec2 a = mod(uv, r) - h;\r\n  vec2 b = mod(uv - h, r) - h;\n\n  vec2 gv = length(a) < length(b) ? a : b;\r\n  vec2 id = uv - gv;\n\n  float x = atan(gv.x, gv.y);\r\n  float y = 0.5 - hexDist(gv);\n\n  return vec4(x, y, id);\r\n}\n\nvoid main() {\r\n  vec2 uv = uvPosition * vec2(division * divisionScaleX, division);\r\n  vec4 hc = hexCoords(uv);\r\n  vec2 id = hc.zw;\r\n  float distance = id.y;\r\n  if (direction == 3) {\r\n    distance = id.x;\r\n  } else if (direction == 5) {\r\n    distance = length(id.xy);\r\n  } else if (direction == 6) {\r\n    vec2 center = vec2(0.5 * division * divisionScaleX, 0.5 * division);\r\n    distance = length(uv - center);\r\n  }\r\n  float wavy =\r\n      pow(sin((distance * waveFrequency - time)), wavePow) + raisedBottom;\n\n  float diffuseColorA = csm_DiffuseColor.a;\r\n  diffuseColorA *= wavy;\n\n  float mask = 1.0;\r\n  if (hasMaskTexture) {\r\n    vec2 uVm = id / vec2(division * divisionScaleX, division);\r\n    mask = texture2D(maskTexture, uVm).g;\r\n  }\n\n  float w = gridWeight + (1.0 - mask);\r\n  w = clamp(w, 0.0, 1.0);\n\n  float margin = clamp(w * 0.33, 0.00, 0.02);\r\n  float stepMax = w + margin;\n\n  float gridLine = smoothstep(w, stepMax, hc.y);\r\n  gridLine = isReversed ? 1.0 - gridLine : gridLine;\r\n  diffuseColorA *= gridLine;\n\n  \n  \n  csm_DiffuseColor.rgb *= diffuseColorA;\n\nfloat brightness = length(csm_DiffuseColor.rgb);\n\nfloat alphaBlend = smoothstep(0.0, 1.0, brightness);\n\ncsm_DiffuseColor.a *= alphaBlend;\n\ncsm_FragColor = vec4(csm_DiffuseColor.rgb, csm_DiffuseColor.a);\r\n}"),uniforms:s},null,8,["baseMaterial","side","fragmentShader"]))}}),b=["rotation"],y=o({__name:"hexGridMesh",setup(e){const i=x;return(e,a)=>(l(),m("TresMesh",{rotation:[-Math.PI/2,0,0]},[a[0]||(a[0]=v("TresPlaneGeometry",{args:[1,1]},null,-1)),c(j,f({baseMaterial:u(i)},e.$attrs,{maskTexture:"./plugins/floor/image/logoBlack.png"}),null,16,["baseMaterial"])],8,b))}}),k=o({__name:"hexGridGround",setup(e){const i=p({reflectivity:.8,showGridHelper:!1,scale:1}),a=p({color:"#de62f2",speed:1.9,gridWeight:.223,raisedBottom:.66,waveFrequency:.066,wavePow:19,division:46,divisionScaleX:1,isReversed:!1,direction:4,hasMaskTexture:!0}),o=new r({title:"hexGridGround",expanded:!0});return o.addBinding(a,"hasMaskTexture",{label:"图片纹理"}),o.addBinding(a,"color",{label:"颜色"}),o.addBinding(a,"speed",{label:"速度",min:-5,max:5,step:.1}),o.addBinding(a,"gridWeight",{label:"网格宽度",min:.001,max:.5,step:.001}),o.addBinding(a,"raisedBottom",{label:"渐变宽度",min:.001,max:1,step:.001}),o.addBinding(a,"waveFrequency",{label:"分段",min:.001,max:1,step:.001}),o.addBinding(a,"wavePow",{label:"渐变强度",min:1,max:30,step:.1}),o.addBinding(a,"division",{label:"网格整体缩放",min:.1,max:50,step:.1}),o.addBinding(a,"divisionScaleX",{label:"网格横向缩放",min:.1,max:10,step:.1}),o.addBinding(a,"isReversed",{label:"颜色取反"}),o.addBinding(a,"direction",{label:"方向类别",min:3,max:6,step:1}),(e,r)=>{const o=g("TresCanvas");return l(),d(o,{clearColor:"#666666","window-size":""},{default:h(()=>[r[0]||(r[0]=v("TresPerspectiveCamera",{position:[3,3,0],fov:45,near:.1,far:1e4},null,-1)),c(u(n),{enableDamping:"",autoRotate:""}),c(y,f(a,{scale:9}),null,16),c(s,f({position:[0,-.06,0]},i),null,16)]),_:1})}}});export{k as default};
