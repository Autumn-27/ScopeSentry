import{k as n,a6 as r,a0 as e}from"./three.BbguFgn81764683399638.js";import{K as o,t as s}from"./@tresjs.CJvYCGUA1764683399638.js";import{P as i}from"./tweakpane.CqZAnw7f1764683399638.js";import{d as a,a3 as t,G as l,o as d,I as u,a9 as v,aa as c,r as g,b as f,e as h,f as m,h as C,u as p,ah as T,m as x}from"./@vue.DjQnunkc1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";const W=["rotate-x"],k=a({__name:"gridFloor",props:{gridColor:{default:"#c4d6ff"},gridThickness:{default:.02},crossColor:{default:"#7a91df"},crossThickness:{default:.02},uCross:{default:.2},floorColor:{default:"#ffffff"}},setup(e){const o=e,s={vertexShader:"varying vec2 vUv;\r\nvoid main()\r\n{\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    vUv = uv;\r\n}",fragmentShader:"uniform float uGridThickness;\r\nuniform vec3 uGridColor;\r\nuniform float uCrossScale;\r\nuniform float uCrossThickness;\r\nuniform float uCross;\r\nuniform vec3 uCrossColor;\r\nuniform vec3 uFloorColor;\n\nvarying vec2 vUv;\n\nfloat gridFloor(vec2 uv, vec2 lineWidth) {\r\n    \n    \n    \n    \n    \n    \n    \n    vec4 uvDDXY = vec4(dFdx(uv), dFdy(uv));\r\n    vec2 uvDeriv = vec2(length(uvDDXY.xz), length(uvDDXY.yw));\n\n    \n    \n    \n    bool invertLine = lineWidth.x > 0.5;\r\n    vec2 targetWidth = invertLine ? 1.0 - lineWidth : lineWidth;\n\n    \n    \n    \n    \n    \n    vec2 drawWidth = clamp(targetWidth, uvDeriv, vec2(0.5));\n\n    \n    \n    \n    vec2 lineAA = uvDeriv * 1.5;\r\n    \r\n    \n    \n    \n    \n    \n    vec2 gridUV = abs(fract(uv) * 2.0 - 1.0);\r\n    gridUV = invertLine ? gridUV : 1.0 - gridUV;\n\n    \n    \n    \n    vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n    \n    \n    \n    grid2 *= clamp(targetWidth / drawWidth, 0.0, 1.0);\n\n    \n    \n    \n    \n    \n    grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, 0.0, 1.0));\r\n    grid2 = invertLine ? 1.0 - grid2 : grid2;\n\n    \n    float grid = mix(grid2.x, 1.0, grid2.y);\n\n    return grid;\r\n}\n\nfloat crossFloor(vec2 uv, float scale, float thickness, float crossIntensity) {\r\n    vec2 lineWidth = vec2(thickness);\n\n    \n    \n    \n    \n    \n    \n    \n    vec4 uvDDXY = vec4(dFdx(uv), dFdy(uv));\r\n    vec2 uvDeriv = vec2(length(uvDDXY.xz), length(uvDDXY.yw));\n\n    \n    \n    \n    bool invertLine = lineWidth.x > 0.5;\r\n    \n    vec2 targetWidth = lineWidth;\n\n    \n    \n    \n    \n    \n    vec2 drawWidth = clamp(targetWidth, uvDeriv, vec2(0.5));\n\n    \n    \n    \n    vec2 lineAA = uvDeriv * 1.5;\r\n    \r\n    \n    float cutOffX = abs(fract(uv.y) * 2.0 - 1.0) > crossIntensity ? 1.0 : 0.0;\r\n    float cutOffY = abs(fract(uv.x) * 2.0 - 1.0) > crossIntensity ? 1.0 : 0.0;\n\n    \n    \n    \n    \n    \n    \n    \n    float uvX = abs(fract(uv.x) * 2.0 - 1.0) + cutOffX;\r\n    float uvY = abs(fract(uv.y) * 2.0 - 1.0) + cutOffY;\r\n    vec2 gridUV = vec2(uvX, uvY);\n\n    \n\n    \n    \n    \n    vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n    \n    \n    \n    grid2 *= clamp(targetWidth / drawWidth, 0.0, 1.0);\n\n    \n    \n    \n    \n    \n    grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, 0.0, 1.0));\r\n    \n\n    \n    float grid = mix(grid2.x, 1.0, grid2.y);\n\n    return grid;\r\n}\n\nvoid main()\r\n{\r\n    vec2 lineWidth = vec2(uGridThickness);\r\n    \n    vec2 uv = vUv * 20.0;\n\n    \n    float grid = gridFloor(uv, lineWidth);\r\n    \n    vec3 gridColor = mix(uFloorColor, uGridColor, vec3(grid));\n\n    \n    float crossUv = crossFloor(uv, uCrossScale, uCrossThickness, uCross);\r\n    \n    vec3 gridColor2 = mix(gridColor, uCrossColor, vec3(crossUv));\r\n    \r\n    vec3 color =  gridColor2;\n\n    gl_FragColor = vec4(color, 1.0);\r\n}",side:r,transparent:!0,uniforms:{uFloorColor:{value:new n(o.floorColor)},uGridThickness:{value:o.gridThickness},uGridColor:{value:new n(o.gridColor)},uCrossThickness:{value:o.crossThickness},uCross:{value:o.uCross},uCrossColor:{value:new n(o.crossColor)}}};return t(()=>{s.uniforms.uFloorColor.value.set(o.floorColor),s.uniforms.uGridColor.value.set(o.gridColor),s.uniforms.uCrossColor.value.set(o.crossColor),s.uniforms.uGridThickness.value=o.gridThickness,s.uniforms.uCrossThickness.value=o.crossThickness,s.uniforms.uCross.value=o.uCross}),(n,r)=>(d(),l("TresMesh",{"rotate-x":-Math.PI/2},[r[0]||(r[0]=u("TresPlaneGeometry",{args:[10,10,32,32]},null,-1)),u("TresShaderMaterial",v(c(s)),null,16)],8,W))}}),D=a({__name:"gridFloor",setup(n){const r=g({alpha:!0,toneMapping:e,windowSize:!0,clearColor:3355443}),a=g({enableDamping:!0,autoRotate:!1}),t=g({gridColor:"#ffffff",crossColor:"#ef57ff",floorColor:"#000000",gridThickness:.02,crossThickness:.03,uCross:.29}),l=new i;return l.addBinding(t,"gridColor",{label:"网格颜色"}),l.addBinding(t,"gridThickness",{label:"网格厚度",min:.01,max:1,step:.01}),l.addBinding(t,"crossColor",{label:"十字颜色"}),l.addBinding(t,"crossThickness",{label:"十字厚度",min:.01,max:1,step:.01}),l.addBinding(t,"uCross",{label:"十字大小",min:.01,max:1,step:.01}),l.addBinding(t,"floorColor",{label:"地板颜色"}),(n,e)=>{const i=f("TresCanvas");return d(),h(i,x(r,{"window-size":""}),{default:m(()=>[e[0]||(e[0]=u("TresPerspectiveCamera",{position:[6,6,6],fov:45,near:.1,far:1e3},null,-1)),C(p(o),v(c(a)),null,16),e[1]||(e[1]=u("TresAmbientLight",{intensity:.5},null,-1)),e[2]||(e[2]=u("TresDirectionalLight",{position:[15,15,15],intensity:1},null,-1)),e[3]||(e[3]=u("TresMesh",{position:[0,.5,0],scale:.2},[u("TresTorusKnotGeometry",{args:[1,.35,100,32]}),u("TresMeshStandardMaterial",{color:"#ff33ff",roughness:0,metalness:1})],-1)),C(k,v(c(t)),null,16),(d(),h(T,null,{default:m(()=>[C(p(s),{files:["pos-x.jpg","neg-x.jpg","pos-y.jpg","neg-y.jpg","pos-z.jpg","neg-z.jpg"],path:"https://opensource.cdn.icegl.cn/images/skyBox/6jpg/"},null,8,["path"])]),_:1}))]),_:1},16)}}});export{D as default};
