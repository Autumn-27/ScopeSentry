import{bJ as r,a6 as t}from"./three.BbguFgn81764683399638.js";import{d as n,b as e,e as a,o,f as s,I as c,a9 as v,aa as p,m as i}from"./@vue.DjQnunkc1764683399638.js";const d={ref:"perspectiveCameraRef",position:[0,0,1800],fov:45,near:1,far:1e4},m=["rotation-x"],l=n({__name:"superTunnel",setup(n){const l={clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0},f={uniforms:{uTime:{type:"f",value:0}},vertexShader:"varying vec2 vUv;\r\nvoid main(){\r\n\tvUv=uv;\r\n\tgl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\r\n}",fragmentShader:"varying vec2 vUv;\r\nuniform float uTime;\r\n\r\n#define PI 3.14159265\r\n#define FAR 60.\r\n\r\nmat2 rot2(float a){vec2 v=sin(vec2(1.570796,0)+a);return mat2(v,-v.y,v.x);}\r\n\r\nvec3 tex3D(sampler2D tex,in vec3 p,in vec3 n){\r\n\t\r\n\tn=max(abs(n),.001);\r\n\tn/=(n.x+n.y+n.z);\r\n\tp=(texture(tex,p.yz)*n.x+texture(tex,p.zx)*n.y+texture(tex,p.xy)*n.z).xyz;\r\n\treturn p*p;\r\n}\r\nvec2 path(in float z){\r\n\tfloat a=sin(z*.11);\r\n\tfloat b=cos(z*.14);\r\n\treturn vec2(a*4.-b*1.5,b*1.7+a*1.5);\r\n\t\r\n}\r\nvec3 palette(float t){\r\n\tvec3 a=vec3(.5,.5,.5);\r\n\tvec3 b=vec3(.5,.5,.5);\r\n\tvec3 c=vec3(1.,1.,1.);\r\n\tvec3 d=vec3(sin(uTime*.2)*.5+.5,cos(uTime*.25)*.5+.5,sin(uTime*.3+1.)*.5+.5);\r\n\t\r\n\treturn a+b*cos(6.28318*(c*t+d));\r\n}\r\nfloat map(vec3 p){\r\n\tp.xy-=path(p.z);\r\n\tfloat n=5.-length(p.xy*vec2(1,.8));\r\n\treturn min(p.y+3.,n);\r\n\t\r\n}\r\n\r\nconst float w2h=2.;\r\nconst float mortW=.05;\r\n\r\nfloat brickMorter(vec2 p){\r\n\t\r\n\tp.x-=step(1.,p.y)*.5;\r\n\t\r\n\tp=abs(fract(p+vec2(0,.5))-.5)*2.;\r\n\t\r\n\treturn smoothstep(0.,mortW,p.x)*smoothstep(0.,mortW*w2h,p.y);\r\n\t\r\n}\r\n\r\nfloat brick(vec2 p){\r\n\tp=fract(p*vec2(.5/w2h,.5))*2.;\r\n\treturn brickMorter(p);\r\n}\r\nfloat bumpSurf3D(in vec3 p,in vec3 n){\r\n\t\r\n\tn=abs(n);\r\n\t\r\n\tif(n.x>.5)p.xy=p.zy;\r\n\telse if(n.y>.5)p.xy=p.xz;\r\n\t\r\n\treturn brick(p.xy);\r\n\t\r\n}\r\n\r\nvec3 doBumpMap(in vec3 p,in vec3 nor,float bumpfactor){\r\n\t\r\n\tconst vec2 e=vec2(.001,0);\r\n\tfloat ref=bumpSurf3D(p,nor);\r\n\tvec3 grad=(vec3(bumpSurf3D(p-e.xyy,nor),\r\n\tbumpSurf3D(p-e.yxy,nor),\r\n\tbumpSurf3D(p-e.yyx,nor))-ref)/e.x;\r\n\t\r\n\tgrad-=nor*dot(nor,grad);\r\n\t\r\n\treturn normalize(nor+grad*bumpfactor);\r\n\t\r\n}\r\nvec3 doBumpMap(sampler2D tx,in vec3 p,in vec3 n,float bf){\r\n\tconst vec2 e=vec2(.001,0);\r\n\tmat3 m=mat3(tex3D(tx,p-e.xyy,n),tex3D(tx,p-e.yxy,n),tex3D(tx,p-e.yyx,n));\r\n\tvec3 g=vec3(.299,.587,.114)*m;\r\n\tg=(g-dot(tex3D(tx,p,n),vec3(.299,.587,.114)))/e.x;g-=n*dot(n,g);\r\n\t\r\n\treturn normalize(n+g*bf);\r\n\t\r\n}\r\n\r\nvec3 voxelTrace(vec3 ro,vec3 rd,out vec3 mask){\r\n\tvec3 p=floor(ro)+.5;\r\n\tvec3 dRd=1./abs(rd);\r\n\trd=sign(rd);\r\n\tvec3 side=dRd*(rd*(p-ro)+.5);\r\n\tmask=vec3(0);\r\n\tfor(int i=0;i<64;i++){\r\n\t\tif(map(p)<0.)break;\r\n\t\tmask=step(side,side.yzx)*(1.-step(side.zxy,side));\r\n\t\tside+=mask*dRd;\r\n\t\tp+=mask*rd;\r\n\t}\r\n\t\r\n\treturn p;\r\n}\r\n//光追核心参数\r\nfloat voxShadow(vec3 ro,vec3 rd,float end){\r\n\tfloat shade=1.;\r\n\tvec3 p=floor(ro)+.5;\r\n\tvec3 dRd=1./abs(rd);\r\n\trd=sign(rd);\r\n\tvec3 side=dRd*(rd*(p-ro)+.5);\r\n\tvec3 mask=vec3(0);\r\n\tfloat d=1.;\r\n\tfor(int i=0;i<16;i++){\r\n\t\td=map(p);\r\n\t\tif(d<0.||length(p-ro)>end)break;\r\n\t\tmask=step(side,side.yzx)*(1.-step(side.zxy,side));\r\n\t\tside+=mask*dRd;\r\n\t\tp+=mask*rd;\r\n\t}\r\n\t\r\n\treturn shade=step(0.,d)*.7+.3;\r\n\t\r\n}\r\n\r\nvec4 voxelAO(vec3 p,vec3 d1,vec3 d2){\r\n\tvec4 side=vec4(map(p+d1),map(p+d2),map(p-d1),map(p-d2));\r\n\tvec4 corner=vec4(map(p+d1+d2),map(p-d1+d2),map(p-d1-d2),map(p+d1-d2));\r\n\tside=step(side,vec4(0));\r\n\tcorner=step(corner,vec4(0));\r\n\treturn 1.-(side+side.yzwx+max(corner,side*side.yzwx))/3.;\r\n}\r\n//创建vAO\r\nfloat calcVoxAO(vec3 vp,vec3 sp,vec3 rd,vec3 mask){\r\n\tvec4 vAO=voxelAO(vp-sign(rd)*mask,mask.zxy,mask.yzx);\r\n\tsp=fract(sp);\r\n\tvec2 uv=sp.yz*mask.x+sp.zx*mask.y+sp.xy*mask.z;\r\n\treturn mix(mix(vAO.z,vAO.w,uv.x),mix(vAO.y,vAO.x,uv.x),uv.y);\r\n\t\r\n}\r\n\r\nvoid main(){\r\n\t\r\n\tvec2 uv=(vUv-vec2(.5))*2.;\r\n\t\r\n\t// 相机参数\r\n\tvec3 camPos=vec3(0.,-.9,uTime*8.);//相机位置\r\n\tvec3 lookAt=camPos+vec3(0.,.1,.25);// 相机朝向\r\n\t\r\n\tvec3 lightPos=camPos+vec3(0,2.5,8);\r\n\t\r\n\tlookAt.xy+=path(lookAt.z);\r\n\tcamPos.xy+=path(camPos.z);\r\n\tlightPos.xy+=path(lightPos.z);\r\n\t\r\n\tfloat FOV=PI/2.;\r\n\tvec3 forward=normalize(lookAt-camPos);\r\n\tvec3 right=normalize(vec3(forward.z,0.,-forward.x));\r\n\tvec3 up=cross(forward,right);\r\n\t\r\n\tvec3 rd=normalize(forward+FOV*uv.x*right+FOV*uv.y*up);\r\n\t\r\n\trd.xy=rot2(path(lookAt.z).x/24.)*rd.xy;\r\n\t\r\n\tvec3 mask;\r\n\tvec3 vPos=voxelTrace(camPos,rd,mask);\r\n\t\r\n\tvec3 tCube=(vPos-camPos-.5*sign(rd))/rd;\r\n\tfloat t=max(max(tCube.x,tCube.y),tCube.z);\r\n\t\r\n\tvec3 sceneCol=vec3(0);\r\n\t\r\n\tif(t<FAR){\r\n\t\t\r\n\t\tvec3 sp=camPos+rd*t;\r\n\t\tvec3 sn=-(mask*sign(rd));\r\n\t\tvec3 snNoBump=sn;\r\n\t\tconst float tSize0=1./4.;\r\n\t\tsn=palette(uv.x+uTime*.4);\r\n\t\tsn=doBumpMap(sp,sn,.15);//求最大光追面积\r\n\t\tfloat ao=calcVoxAO(vPos,sp,rd,mask);\r\n\t\t\r\n\t\tvec3 ld=lightPos-sp;\r\n\t\tfloat lDist=max(length(ld),.001);\r\n\t\tld/=lDist;\r\n\t\tfloat atten=1./(1.+lDist*.2+lDist*.1);\r\n\t\t\r\n\t\tfloat ambience=.25;\r\n\t\tfloat diff=max(dot(sn,ld),0.);\r\n\t\tfloat spec=pow(max(dot(reflect(-ld,sn),-rd),0.),32.);\r\n\t\tvec3 texCol=vec3(1,.6,.4)+step(abs(snNoBump.y),.5)*vec3(0,.4,.6);\r\n\t\ttexCol*=palette(uv.x+uTime*.4);;\r\n\t\tfloat shading=voxShadow(sp+snNoBump*.01,ld,lDist);\r\n\t\tsceneCol=texCol*(diff+ambience)+vec3(.7,.9,1.)*spec;\r\n\t\tsceneCol*=atten*shading*ao;\r\n\t\t\r\n\t}\r\n\t\r\n\tsceneCol=mix(sceneCol,vec3(.08,.16,.34),smoothstep(0.,.95,t/FAR));\r\n\tgl_FragColor=vec4(sqrt(clamp(sceneCol,0.,1.)),1.);\r\n\t\r\n}",side:t,blending:r,depthWrite:!1,transparent:!0},x=function(){f.uniforms.uTime.value+=.006};return(r,t)=>{const n=e("TresCanvas");return o(),a(n,i(l,{"window-size":"",onLoop:x}),{default:s(()=>[c("TresPerspectiveCamera",d,null,512),t[1]||(t[1]=c("TresAmbientLight",{color:"#ffffff"},null,-1)),t[2]||(t[2]=c("TresDirectionalLight",{position:[100,100,0],intensity:.5,color:"#ffffff"},null,-1)),c("TresMesh",{ref:"quanMeshRef","rotation-x":Math.PI},[t[0]||(t[0]=c("TresPlaneGeometry",{args:[4e3,4e3]},null,-1)),c("TresShaderMaterial",v(p(f)),null,16)],8,m)]),_:1},16)}}});export{l as default};
