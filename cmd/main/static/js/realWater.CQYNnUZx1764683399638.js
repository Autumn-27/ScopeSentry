import{F as e,_ as r,K as n,d as t}from"./@tresjs.CJvYCGUA1764683399638.js";import{P as o}from"./tweakpane.CqZAnw7f1764683399638.js";import"./index.DM693cYN1764683399638.js";import{u as a}from"./utils.Dayf5snU1764683399638.js";import{d as i,ad as c,a as l,e as s,o as u,u as v,ah as f,f as m,h as p,r as g,I as x,a9 as d,aa as h}from"./@vue.DjQnunkc1764683399638.js";import{i as y,j as w,bT as b,aV as C,o as R,by as M,k as z,bj as _,O as D,p as j,J as T,q as I,b2 as L,m as A,d as O}from"./three.BbguFgn81764683399638.js";import{l as F}from"./lodash.OvYRBTRe1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";var W="attribute vec3 position;\r\nvarying vec2 coord;\r\n\nvoid main() {\r\n  coord = position.xy * 0.5 + 0.5;\n\n  gl_Position = vec4(position.xyz, 1.0);\r\n}";const E=i({__name:"pool",props:{waterTexture:{},causticsTexture:{},tiles:{},light:{}},setup(n){const t=n,o=new y,a=new Float32Array([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,-1,1,1,1,1,1]),i=new Uint32Array([0,1,2,2,1,3,4,5,6,6,5,7,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23]);o.setAttribute("position",new w(a,3)),o.setIndex(new w(i,1));const c=new b({uniforms:{light:{value:t.light},tiles:{value:t.tiles},water:{value:null},causticTex:{value:null}},vertexShader:"const float IOR_AIR = 1.0;\r\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\r\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\r\nuniform sampler2D tiles;\r\nuniform sampler2D causticTex;\r\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\r\n  vec3 tMin = (cubeMin - origin) / ray;\r\n  vec3 tMax = (cubeMax - origin) / ray;\r\n  vec3 t1 = min(tMin, tMax);\r\n  vec3 t2 = max(tMin, tMax);\r\n  float tNear = max(max(t1.x, t1.y), t1.z);\r\n  float tFar = min(min(t2.x, t2.y), t2.z);\r\n  return vec2(tNear, tFar);\r\n}\n\nvec3 getWallColor(vec3 point) {\r\n  float scale = 0.5;\n\n  vec3 wallColor;\r\n  vec3 normal;\r\n  if (abs(point.x) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(-point.x, 0.0, 0.0);\r\n  } else if (abs(point.z) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(0.0, 0.0, -point.z);\r\n  } else {\r\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\r\n    normal = vec3(0.0, 1.0, 0.0);\r\n  }\n\n  scale /= length(point); \n\n  /* caustics */\r\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\r\n  float diffuse = max(0.0, dot(refractedLight, normal));\r\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\r\n  if (point.y < info.r) {\r\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\r\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\r\n  } else {\r\n    /* shadow for the rim of the pool */\r\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\r\n  }\n\n  return wallColor * scale;\r\n}\n\nuniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\n\nattribute vec3 position;\n\nvarying vec3 pos;\r\n\nvoid main() {\r\n  pos = position.xyz;\r\n  pos.y = ((1.0 - pos.y) * (7.0 / 12.0) - 1.0) * poolHeight;\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}",fragmentShader:"precision highp float;\r\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\r\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\r\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\r\nuniform sampler2D tiles;\r\nuniform sampler2D causticTex;\r\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\r\n  vec3 tMin = (cubeMin - origin) / ray;\r\n  vec3 tMax = (cubeMax - origin) / ray;\r\n  vec3 t1 = min(tMin, tMax);\r\n  vec3 t2 = max(tMin, tMax);\r\n  float tNear = max(max(t1.x, t1.y), t1.z);\r\n  float tFar = min(min(t2.x, t2.y), t2.z);\r\n  return vec2(tNear, tFar);\r\n}\n\nvec3 getWallColor(vec3 point) {\r\n  float scale = 0.5;\n\n  vec3 wallColor;\r\n  vec3 normal;\r\n  if (abs(point.x) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(-point.x, 0.0, 0.0);\r\n  } else if (abs(point.z) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(0.0, 0.0, -point.z);\r\n  } else {\r\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\r\n    normal = vec3(0.0, 1.0, 0.0);\r\n  }\n\n  scale /= length(point); \n\n  /* caustics */\r\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\r\n  float diffuse = max(0.0, dot(refractedLight, normal));\r\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\r\n  if (point.y < info.r) {\r\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\r\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\r\n  } else {\r\n    /* shadow for the rim of the pool */\r\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\r\n  }\n\n  return wallColor * scale;\r\n}\n\nvarying vec3 pos;\r\n\nvoid main() {\r\n  gl_FragColor = vec4(getWallColor(pos), 1.0);\n\n  vec4 info = texture2D(water, pos.xz * 0.5 + 0.5);\n\n  if (pos.y < info.r) {\r\n    gl_FragColor.rgb *= underwaterColor * 1.2;\r\n  }\r\n}",side:C}),l=new R(o,c),{renderer:s,camera:u}=e(),{onBeforeRender:v}=r();return v(()=>{var e,r;e=t.waterTexture,r=t.causticsTexture,c.uniforms.water.value=e,c.uniforms.causticTex.value=r,s.render(l,u.value)},-1),(e,r)=>null}}),P=i({__name:"water",props:{waterTexture:{},causticsTexture:{},geometry:{},light:{}},async setup(n){let t,o;const i=n,f=i.geometry,m=(new M).setPath("https://opensource.cdn.icegl.cn/images/skyBox/6jpg/").load(["pos-x.jpg","neg-x.jpg","pos-y.jpg","neg-y.jpg","pos-z.jpg","neg-z.jpg"]),p=([t,o]=c(()=>a("./plugins/water/images/tiles.jpg")),t=await t,o(),t),g=new b({uniforms:{light:{value:i.light},tiles:{value:p},sky:{value:m},water:{value:null},causticTex:{value:null},underwater:{value:!1}},vertexShader:"uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\nuniform sampler2D water;\n\nattribute vec3 position;\n\nvarying vec3 eye;\r\nvarying vec3 pos;\r\n\nvoid main() {\r\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\r\n  pos = position.xzy;\r\n  pos.y += info.r;\n\n  vec3 axis_x = vec3(modelViewMatrix[0].x, modelViewMatrix[0].y, modelViewMatrix[0].z);\r\n  vec3 axis_y = vec3(modelViewMatrix[1].x, modelViewMatrix[1].y, modelViewMatrix[1].z);\r\n  vec3 axis_z = vec3(modelViewMatrix[2].x, modelViewMatrix[2].y, modelViewMatrix[2].z);\r\n  vec3 offset = vec3(modelViewMatrix[3].x, modelViewMatrix[3].y, modelViewMatrix[3].z);\n\n  eye = vec3(dot(-offset, axis_x), dot(-offset, axis_y), dot(-offset, axis_z));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}",fragmentShader:"precision highp float;\r\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\r\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\r\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\r\nuniform sampler2D tiles;\r\nuniform sampler2D causticTex;\r\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\r\n  vec3 tMin = (cubeMin - origin) / ray;\r\n  vec3 tMax = (cubeMax - origin) / ray;\r\n  vec3 t1 = min(tMin, tMax);\r\n  vec3 t2 = max(tMin, tMax);\r\n  float tNear = max(max(t1.x, t1.y), t1.z);\r\n  float tFar = min(min(t2.x, t2.y), t2.z);\r\n  return vec2(tNear, tFar);\r\n}\n\nvec3 getWallColor(vec3 point) {\r\n  float scale = 0.5;\n\n  vec3 wallColor;\r\n  vec3 normal;\r\n  if (abs(point.x) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(-point.x, 0.0, 0.0);\r\n  } else if (abs(point.z) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(0.0, 0.0, -point.z);\r\n  } else {\r\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\r\n    normal = vec3(0.0, 1.0, 0.0);\r\n  }\n\n  scale /= length(point); \n\n  /* caustics */\r\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\r\n  float diffuse = max(0.0, dot(refractedLight, normal));\r\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\r\n  if (point.y < info.r) {\r\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\r\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\r\n  } else {\r\n    /* shadow for the rim of the pool */\r\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\r\n  }\n\n  return wallColor * scale;\r\n}\n\nuniform float underwater;\r\nuniform samplerCube sky;\n\nvarying vec3 eye;\r\nvarying vec3 pos;\r\n\nvec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {\r\n  vec3 color;\n\n  if (ray.y < 0.0) {\r\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n    color = getWallColor(origin + ray * t.y);\r\n  } else {\r\n    vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n    vec3 hit = origin + ray * t.y;\r\n    if (hit.y < 7.0 / 12.0) {\r\n      color = getWallColor(hit);\r\n    } else {\r\n      color = textureCube(sky, ray).rgb;\r\n      color += 0.01 * vec3(pow(max(0.0, dot(light, ray)), 20.0)) * vec3(10.0, 8.0, 6.0);\r\n    }\r\n  }\n\n  if (ray.y < 0.0) color *= waterColor;\n\n  return color;\r\n}\r\n\nvoid main() {\r\n  vec2 coord = pos.xz * 0.5 + 0.5;\r\n  vec4 info = texture2D(water, coord);\n\n  \r\n  for (int i = 0; i < 5; i++) {\r\n    coord += info.ba * 0.005;\r\n    info = texture2D(water, coord);\r\n  }\n\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\r\n  vec3 incomingRay = normalize(pos - eye);\n\n  if (underwater == 1.) {\r\n    normal = -normal;\r\n    vec3 reflectedRay = reflect(incomingRay, normal);\r\n    vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);\r\n    float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, underwaterColor);\r\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);\n\n    gl_FragColor = vec4(mix(reflectedColor, refractedColor, (1.0 - fresnel) * length(refractedRay)), 1.0);\r\n  } else {\r\n    vec3 reflectedRay = reflect(incomingRay, normal);\r\n    vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);\r\n    float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));\n\n    vec3 reflectedColor = getSurfaceRayColor(pos, reflectedRay, abovewaterColor);\r\n    vec3 refractedColor = getSurfaceRayColor(pos, refractedRay, abovewaterColor);\n\n    gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);\r\n  }\r\n}"}),x=new R(f,g),d=l(null),h=new z("white"),{renderer:y,camera:w}=e(),{onRender:D}=r();return D(()=>{y.setRenderTarget(null),y.setClearColor(h,1),y.clear(),g.uniforms.water.value=i.waterTexture,g.uniforms.causticTex.value=i.causticsTexture,g.side=C,g.uniforms.underwater.value=!0,y.render(x,w.value),g.side=_,g.uniforms.underwater.value=!1,y.render(x,w.value)}),(e,r)=>(u(),s(E,{tiles:v(p),light:e.light,waterTexture:e.waterTexture,causticsTexture:e.causticsTexture,ref_key:"pooRef",ref:d},null,8,["tiles","light","waterTexture","causticsTexture"]))}}),S=i({__name:"caustics",props:{lightFrontGeometry:{},waterTexture:{},light:{}},setup(n){const t=n,o=new D(0,1,1,0,0,2e3),a=new j(2,2,200,200),i=new T(1024,1024),c=new I({uniforms:{light:{value:t.light},water:{value:null}},vertexShader:"precision highp float;\r\nprecision highp int;\n\nvarying vec3 oldPos;\r\nvarying vec3 newPos;\r\nvarying vec3 ray;\n\nconst float IOR_AIR = 1.0;\r\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\r\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\r\nuniform sampler2D tiles;\r\nuniform sampler2D causticTex;\r\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\r\n  vec3 tMin = (cubeMin - origin) / ray;\r\n  vec3 tMax = (cubeMax - origin) / ray;\r\n  vec3 t1 = min(tMin, tMax);\r\n  vec3 t2 = max(tMin, tMax);\r\n  float tNear = max(max(t1.x, t1.y), t1.z);\r\n  float tFar = min(min(t2.x, t2.y), t2.z);\r\n  return vec2(tNear, tFar);\r\n}\n\nvec3 getWallColor(vec3 point) {\r\n  float scale = 0.5;\n\n  vec3 wallColor;\r\n  vec3 normal;\r\n  if (abs(point.x) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(-point.x, 0.0, 0.0);\r\n  } else if (abs(point.z) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(0.0, 0.0, -point.z);\r\n  } else {\r\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\r\n    normal = vec3(0.0, 1.0, 0.0);\r\n  }\n\n  scale /= length(point); \n\n  /* caustics */\r\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\r\n  float diffuse = max(0.0, dot(refractedLight, normal));\r\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\r\n  if (point.y < info.r) {\r\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\r\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\r\n  } else {\r\n    /* shadow for the rim of the pool */\r\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\r\n  }\n\n  return wallColor * scale;\r\n}\r\n\nvec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {\r\n  vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n  origin += ray * tcube.y;\r\n  float tplane = (-origin.y - 1.0) / refractedLight.y;\n\n  return origin + refractedLight * tplane;\r\n}\r\n\nvoid main() {\r\n  vec4 info = texture2D(water, position.xy * 0.5 + 0.5);\r\n  info.ba *= 0.5;\r\n  vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);\n\n  /* project the vertices along the refracted vertex ray */\r\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\r\n  ray = refract(-light, normal, IOR_AIR / IOR_WATER);\r\n  oldPos = project(position.xzy, refractedLight, refractedLight);\r\n  newPos = project(position.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);\n\n  gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);\r\n}",fragmentShader:"precision highp float;\r\nprecision highp int;\n\nconst float IOR_AIR = 1.0;\r\nconst float IOR_WATER = 1.333;\n\nconst vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);\r\nconst vec3 underwaterColor = vec3(0.4, 0.9, 1.0);\n\nconst float poolHeight = 1.0;\n\nuniform vec3 light;\r\nuniform sampler2D tiles;\r\nuniform sampler2D causticTex;\r\nuniform sampler2D water;\n\nvec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {\r\n  vec3 tMin = (cubeMin - origin) / ray;\r\n  vec3 tMax = (cubeMax - origin) / ray;\r\n  vec3 t1 = min(tMin, tMax);\r\n  vec3 t2 = max(tMin, tMax);\r\n  float tNear = max(max(t1.x, t1.y), t1.z);\r\n  float tFar = min(min(t2.x, t2.y), t2.z);\r\n  return vec2(tNear, tFar);\r\n}\n\nvec3 getWallColor(vec3 point) {\r\n  float scale = 0.5;\n\n  vec3 wallColor;\r\n  vec3 normal;\r\n  if (abs(point.x) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(-point.x, 0.0, 0.0);\r\n  } else if (abs(point.z) > 0.999) {\r\n    wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;\r\n    normal = vec3(0.0, 0.0, -point.z);\r\n  } else {\r\n    wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;\r\n    normal = vec3(0.0, 1.0, 0.0);\r\n  }\n\n  scale /= length(point); \n\n  /* caustics */\r\n  vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\r\n  float diffuse = max(0.0, dot(refractedLight, normal));\r\n  vec4 info = texture2D(water, point.xz * 0.5 + 0.5);\r\n  if (point.y < info.r) {\r\n    vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);\r\n    scale += diffuse * caustic.r * 2.0 * caustic.g;\r\n  } else {\r\n    /* shadow for the rim of the pool */\r\n    vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n    diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));\n\n    scale += diffuse * 0.5;\r\n  }\n\n  return wallColor * scale;\r\n}\n\nvarying vec3 oldPos;\r\nvarying vec3 newPos;\r\nvarying vec3 ray;\r\n\nvoid main() {\r\n  \r\n  float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));\r\n  float newArea = length(dFdx(newPos)) * length(dFdy(newPos));\r\n  gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);\n\n  vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);\n\n  /* shadow for the rim of the pool */\r\n  vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));\r\n  gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));\r\n}"}),l=new R(a,c),g=new z("black"),{renderer:x}=e(),{onBeforeRender:d}=r();return d(()=>{l.material.uniforms.water.value=t.waterTexture,x.setRenderTarget(i),x.setClearColor(g,0),x.clear(),x.render(l,o)}),(e,r)=>(u(),s(f,null,{default:m(()=>[p(P,{waterTexture:e.waterTexture,causticsTexture:v(i).texture,light:e.light,geometry:v(a)},null,8,["waterTexture","causticsTexture","light","geometry"])]),_:1}))}}),V=i({__name:"waterSimulation",props:{light:{}},setup(n,{expose:t}){const o=new D(0,1,1,0,0,2e3),a=new j(2,2),i=new T(256,256,{type:L}),c=new T(256,256,{type:L}),f=new b({uniforms:{center:{value:[0,0]},radius:{value:0},strength:{value:0},texture:{value:null}},vertexShader:W,fragmentShader:"precision highp float;\r\nprecision highp int;\n\nconst float PI = 3.141592653589793;\r\nuniform sampler2D texture;\r\nuniform vec2 center;\r\nuniform float radius;\r\nuniform float strength;\r\nvarying vec2 coord;\r\n\nvoid main() {\r\n  \r\n  vec4 info = texture2D(texture, coord);\n\n  /* Add the drop to the height */\r\n  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);\r\n  drop = 0.5 - cos(drop * PI) * 0.5;\r\n  info.r += drop * strength;\n\n  gl_FragColor = info;\r\n}"}),m=new b({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:W,fragmentShader:"precision highp float;\r\nprecision highp int;\n\nuniform sampler2D texture;\r\nuniform vec2 delta;\r\nvarying vec2 coord;\r\n\nvoid main() {\r\n  \r\n  vec4 info = texture2D(texture, coord);\n\n  /* update the normal */\r\n  vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);\r\n  vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);\r\n  info.ba = normalize(cross(dy, dx)).xz;\n\n  gl_FragColor = info;\r\n}"}),p=new b({uniforms:{delta:{value:[1/256,1/256]},texture:{value:null}},vertexShader:W,fragmentShader:"precision highp float;\r\nprecision highp int;\n\nuniform sampler2D texture;\r\nuniform vec2 delta;\r\nvarying vec2 coord;\r\n\nvoid main() {\r\n  \r\n  vec4 info = texture2D(texture, coord);\n\n  /* calculate average neighbor height */\r\n  vec2 dx = vec2(delta.x, 0.0);\r\n  vec2 dy = vec2(0.0, delta.y);\r\n  float average = (\r\n    texture2D(texture, coord - dx).r +\r\n    texture2D(texture, coord - dy).r +\r\n    texture2D(texture, coord + dx).r +\r\n    texture2D(texture, coord + dy).r\r\n  ) * 0.25;\n\n  /* change the velocity to move toward the average */\r\n  info.g += (average - info.r) * 2.0;\n\n  /* attenuate the velocity a little so waves do not last forever */\r\n  info.g *= 0.995;\n\n  /* move the vertex along the velocity */\r\n  info.r += info.g;\n\n  gl_FragColor = info;\r\n}"}),g=new R(a,f),x=new R(a,m),d=new R(a,p);let h=i;const y=(e,r)=>{const n=h,t=h===i?c:i;r.material.uniforms.texture.value=n.texture,e.setRenderTarget(t),e.render(r,o),h=t},{renderer:w,camera:C}=e(),M=l(new A);w.autoClear=!1;const{onBeforeRender:z}=r();z(()=>{y(w,d),(e=>{y(e,x)})(w)});const _=(e,r,n,t)=>{g.material.uniforms.center.value=[e,r],g.material.uniforms.radius.value=n,g.material.uniforms.strength.value=t,y(w,g)},I=new O,E=new j(2,2),P=E.attributes.position;for(let e=0;e<P.count;e++){const r=-P.getY(e);P.setY(e,0),P.setZ(e,r)}P.needsUpdate=!0;const V=new R(E),H=e=>{const r=w.domElement.getBoundingClientRect(),n=r.width,t=r.height;I.x=2*(e.clientX-r.left)/n-1,I.y=2*-(e.clientY-r.top)/t+1,M.value.setFromCamera(I,C.value);const o=M.value.intersectObject(V);for(let a of o)_(a.point.x,a.point.z,.03,.04)},k={handleEvent:H};return t({addDrop:_,mouseEvent:e=>{e?w.domElement.addEventListener("mousemove",F.throttle(H,30)):w.domElement.removeEventListener("mousemove",k)}}),(e,r)=>(u(),s(S,{lightFrontGeometry:v(a),waterTexture:v(h).texture,light:e.light},null,8,["lightFrontGeometry","waterTexture","light"]))}}),H=i({__name:"realWater",setup(e){const r=g({alpha:!0,antialias:!0,windowSize:!0,clearAlpha:0,renderMode:"manual"}),a=[.7559289460184544,.7559289460184544,-.3779644730092272],i=l(null),c=new o;c.addButton({label:"点击按钮",title:"随机增加波纹"}).on("click",()=>{for(var e=0;e<10;e++)i.value.addDrop(2*Math.random()-1,2*Math.random()-1,.03,1&e?.02:-.02)});const f=l(!1);return c.addBinding(f,"value",{label:"鼠标波纹"}).on("change",e=>{i.value.mouseEvent(e.value)}),(e,o)=>(u(),s(v(t),d(h(r)),{default:m(()=>[o[0]||(o[0]=x("TresPerspectiveCamera",{position:[.426,.677,-2.095],fov:75,near:.01,far:1e3},null,-1)),p(v(n)),p(V,{light:a,ref_key:"waterSimulationRef",ref:i},null,512)]),_:1},16))}});export{H as default};
