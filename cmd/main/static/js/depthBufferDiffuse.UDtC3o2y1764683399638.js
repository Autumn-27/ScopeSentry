import"./@fesjs.CQdxRiFD1764683399638.js";import"./index.DM693cYN1764683399638.js";import{_ as e}from"./default.vue_vue_type_script_setup_true_lang.SpQztfdb1764683399638.js";import{F as o,_ as r}from"./@tresjs.CJvYCGUA1764683399638.js";import{u as i}from"./index.zjpK5bpU1764683399638.js";import{d as a,ae as n,w as t,G as s,o as l,I as u,a9 as m,aa as p,r as d,t as f,h as v,u as h,f as c,m as j,F as g}from"./@vue.DjQnunkc1764683399638.js";import{k as C,d as _,a6 as x,bd as y}from"./three.BbguFgn81764683399638.js";import"./SPE.vXfNhp2I1764683399638.js";import"./Fetch.CIMEiaKn1764683399638.js";import"./three-custom-shader-material.VhylcSiy1764683399638.js";import{P as b}from"./tweakpane.CqZAnw7f1764683399638.js";import{b as D}from"./pagesShow.vue_vue_type_script_setup_true_lang.BJJ2kmGn1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./buildingsCustomShaderMaterial.C_BZxytV1764683399638.js";const w={renderOrder:2200},z=["args"],N=a({__name:"depthBufferDiffuse",props:{radius:{default:100},shieldColor:{default:"#ffff00"},rimColor:{default:"#ffffff"},threshold:{default:.005}},setup(e){const a=e,{sizes:d,camera:f}=o(),v=d.aspectRatio.value,h=d.width.value,c=d.height.value,j=i({height:h*v,width:c*v,depth:!0,isLoop:!0}),g={blending:y,transparent:!0,depthWrite:!1,depthTest:!0,side:x,vertexShader:"\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        void main() {\n            vUv = uv;\n            vec4 worldPos = modelMatrix * vec4(position, 1.0);\n            vec4 modelNormal = modelMatrix * vec4(normal, 0.0);\n            vec4 mvPosition = viewMatrix * worldPos;\n            gl_Position = projectionMatrix * mvPosition;\n            vNormal = modelNormal.xyz;\n            vPosition = worldPos.xyz;\n        }\n    ",fragmentShader:"\n        uniform sampler2D uDepthTexture; \n        uniform vec2 uResolution;\n        uniform float uNear;\n        uniform float uFar;\n        uniform float uThreshold;\n        uniform vec3 uShieldColor;\n        uniform vec3 uRimColor;\n\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n\n        #include <packing>\n\n        float LinearizeDepth(float depth) {\n            float zNdc = 2.0 * depth - 1.0;\n            float zEye = (2.0 * uFar * uNear) / ((uFar + uNear) - zNdc * (uFar - uNear));\n            float linearDepth = (zEye - uNear) / (uFar - uNear);\n            return linearDepth;\n        }\n\n        void main() {\n            vec3 normal = normalize(vNormal);\n            if(gl_FrontFacing) {\n                normal *= -1.0;\n            }\n\n            vec3 viewDirection = normalize(cameraPosition - vPosition);\n            float fresnel = 1. + dot(normal, viewDirection);\n            fresnel = pow(fresnel, 4.0);\n\n            vec2 worldCoords = gl_FragCoord.xy/uResolution;\n\n            float sceneDepth = LinearizeDepth(texture2D(uDepthTexture, worldCoords).r);\n            float bubbleDepth = LinearizeDepth(gl_FragCoord.z);\n\n            float difference = abs(sceneDepth - bubbleDepth);\n            float normalizedDistance = clamp(difference / uThreshold, 0.0, 1.0);\n            vec4 intersection = mix(vec4(1.0), vec4(0.0), normalizedDistance);\n            intersection.rgb *= uRimColor;\n\n            vec4 color = vec4(uShieldColor, 0.3);\n            gl_FragColor = color + intersection + vec4(uRimColor, 1.0) * fresnel;\n        }\n    ",uniforms:{uDepthTexture:{value:n(j?.value?.depthTexture)},uResolution:{value:new _(h,c)},uNear:{value:f.value?.near??1},uFar:{value:f.value?.far??1e4},uThreshold:{value:a.threshold},uShieldColor:{value:new C(a.shieldColor)},uRimColor:{value:new C(a.rimColor)}}},{onRender:b}=r();return b(()=>{}),t(()=>[a.rimColor,a.shieldColor,a.threshold],([e,o,r])=>{g.uniforms.uRimColor.value.setStyle(e),g.uniforms.uShieldColor.value.setStyle(o),g.uniforms.uThreshold.value=r}),(e,o)=>(l(),s("TresMesh",w,[u("TresSphereGeometry",{args:[a.radius,64,64]},null,8,z),u("TresShaderMaterial",m(p(g)),null,16)]))}}),F=a({__name:"depthBufferDiffuse",setup(o){const r=d({shieldColor:"#ffff00",rimColor:"#ffffff",threshold:2e-4,radius:100}),i=new b;i.addBinding(r,"shieldColor",{label:"圈颜色"}),i.addBinding(r,"rimColor",{label:"条颜色"}),i.addBinding(r,"threshold",{label:"线条参数",min:1e-5,max:.002,step:1e-5}),i.addBinding(r,"radius",{label:"大小",min:10,max:200,step:1});const a=f(null);return t(()=>a.value?.contextReady,e=>{e&&a.value.context.context.camera.activeCamera.value.position.set(-135,250,320)}),(o,i)=>(l(),s(g,null,[v(h(e)),v(D,{ref_key:"pagesShowRef",ref:a},{ability:c(()=>[v(h(N),j({position:[0,30,0]},r),null,16)]),_:1},512)],64))}});export{F as default};
