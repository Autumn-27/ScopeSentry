import{bJ as r,a6 as n}from"./three.BbguFgn81764683399638.js";import{a as e}from"./argestCircle.BQYgKx3o1764683399638.js";import{d as t,b as a,e as o,o as l,f,I as i,a9 as c,aa as s,m as d}from"./@vue.DjQnunkc1764683399638.js";const v={ref:"perspectiveCameraRef",position:[0,0,1800],fov:45,near:1,far:1e4},p=["rotation-x"],m=t({__name:"superPipeline",setup(t){const m={clearColor:"#000000",shadows:!0,alpha:!1,useLegacyLights:!0},x={uniforms:{uTime:{type:"f",value:0}},vertexShader:e,fragmentShader:"varying vec2 vUv;\r\nuniform float uTime;\r\n#define FAR 50.\r\nfloat svObjID,svObjID2;\r\nvec3 vObjID;\r\n#define TUN 0.\r\n#define ROD 1.\r\n#define BLT 2.\r\nmat2 rot(float th){vec2 a=sin(vec2(1.5707963,0)+th);return mat2(a,-a.y,a.x);}\r\nvec3 camPath(float t){\r\n  float a=sin(t*3.14159265/16.+1.5707963);\r\n  float b=cos(t*3.14159265/16.);\r\n  return vec3(a,b*a*.5,t);\r\n}\n\nvec3 camPathPL(float t){\r\n  float it=floor(t+1.);\r\n  float ft=t-it;\r\n  float a=sin(it*3.14159265/16.+1.5707963);\r\n  float b=cos(it*3.14159265/16.);\r\n  vec2 p0=vec2(a,b*a*.5);\r\n  a=sin((it+1.)*3.14159265/16.+1.5707963);\r\n  b=cos((it+1.)*3.14159265/16.);\r\n  vec2 p1=vec2(a,b*a*.5);\r\n  vec2 p=mix(p0,p1,ft);\r\n  return vec3(p,t);\r\n}\r\nvec2 objMin(vec2 a,vec2 b){\r\n  return a.x<b.x?a:b;\r\n}\n\nfloat map(vec3 p){\r\n  const float depth=.25;\r\n  p.xy-=camPath(p.z).xy;\r\n  float tun=(1.+depth)-length(p.xy);\r\n  vec3 q=p;\r\n  vec3 q2=p;\r\n  float a=atan(q.y,q.x)/6.2831853;\r\n  float ia=(floor(a*5.)+.5)/5.*6.2831853;\r\n  float ia2=(floor(a*15.)+.5)/15.*6.2831853;\r\n  q.xy*=rot(ia+sign(mod(q.z+1.,4.)-2.)*3.14159/15.);\n  q2.xy*=rot(ia2);\r\n  q.x=mod(q.x,2.)-1.;\r\n  q.z=mod(q.z,2.)-1.;\r\n  q2.x=mod(q2.x,(2.+.25))-(2.+.25)/2.;\r\n  q=abs(q);\r\n  q2=abs(q2);\r\n  float tunDetail=max(min(q.y,q.z)-.07,-(min(q.y,q.z)-.007));\r\n  tun=min(tun,max(tunDetail,tun-depth));\r\n  float blt=max(max(q2.x*.866025+q2.y*.5,q2.y)-.055,q.z-.16);\r\n  float thread=max(sin(q.z*6.283*64.)*2.,0.)*.002;\r\n  float rod=max(length(q2.xy)-.025+thread,q.z-.19);\r\n  rod=min(rod,max(length(q2.xy)-.075,q.z-.09));\r\n  vObjID=vec3(tun,blt,rod);\r\n  return min(min(tun,blt),rod);\r\n}\r\nfloat refTrace(vec3 ro,vec3 rd){\r\n  float t=0.;\r\n  for(int i=0;i<12;i++){\r\n    float d=map(ro+rd*t);\r\n    if(abs(d)<.005*(t*.25+1.)||t>FAR)break;\r\n    t+=d;\r\n  }\r\n  return t;\r\n}\n\nfloat trace(vec3 ro,vec3 rd){\r\n  float t=0.,d;\r\n  for(int i=0;i<96;i++){\r\n    d=map(ro+rd*t);\r\n    if(abs(d)<.001*(t*.125+1.)||t>FAR)break;\r\n    t+=d;\r\n  }\r\n  return min(t,FAR);\r\n}\r\nvec3 nrHyb(vec3 p,inout float crv,float ef){\r\n  vec2 e=vec2(-1.,1.)*.66*ef/450.;\r\n  float d1=map(p+e.yxx),d2=map(p+e.xxy);\r\n  float d3=map(p+e.xyx),d4=map(p+e.yyy);\r\n  float d=map(p);\r\n  float d5,d6;\r\n  crv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\r\n  e=vec2(.005,0);\r\n  d1=map(p+e.xyy),d2=map(p-e.xyy);\r\n  d3=map(p+e.yxy),d4=map(p-e.yxy);\r\n  d5=map(p+e.yyx),d6=map(p-e.yyx);\r\n  return normalize(vec3(d1-d2,d3-d4,d5-d6));\r\n}\r\nvec3 nrRef(in vec3 p,inout float crv,in float ef){\r\n  vec2 e=vec2(-1.,1.)*.66*ef/450.;\r\n  float d1=map(p+e.yxx),d2=map(p+e.xxy);\r\n  float d3=map(p+e.xyx),d4=map(p+e.yyy);\r\n  float d=map(p);\r\n  crv=clamp((d1+d2+d3+d4-d*4.)*24.+.5,0.,1.);\r\n  e=vec2(-1.,1.)*.002;\r\n  d1=map(p+e.yxx),d2=map(p+e.xxy);\r\n  d3=map(p+e.xyx),d4=map(p+e.yyy);\r\n  return normalize(e.yxx*d1+e.xxy*d2+e.xyx*d3+e.yyy*d4);\r\n}\r\nfloat cao(in vec3 p,in vec3 n){\r\n  float sca=1.,occ=0.;\r\n  for(float i=0.;i<5.;i++){\r\n    float hr=.01+i*.5/4.;\r\n    float dd=map(n*hr+p);\r\n    occ+=(hr-dd)*sca;\r\n    sca*=.7;\r\n  }\r\n  return clamp(1.-occ,0.,1.);\r\n}\r\nfloat softShadow(vec3 ro,vec3 lp,float k){\r\n  const int maxIterationsShad=20;\r\n  vec3 rd=(lp-ro);\r\n  float shade=1.;\r\n  float dist=.05;\r\n  float end=max(length(rd),.001);\r\n  rd/=end;\r\n  for(int i=0;i<maxIterationsShad;i++){\r\n    float h=map(ro+rd*dist);\r\n    shade=min(shade,k*h/dist);\r\n    dist+=clamp(h,.01,.25);\r\n    if(h<.001||dist>end)break;\r\n  }\r\n  return min(max(shade,0.)+.2,1.);\r\n}\r\nvec3 palette(float t){\r\n  vec3 a=vec3(.5,.5,.5);\r\n  vec3 b=vec3(.5,.5,.5);\r\n  vec3 c=vec3(1.,1.,1.);\r\n  vec3 d=vec3(sin(uTime*.2)*.5+.5,cos(uTime*.25)*.5+.5,sin(uTime*.3+1.)*.5+.5);\r\n  return a+b*cos(6.28318*(c*t+d));\r\n}\r\nvoid main(){\r\n  vec2 u=(vUv-vec2(.5))*2.;\r\n  #ifdef THREE_D\r\n  float sg=sign(fragCoord.x-.5*iResolution.x);\r\n  u.x-=sg*.25*iResolution.x/iResolution.y;\r\n  #endif\r\n  float speed=2.;\r\n  vec3 ro=camPath(uTime*speed+.0);\r\n  vec3 lk=camPath(uTime*speed+.5);\r\n  vec3 lp=camPath(uTime*speed+2.);\r\n  lp.y+=.5;\r\n  #ifdef THREE_D\r\n  ro.x-=sg*.15;lk.x-=sg*.15;lp.x-=sg*.15;\r\n  #endif\r\n  float FOV=.75;\r\n  vec3 fwd=normalize(lk-ro);\r\n  vec3 rgt=normalize(vec3(fwd.z,0.,-fwd.x));\r\n  vec3 up=cross(fwd,rgt);\r\n  vec3 rd=fwd+FOV*(u.x*rgt+u.y*up);\r\n  rd=normalize(vec3(rd.xy,(rd.z-length(rd.xy)*.25)*.75));\r\n  float swivel=camPath(lk.z).x;\r\n  rd.xy=rot(swivel/48.)*rd.xy;\r\n  rd.xz=rot(swivel/32.)*rd.xz;\r\n  float t=trace(ro,rd);\r\n  vec2 vObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\r\n  vObj=objMin(vObj,vec2(vObjID.z,ROD));\r\n  svObjID=vObj.y;\r\n  vec3 sp=ro+rd*t;\r\n  float crv=1.,ef=8.;\r\n  vec3 sn=nrHyb(sp,crv,ef);\r\n  float sh=softShadow(sp,lp,16.);\r\n  float ao=cao(sp,sn);\r\n  vec3 ld=lp-sp;\r\n  float lDist=max(length(ld),.0001);\r\n  ld/=lDist;\r\n  float atten=1./(1.+lDist*.25+lDist*lDist*.025);\r\n  const float tSize0=1./1.;\r\n  vec3 tx=palette(rd.z+uTime*.4);\r\n  tx=tx*.5+smoothstep(.02,.8,tx)*1.;\r\n  float gr=dot(tx,vec3(.299,.587,.114));\r\n  if(svObjID==TUN)tx*=vec3(1);\r\n  else if(svObjID==ROD)tx=(gr*.5+.5)*vec3(1);\r\n  else if(svObjID==BLT)tx=(tx*.5+.5)*vec3(1.4,.7,.05);\r\n  float dif=max(dot(ld,sn),0.);\r\n  float spe=pow(max(dot(reflect(rd,sn),ld),0.),64.);\r\n  float Schlick=pow(1.-max(dot(rd,normalize(rd+ld)),0.),5.);\r\n  Schlick=mix(.5,1.,Schlick);\r\n  if(svObjID!=TUN)\r\n  dif=(pow(dif,4.)*.5+pow(dif,8.)*.5)*3.;\r\n  vec3 ref=reflect(rd,sn);\r\n  float rt=refTrace(sp+ref*.1,ref);\r\n  vObj=objMin(vec2(vObjID.x,TUN),vec2(vObjID.y,BLT));\r\n  vObj=objMin(vObj,vec2(vObjID.z,ROD));\r\n  svObjID2=vObj.y;\r\n  float crv2=1.;\r\n  vec3 rsp=sp+ref*rt;\r\n  vec3 rsn=nrRef(rsp,crv2,ef);\r\n  vec3 rCol=palette(u.x+uTime*.4);\r\n  rCol=smoothstep(.02,.8,rCol)*2.;\r\n  gr=dot(rCol,vec3(.299,.587,.114));\r\n  if(svObjID2==TUN)rCol*=vec3(1);\r\n  else if(svObjID2==ROD)rCol=(gr*.5+.5)*vec3(1);\r\n  else if(svObjID2==BLT)rCol=(rCol*.5+.5)*vec3(1.4,.7,.05);\r\n  float rDiff=max(dot(rsn,normalize(lp-rsp)),0.);\r\n  float rSpec=pow(max(dot(reflect(ref,rsn),normalize(lp-rsp)),0.),8.);\r\n  float rlDist=length(lp-rsp);\r\n  if(svObjID2!=TUN)rDiff=(pow(rDiff,4.)*.5+pow(rDiff,8.)*.5)*3.;\r\n  rCol=rCol*(rDiff+.25)+vec3(1.,.6,.2)*rSpec*2.;\r\n  rCol*=1./(1.+rlDist*.25+rlDist*rlDist*.025);\r\n  rCol*=min(crv2*1.5,1.);\r\n  vec3 fc=tx*(dif+ao*.3)+vec3(1,.6,.2)*spe*Schlick*2.;\r\n  if(svObjID!=TUN)fc+=rCol*.5;\r\n  else fc+=rCol*.25;\r\n  fc*=atten*sh*ao;\r\n  fc*=clamp(crv*1.5,0.,1.);\r\n  vec3 bg=vec3(1,.7,.4);\r\n  fc=mix(fc,bg*2.,smoothstep(0.,.95,t/FAR));\r\n  gl_FragColor=vec4(pow(clamp(fc,0.,1.),vec3(1./2.)),1.);\n}",side:n,blending:r,depthWrite:!1,transparent:!0},y=function(){x.uniforms.uTime.value+=.03};return(r,n)=>{const e=a("TresCanvas");return l(),o(e,d(m,{"window-size":"",onLoop:y}),{default:f(()=>[i("TresPerspectiveCamera",v,null,512),n[1]||(n[1]=i("TresAmbientLight",{color:"#ffffff"},null,-1)),n[2]||(n[2]=i("TresDirectionalLight",{position:[100,100,0],intensity:.5,color:"#ffffff"},null,-1)),i("TresMesh",{ref:"quanMeshRef","rotation-x":Math.PI},[n[0]||(n[0]=i("TresPlaneGeometry",{args:[4e3,4e3]},null,-1)),i("TresShaderMaterial",c(s(x)),null,16)],8,p)]),_:1},16)}}});export{m as default};
