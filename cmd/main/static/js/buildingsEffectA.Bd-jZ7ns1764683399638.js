import{P as t}from"./tweakpane.CqZAnw7f1764683399638.js";import{b as o,l as e}from"./pagesShow.vue_vue_type_script_setup_true_lang.BJJ2kmGn1764683399638.js";import{_ as i}from"./@tresjs.CJvYCGUA1764683399638.js";import{B as r}from"./three-custom-shader-material.VhylcSiy1764683399638.js";import{d as a,a3 as l,w as n,G as s,o as u,u as m,ad as d,r as c,e as f,f as p,h as v,m as g}from"./@vue.DjQnunkc1764683399638.js";import{y as C,a6 as y,k as j,ap as h,q as w,an as _}from"./three.BbguFgn81764683399638.js";import"./index.DM693cYN1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";import"./buildingsCustomShaderMaterial.C_BZxytV1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";const b=["object"],x=a({__name:"bModel",props:{model:{},bulidingsColor:{default:"#e523ff"},landColor:{default:"#112233"},topColor:{default:"#ffff00"},opacity:{default:.9},gradient:{type:Boolean,default:!0}},setup(t){const o=t,e=o.model.city;o.model.model.children[0].material=new C({color:"#ffff00"}),e.renderOrder=1001;const a=o.model.land;(()=>{const{geometry:t}=e;t.computeBoundingBox(),t.computeBoundingSphere();const{max:i,min:a}=t.boundingBox;if(e.material.__csm)return;const l=new r({baseMaterial:e.material,vertexShader:"\n\t\tvarying vec4 vPosition;\n\t\tvoid main() {\n\t\t\tvPosition = modelMatrix * vec4(position,1.0);\n\t\t\tcsm_Position = position * vec3(1.0);\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform mat4 modelMatrix;\n\t\tvarying vec4 vPosition;\n\t\tuniform vec3 uMax; \n\t\tuniform vec3 uMin; \n\t\tuniform float uOpacity;  \n\t\tuniform float uBorderWidth; \n\t\tuniform vec3 uLightColor;\n\t\tuniform vec3 uColor;\n\t\tuniform float uCircleTime; \n\t\tuniform float uTime; \n\t\tuniform vec3 uTopColor;\t\t\t\t\t//顶部颜色\n\t\tuniform bool uGradient;\n\t\tvec4 uMax_world;\n\t\tvec4 uMin_world;\n\t\tvoid main() {\n\t\t\t// 转世界坐标\n\t\t\tuMax_world =  modelMatrix * vec4(uMax,1.0);\n\t\t\tuMin_world =  modelMatrix * vec4(uMin,1.0);\n\t\t\tvec3 distColor = uColor;\n\t\t\tfloat residue = uTime - floor(uTime / uCircleTime) * uCircleTime;\n\t\t\tfloat rate = residue / uCircleTime;\n\t\t\tfloat lightOffset = rate * (uMax_world.y - uMin_world.y);\n\n\t\t\tif (uMin_world.y + lightOffset < vPosition.y && uMin_world.y + lightOffset + uBorderWidth > vPosition.y) {\n\t\t\t\tcsm_DiffuseColor = vec4(uLightColor, uOpacity);\n\t\t\t} else {\n\t\t\t\tcsm_DiffuseColor = vec4(distColor, uOpacity);\n\t\t\t}\n\n\t\t\t//根据高度计算颜色\n\t\t\tif(uGradient){\n\t\t\t\tfloat rateHight = (vPosition.y - uMin_world.y) / (uMax_world.y - uMin_world.y); \n\t\t\t\tvec3 outColor = mix(csm_DiffuseColor.xyz, uTopColor, rateHight*2.0);\n\t\t\t\tcsm_DiffuseColor = vec4(outColor, uOpacity);\n\t\t\t}\n    }\n\t\t",silent:!0,uniforms:{uMax:{value:i},uMin:{value:a},uBorderWidth:{value:5},uCircleTime:{value:5},uColor:{value:new j(o.bulidingsColor)},uOpacity:{value:o.opacity},uLightColor:{value:new j("#ffffff")},uTopColor:{value:new j(o.topColor)},uTime:{value:0},uGradient:{value:o.gradient}},depthWrite:!0,depthTest:!0,transparent:!0,side:y});e.material.dispose(),e.material=l})();const{onBeforeRender:d}=i();d(({delta:t})=>{e.material.uniforms.uTime.value+=t}),l(()=>{o.bulidingsColor&&e.material.uniforms.uColor.value.setStyle(o.bulidingsColor),o.landColor&&((t,e)=>{let i;i=Array.isArray(a.material)?a.material:[a.material],i.forEach(t=>{t[e].setStyle(o.landColor),t.side=y})})(0,"color"),o.opacity&&(e.material.uniforms.uOpacity.value=o.opacity)}),n(o,(t,o)=>{e.material.uniforms.uGradient.value=t.gradient});const c=o.model.model.clone();return(t,o)=>(u(),s("primitive",{object:m(c)},null,8,b))}});const M=["object"],T=a({__name:"bLine",props:{builds:{},color:{default:"#FFF"},srcColor:{default:"#000"},scale:{default:2e3},gradual:{default:10},speed:{default:.5}},setup(t){const o=t;let e=null;const r={transparent:!0,uniforms:{uColor:{value:new j(o.color)},uSrcColor:{value:new j(o.srcColor)},uScale:{value:o.scale},uTime:{value:0},uGradual:{value:o.gradual}},vertexShader:"varying vec3 vPosition;\r\nvoid main(){\r\n\tvPosition=position;\r\n\tvec4 viewPosition=modelViewMatrix*vec4(position,1.);\r\n\tgl_Position=projectionMatrix*viewPosition;\r\n}",fragmentShader:"uniform float uScale;\nuniform float uGradual;\nuniform float uTime;\r\nuniform vec3 uColor;\nuniform vec3 uSrcColor;\nvarying vec3 vPosition;\n\nvoid main(){\r\n\tfloat dis=distance(vPosition.xz,vec2(.0,.0));\r\n\tif(dis>uScale){\r\n\t\tdiscard;\r\n\t}\r\n\tfloat opacity=smoothstep(uScale/uGradual*uTime,uScale*uTime,dis);\r\n\topacity*=step(dis,uScale*uTime);\r\n\t\r\n\tif(opacity<.3){\r\n\t\tgl_FragColor=vec4(uSrcColor,1.-opacity);\r\n\t}else{\r\n\t\tgl_FragColor=vec4(uColor,opacity);\r\n\t}\r\n\t\n}"};let a=new h(o.builds.geometry).clone();a=a.applyMatrix4(o.builds.matrix);const n=new w(r);e=new _(a,n),e.material.linewidth=o.width,e.renderOrder=1e3,l(()=>{o.color&&(r.uniforms.uColor.value=new j(o.color)),o.srcColor&&(r.uniforms.uSrcColor.value=new j(o.srcColor)),o.scale&&(r.uniforms.uScale.value=o.scale),o.gradual&&(r.uniforms.uGradual.value=o.gradual)});const{onBeforeRender:d}=i();return d(({delta:t})=>{r.uniforms.uTime.value+=t*o.speed,r.uniforms.uTime.value%=1}),(t,o)=>(u(),s("primitive",{object:m(e)},null,8,M))}}),S=a({__name:"buildingsEffectA",async setup(i){let r,a;const l=([r,a]=d(()=>e()),r=await r,a(),r),n=c({color:"#FFF",srcColor:"#000",scale:2e3,gradual:6.6,speed:.3}),s=new t({title:"效果参数",expanded:!0});return s.addBinding(n,"srcColor",{label:"线原颜色"}),s.addBinding(n,"color",{label:"线扫颜色"}),s.addBinding(n,"speed",{label:"速度",min:.1,max:1,step:.1}),s.addBinding(n,"scale",{label:"最大扩散",min:10,max:2e3,step:10}),s.addBinding(n,"gradual",{label:"扩散系数",min:1.1,max:10,step:.1}),(t,e)=>(u(),f(o,{showAxesHelper:!1,autoRotate:!1,showBuildings:!1},{ability:p(()=>[v(x,{model:m(l),bulidingsColor:"#000000",landColor:"#112233",topColor:"#999"},null,8,["model"]),v(T,g({builds:m(l).city},n),null,16,["builds"])]),_:1}))}});export{S as default};
