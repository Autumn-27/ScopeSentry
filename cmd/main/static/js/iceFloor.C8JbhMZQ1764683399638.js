import{K as r}from"./@tresjs.CJvYCGUA1764683399638.js";import{P as a}from"./tweakpane.CqZAnw7f1764683399638.js";import"./index.DM693cYN1764683399638.js";import{u as e}from"./useTexture.RJnyBWqC1764683399638.js";import{d as n,ad as t,w as o,G as l,o as i,I as s,u as c,r as u,b as p,e as m,f as v,h as d,ah as x,a9 as f,aa as g,m as C}from"./@vue.DjQnunkc1764683399638.js";import{as as j,aE as k,r as h,az as T,k as w,bK as P}from"./three.BbguFgn81764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";const b=["rotate-x"],S=["vertexShader","fragmentShader"],y=n({__name:"iceFloor",props:{uParallaxDistance:{default:1},uTintColor:{default:"#666666"},uTintStrength:{default:.1},uStyle:{default:1}},async setup(r){let a,n;const u=r,p=Array.from({length:7},(r,a)=>`./plugins/water/images/textures/${a+1}.png`);p.push("./plugins/water/images/textures/super-perlin.png");const m=([a,n]=t(()=>e(p)),a=await a,n(),a);m.forEach(r=>{r.colorSpace=j,r.wrapS=k,r.wrapT=k,r.magFilter=h,r.minFilter=T});const v={uTrailMap:{value:null},uCracksMap:new P(m[u.uStyle]),uPerlin:new P(m[7]),uParallaxDistance:{value:u.uParallaxDistance},uTintColor:{value:new w(u.uTintColor)},uTintStrength:{value:u.uTintStrength}};return o(()=>[u.uParallaxDistance,u.uTintColor,u.uTintStrength,u.uStyle],([r,a,e,n])=>{v.uParallaxDistance.value=r,v.uTintColor.value.set(a),v.uTintStrength.value=e,v.uCracksMap.value=m[n]}),(r,a)=>(i(),l("TresGroup",null,[s("TresMesh",{"rotate-x":-Math.PI/2},[a[0]||(a[0]=s("TresPlaneGeometry",{args:[40,40]},null,-1)),s("TresShaderMaterial",{vertexShader:c("uniform float uParallaxDistance;\n\nvarying vec2 vParallax;\r\nvarying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n\n  vec3 pos = position;\r\n  vec4 wPos = modelMatrix * vec4(pos, 1.0);\n\n  mat3 tbn = mat3(vec3(1.,0,0), vec3(0,0.,-1.), vec3(0.,1.,0.));\r\n  tbn = transpose(tbn);\n\n  vec3 viewDir = normalize(wPos.xyz - cameraPosition);\r\n  vec3 tbnViewDir = tbn * viewDir;\n\n  vParallax = tbnViewDir.xy;\r\n  vParallax *= uParallaxDistance / dot(-tbnViewDir, vec3(0.0,0.0,1.0));\n\n  gl_Position = projectionMatrix * viewMatrix * wPos;\n\n}"),fragmentShader:c("uniform sampler2D uCracksMap;\r\nuniform sampler2D uTrailMap;\r\nuniform sampler2D uPerlin;\r\nuniform vec3 uTintColor;   \nuniform float uTintStrength; \n\nvarying vec2 vParallax;\r\nvarying vec2 vUv;\n\nvoid main() {\n\n  float perlin = texture(uPerlin, vUv).r;\r\n  float perlin2 = texture(uPerlin, vUv * 10.).r;\r\n  vec3 trail = texture(uTrailMap, vUv).rgb;\r\n  float cracks = texture(uCracksMap, vUv * 4.).r;\r\n  float nomalization = 1.0;\n\n  vec3 colorBlue = vec3(0.0,0.2,0.25);\r\n  vec3 colorDeepBlue = vec3(0.0,0.01,0.03);\r\n  vec3 colorGreen = vec3(0.1,0.2,0.35);\n\n  float accumulateFrosted = 0.;\n\n  for (int i = 0; i < 50; i++) {\r\n    float aplitude = float(70 - i) / 1.;\r\n    vec2 uv = vUv * 4. + vParallax * 0.002 * float(i + 1);\n\n    float currCrack = (1. - texture(uCracksMap, uv ).r) * aplitude;\n\n    float currTrail = texture(uTrailMap, vUv + vParallax * 0.0025 * float(i + 1)).r;\n\n    currCrack = currCrack * step(0.7, 1. - pow(currTrail,0.7));\n\n    cracks += currCrack;\r\n    nomalization += aplitude;\n\n    accumulateFrosted += currTrail * aplitude;\r\n  }\r\n  cracks /= nomalization;\r\n  accumulateFrosted /= nomalization;\r\n  cracks += pow(1. - texture(uCracksMap, vUv * 4.).r, 3.) * 3. * step(0.92, 1. - pow(trail.r,0.6));\r\n  \r\n  vec3 cracksParallax = texture(uCracksMap, vUv * 2. + vParallax * 0.1).rgb;\n\n  vec3 frosted = colorBlue * 3. + perlin * 0.6 + perlin2 * 0.6;\r\n  vec3 cracksColor = mix(colorBlue, colorGreen, pow(cracks,1.) * 1.);\r\n  cracksColor += pow(cracks,1.) * 2.;\r\n  cracksColor *= perlin * 8. * colorBlue;\r\n  cracksColor += pow(cracks,1.) * 0.5;\n\n  vec3 prxCracksColor = mix(colorDeepBlue, colorBlue, pow(1. - cracksParallax.r,3.) * 10.);\r\n  prxCracksColor *= perlin;\r\n  \r\n  cracksColor = mix(cracksColor, prxCracksColor, 0.3);\n\n  vec3 deepColor = mix(vec3(0.1,0.7,0.7),vec3(0., 0.3, 1.), 1. - pow(accumulateFrosted,1.5));\r\n  cracksColor = mix(cracksColor, deepColor, pow(accumulateFrosted,1.5));\r\n  vec3 color = mix(cracksColor, frosted, pow(trail.r,0.5) );\n\n  \n  color = mix(color, uTintColor, uTintStrength);\n\n  vec2 uvCentered = vUv - 0.5;\r\n  float dist = length(uvCentered * 2.0); \n  float edgeFade = smoothstep(0.6, 1.0, dist); \n\n  float alpha = mix(1.0, 0.0, edgeFade);\n\n  if (alpha < 0.01) discard;\n\n  gl_FragColor = vec4(color, alpha);\r\n\n  #include <tonemapping_fragment>\r\n  #include <colorspace_fragment>\r\n}"),transparent:"",uniforms:v},null,8,S)],8,b)]))}}),D=n({__name:"iceFloor",setup(e){const n={clearColor:"#010A13",antialias:!0},t=u({uParallaxDistance:1,uTintColor:"#666666",uTintStrength:.1,uStyle:1}),o=new a;return o.addBinding(t,"uTintColor",{label:"偏色"}),o.addBinding(t,"uTintStrength",{label:"偏色强度",min:0,max:1,step:.01}),o.addBinding(t,"uParallaxDistance",{label:"视觉差强度",min:.01,max:2,step:.01}),o.addBinding(t,"uStyle",{label:"纹理样式",options:{"样式1":0,"样式2":1,"样式3":2,"样式4":3,"样式5":4,"样式6":5,"样式7":6}}),(a,e)=>{const o=p("TresCanvas");return i(),m(o,C(n,{"window-size":""}),{default:v(()=>[e[0]||(e[0]=s("TresPerspectiveCamera",{position:[4,8,8],fov:60,near:.1},null,-1)),e[1]||(e[1]=s("TresAmbientLight",{intensity:1},null,-1)),d(c(r)),(i(),m(x,null,{default:v(()=>[d(y,f(g(t)),null,16)]),_:1}))]),_:1},16)}}});export{D as default};
