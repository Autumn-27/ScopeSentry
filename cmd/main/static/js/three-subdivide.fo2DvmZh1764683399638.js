import{i as t,V as e,x as o,j as r}from"./three.BbguFgn81764683399638.js";
/**
 * @description Loop Subdivision Surface
 * @about       Smooth subdivision surface modifier for use with three.js BufferGeometry.
 * @author      Stephens Nunnally <@stevinz>
 * @license     MIT - Copyright (c) 2022 Stephens Nunnally
 * @source      https://github.com/stevinz/three-subdivide
 */
const i=new e,n=new e,s=new e,u=new e,a=new e,c=new e,f=new e,d=new e,l=new e,p=new e,m=new e,h=[new e,new e,new e],b=[new e,new e,new e],v=new o;class g{static modify(t,e=1,o={}){if(arguments.length>3&&console.warn("LoopSubdivision.modify() now uses a parameter object. See readme for more info!"),"object"!=typeof o&&(o={}),void 0===o.split&&(o.split=!0),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),void 0===o.flatOnly&&(o.flatOnly=!1),void 0===o.maxTriangles&&(o.maxTriangles=1/0),void 0===o.weight&&(o.weight=1),!isNaN(o.weight)&&isFinite(o.weight)||(o.weight=1),o.weight=Math.max(0,Math.min(1,o.weight)),!E(t))return t;let r=t.clone();if(o.split){const t=g.edgeSplit(r);r.dispose(),r=t}for(let i=0;i<e;i++){if(r.attributes.position.count/3<o.maxTriangles){let t;t=o.flatOnly?g.flat(r,o):g.smooth(r,o),r.groups.forEach(e=>{t.addGroup(4*e.start,4*e.count,e.materialIndex)}),r.dispose(),r=t}}return r}static edgeSplit(e){if(!E(e))return e;const o=null!==e.index?e.toNonIndexed():e.clone(),i=new t,a=x(o),l=o.attributes.position.count,p=o.getAttribute("position"),m=o.getAttribute("normal"),h={},b=[],g={},w=[];for(let t=0;t<l;t+=3){c.fromBufferAttribute(p,t+0),f.fromBufferAttribute(p,t+1),d.fromBufferAttribute(p,t+2),u.fromBufferAttribute(m,t);const e=A(c),o=A(f),r=A(d),i=v.set(c,f,d).getArea();if(w.push(!S(i,0)),!w[t/3]){b.push([]);continue}$(u,c,f,d);const n=A(u),s=[`${e}_${o}_${n}`,`${o}_${e}_${n}`,`${o}_${r}_${n}`,`${r}_${o}_${n}`,`${r}_${e}_${n}`,`${e}_${r}_${n}`],a=t/3;for(let t=0;t<s.length;t++)h[s[t]]||(h[s[t]]=[]),h[s[t]].push(a),g[s[t]]||(0!==t&&1!==t||(g[s[t]]=c.distanceTo(f)),2!==t&&3!==t||(g[s[t]]=f.distanceTo(d)),4!==t&&5!==t||(g[s[t]]=d.distanceTo(c)));b.push([s[0],s[2],s[4]])}a.forEach(t=>{const e=o.getAttribute(t);if(!e)return;const n=B(e,t);i.setAttribute(t,new r(n,e.itemSize))});const y=o.morphAttributes;for(const t in y){const e=[],o=y[t];for(let i=0,n=o.length;i<n;i++){if(o[i].count!==l)continue;const n=B(o[i],t,!0);e.push(new r(n,o[i].itemSize))}i.morphAttributes[t]=e}return i.morphTargetsRelative=o.morphTargetsRelative,o.dispose(),i;function B(t,e,r=!1){const u=l*t.itemSize*4,a=new t.array.constructor(u),p="position"===e&&!r&&o.groups.length>0;let m,v,S=0,y=0,A=t.itemSize;for(let x=0;x<l;x+=3){if(!w[x/3]){y+=3;continue}c.fromBufferAttribute(t,x+0),f.fromBufferAttribute(t,x+1),d.fromBufferAttribute(t,x+2);const e=x/3,r=b[e][0],u=b[e][1],l=b[e][2],B=h[r].length,$=h[u].length,E=h[l].length,T=3*S/A/3;if(0===B+$+E-3)z(a,S,A,c,f,d),S+=3*A;else{const t=g[r],e=g[u],o=g[l];(t>e||$<=1)&&(t>o||E<=1)&&B>1?(n.copy(c).add(f).divideScalar(2),E>1?(s.copy(d).add(c).divideScalar(2),z(a,S,A,c,n,s),S+=3*A,z(a,S,A,n,d,s),S+=3*A):(z(a,S,A,c,n,d),S+=3*A),$>1?(s.copy(f).add(d).divideScalar(2),z(a,S,A,n,f,s),S+=3*A,z(a,S,A,s,d,n),S+=3*A):(z(a,S,A,f,d,n),S+=3*A)):(e>o||E<=1)&&$>1?(n.copy(f).add(d).divideScalar(2),B>1?(s.copy(c).add(f).divideScalar(2),z(a,S,A,n,s,f),S+=3*A,z(a,S,A,s,n,c),S+=3*A):(z(a,S,A,f,n,c),S+=3*A),E>1?(s.copy(d).add(c).divideScalar(2),z(a,S,A,n,d,s),S+=3*A,z(a,S,A,s,c,n),S+=3*A):(z(a,S,A,d,c,n),S+=3*A)):E>1?(n.copy(d).add(c).divideScalar(2),$>1?(s.copy(f).add(d).divideScalar(2),z(a,S,A,d,n,s),S+=3*A,z(a,S,A,n,f,s),S+=3*A):(z(a,S,A,d,n,f),S+=3*A),B>1?(s.copy(c).add(f).divideScalar(2),z(a,S,A,c,s,n),S+=3*A,z(a,S,A,s,f,n),S+=3*A):(z(a,S,A,c,f,n),S+=3*A)):(z(a,S,A,c,f,d),S+=3*A)}p&&o.groups.forEach(t=>{t.start===x-y&&(void 0!==m&&void 0!==v&&i.addGroup(m,T-m,v),m=T,v=t.materialIndex)}),y=0}const B=3*S/A,$=new t.array.constructor(B);for(let o=0;o<B;o++)$[o]=a[o];return p&&void 0!==m&&void 0!==v&&i.addGroup(m,3*S/A/3-m,v),$}}static flat(e,o={}){if(!E(e))return e;const r=null!==e.index?e.toNonIndexed():e.clone(),i=new t,n=x(r),s=r.attributes.position.count;n.forEach(t=>{const e=r.getAttribute(t);e&&i.setAttribute(t,g.flatAttribute(e,s,o))});const u=r.morphAttributes;for(const t in u){const e=[],r=u[t];for(let t=0,i=r.length;t<i;t++)r[t].count===s&&e.push(g.flatAttribute(r[t],s,o));i.morphAttributes[t]=e}return i.morphTargetsRelative=r.morphTargetsRelative,r.dispose(),i}static flatAttribute(t,e,o={}){const i=e*t.itemSize*4,n=new t.array.constructor(i);let s=0,u=t.itemSize;for(let r=0;r<e;r+=3)c.fromBufferAttribute(t,r+0),f.fromBufferAttribute(t,r+1),d.fromBufferAttribute(t,r+2),l.copy(c).add(f).divideScalar(2),p.copy(f).add(d).divideScalar(2),m.copy(d).add(c).divideScalar(2),z(n,s,u,c,l,m),s+=3*u,z(n,s,u,f,p,l),s+=3*u,z(n,s,u,d,m,p),s+=3*u,z(n,s,u,l,p,m),s+=3*u;return new r(n,t.itemSize)}static smooth(e,o={}){if("object"!=typeof o&&(o={}),void 0===o.uvSmooth&&(o.uvSmooth=!1),void 0===o.preserveEdges&&(o.preserveEdges=!1),!E(e))return e;const n=null!==e.index?e.toNonIndexed():e.clone(),s=g.flat(n,o),u=new t,c=x(n),f=n.attributes.position.count,d=n.getAttribute("position"),v=s.getAttribute("position"),w={},S={},y={},$={};function T(t,e,o){S[t]||(S[t]={}),S[t][e]||(S[t][e]=[]),S[t][e].push(o)}function _(t,e){y[t]||(y[t]=[]),y[t].push(e)}function j(t,e){$[t]||($[t]=new Set),$[t].add(e)}for(let t=0;t<f;t+=3){const e=A(b[0].fromBufferAttribute(d,t+0)),o=A(b[1].fromBufferAttribute(d,t+1)),r=A(b[2].fromBufferAttribute(d,t+2));T(e,o,t+1),T(e,r,t+2),T(o,e,t+0),T(o,r,t+2),T(r,e,t+0),T(r,o,t+1),l.copy(b[0]).add(b[1]).divideScalar(2),p.copy(b[1]).add(b[2]).divideScalar(2),m.copy(b[2]).add(b[0]).divideScalar(2);const i=A(l),n=A(p),s=A(m);_(i,t+2),_(n,t+0),_(s,t+1),j(e,i),j(e,s),j(o,i),j(o,n),j(r,n),j(r,s)}for(let t=0;t<s.attributes.position.count;t++){const e=A(a.fromBufferAttribute(v,t));w[e]||(w[e]=[]),w[e].push(t)}c.forEach(t=>{const e=n.getAttribute(t),o=s.getAttribute(t);if(void 0===e||void 0===o)return;const i=I(t,e,o);u.setAttribute(t,new r(i,o.itemSize))});const G=n.morphAttributes;for(const t in G){const e=[],i=G[t];for(let n=0,s=i.length;n<s;n++){if(i[n].count!==f)continue;const s=i[n],u=g.flatAttribute(i[n],i[n].count,o),a=I(t,s,u);e.push(new r(a,u.itemSize))}u.morphAttributes[t]=e}return u.morphTargetsRelative=n.morphTargetsRelative,s.dispose(),n.dispose(),u;function I(t,e,r){const n=s.attributes.position.count*r.itemSize,u=new e.array.constructor(n);let c=0;for(let f=0;f<s.attributes.position.count;f+=3){for(let n=0;n<3;n++)if("uv"!==t||o.uvSmooth)if("normal"===t){h[n].fromBufferAttribute(v,f+n);const t=A(h[n]),e=w[t],o=Object.keys(e).length,s=.75/o,u=1-s*o;b[n].fromBufferAttribute(r,f+n),b[n].multiplyScalar(u),e.forEach(t=>{i.fromBufferAttribute(r,t),i.multiplyScalar(s),b[n].add(i)})}else{b[n].fromBufferAttribute(r,f+n),h[n].fromBufferAttribute(v,f+n);const t=A(h[n]),s=S[t],u=y[t];if(s){if(o.preserveEdges){const e=$[t];let o=!0;for(const t of e)y[t].length%2!=0&&(o=!1);if(!o)continue}const r=Object.keys(s).length,u=B(1/r/r,1/r*(5/8-Math.pow(3/8+1/4*Math.cos(2*Math.PI/r),2)),o.weight),c=1-u*r;b[n].multiplyScalar(c);for(let t in s){const o=s[t];i.set(0,0,0);for(let t=0;t<o.length;t++)i.add(a.fromBufferAttribute(e,o[t]));i.divideScalar(o.length),i.multiplyScalar(u),b[n].add(i)}}else if(u&&2===u.length){const t=u.length,o=.125,r=1-o*t;b[n].multiplyScalar(r),u.forEach(t=>{i.fromBufferAttribute(e,t),i.multiplyScalar(o),b[n].add(i)})}}else b[n].fromBufferAttribute(r,f+n);z(u,c,r.itemSize,b[0],b[1],b[2]),c+=3*r.itemSize}return u}}}const w=Math.pow(10,2);function S(t,e,o=1e-5){return t<e+o&&t>e-o}function y(t,e=w){let o=(r=t*e)+(r>0?.5:-.5)|0;var r;return 0==o&&(o=0),`${o}`}function A(t,e=w){return`${y(t.x,e)},${y(t.y,e)},${y(t.z,e)}`}function B(t,e,o){return(1-o)*t+o*e}function $(t,e,o,r){a.subVectors(e,o),t.subVectors(o,r),t.cross(a).normalize()}function x(t){const e=Object.keys(t.attributes);return Array.from(new Set(["position","normal","uv"].concat(e)))}function z(t,e,o,r,i,n){o>=1&&(t[e+0+0*o]=r.x,t[e+0+1*o]=i.x,t[e+0+2*o]=n.x),o>=2&&(t[e+1+0*o]=r.y,t[e+1+1*o]=i.y,t[e+1+2*o]=n.y),o>=3&&(t[e+2+0*o]=r.z,t[e+2+1*o]=i.z,t[e+2+2*o]=n.z),o>=4&&(t[e+3+0*o]=r.w,t[e+3+1*o]=i.w,t[e+3+2*o]=n.w)}function E(t){return void 0===t?(console.warn("LoopSubdivision: Geometry provided is undefined"),!1):t.isBufferGeometry?void 0===t.attributes.position?(console.warn("LoopSubdivision: Geometry provided missing required 'position' attribute"),!1):(void 0===t.attributes.normal&&t.computeVertexNormals(),!0):(console.warn("LoopSubdivision: Geometry provided is not 'BufferGeometry' type"),!1)}export{g as L};
