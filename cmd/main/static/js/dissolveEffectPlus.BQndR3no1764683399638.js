import{o as e,F as t,_ as n,K as o}from"./@tresjs.CJvYCGUA1764683399638.js";import"./lamina.DDkSGhRq1764683399638.js";import"./three-custom-shader-material.VhylcSiy1764683399638.js";import"./index.DM693cYN1764683399638.js";import{_ as r}from"./skyBoxDmesh.vue_vue_type_script_setup_true_lang.DJ20Ont71764683399638.js";import{P as a}from"./tweakpane.CqZAnw7f1764683399638.js";import{d as s,w as i,e as l,o as u,u as p,ad as d,G as c,I as m,h as v,m as g,ah as f,f as x,a3 as y,r as w,b as h,a9 as A,aa as P}from"./@vue.DjQnunkc1764683399638.js";import{ar as j,k as b,a6 as z,i as C,bJ as _,j as D,V as F,dm as E,cR as M,cS as S,d as q,cT as k,a0 as B}from"./three.BbguFgn81764683399638.js";import{u as T}from"./utils.Dayf5snU1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./glsl-tokenizer.Cy5Jb2X41764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./glsl-token-descope.B2bFv_j_1764683399638.js";import"./glsl-token-depth.Duvdnvlt1764683399638.js";import"./glsl-token-scope.BdCfdvWe1764683399638.js";import"./glsl-token-properties.DKXemF9b1764683399638.js";import"./glsl-token-assignments.Ctx_yUgS1764683399638.js";import"./glsl-token-string.DDqeLsrr1764683399638.js";import"./glsl-token-functions.DTY1u6bV1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";var N="vec4 permute(vec4 x) {\r\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\r\n}\r\nvec4 taylorInvSqrt(vec4 r) {\r\n    return 1.79284291400159 - 0.85373472095314 * r;\r\n}\n\nfloat snoise(vec3 v) {\r\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\r\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    \n    vec3 i = floor(v + dot(v, C.yyy));\r\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    \n    vec3 g = step(x0.yzx, x0.xyz);\r\n    vec3 l = 1.0 - g;\r\n    vec3 i1 = min(g.xyz, l.zxy);\r\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    \n    i = mod(i, 289.0);\r\n    vec4 p = permute(permute(permute(\r\n                    i.z + vec4(0.0, i1.z, i2.z, 1.0))\r\n                    + i.y + vec4(0.0, i1.y, i2.y, 1.0))\r\n                + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    \n    \n    float n_ = 1.0 / 7.0; \n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \n\n    vec4 x_ = floor(j * ns.z);\r\n    vec4 y_ = floor(j - 7.0 * x_); \n\n    vec4 x = x_ * ns.x + ns.yyyy;\r\n    vec4 y = y_ * ns.x + ns.yyyy;\r\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\r\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\r\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\r\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\r\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\r\n    vec3 p1 = vec3(a0.zw, h.y);\r\n    vec3 p2 = vec3(a1.xy, h.z);\r\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\r\n    p0 *= norm.x;\r\n    p1 *= norm.y;\r\n    p2 *= norm.z;\r\n    p3 *= norm.w;\n\n    \n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\r\n    m = m * m;\r\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\r\n                dot(p2, x2), dot(p3, x3)));\r\n}";const K=s({__name:"material",props:{baseMaterial:{default:new j},uEdgeColor:{default:"#4d9bff"},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2}},setup(t){const n=t,o={uEdgeColor:{value:new b(n.uEdgeColor)},uFreq:{value:n.uFreq},uAmp:{value:n.uAmp},uProgress:{value:n.uProgress},uEdge:{value:n.uEdge}},r=`\n  varying vec3 vPos;\n\n  uniform float uFreq;\n  uniform float uAmp;\n  uniform float uProgress;\n  uniform float uEdge;\n  uniform vec3 uEdgeColor;\n\n  ${N}\n\n\tvoid main() {\n\t\tfloat noise = snoise(vPos * uFreq) * uAmp; // calculate snoise in fragment shader for smooth dissolve edges\n\n    if(noise < uProgress) discard; // discard any fragment where noise is lower than progress\n\n    float edgeWidth = uProgress + uEdge;\n\n    if(noise > uProgress && noise < edgeWidth){\n        csm_DiffuseColor = vec4(vec3(uEdgeColor),noise); // colors the edge\n    }else{\n\t\t\t\tcsm_DiffuseColor = vec4(csm_DiffuseColor.xyz,1.0);\n\t\t}\n\t}\n`;return i(()=>[n.uEdgeColor,n.uEdge,n.uFreq,n.uAmp,n.uProgress],([e,t,n,r,a])=>{o.uEdgeColor.value.setStyle(e),o.uEdge.value=t,o.uFreq.value=n,o.uAmp.value=r,o.uProgress.value=a}),(n,a)=>(u(),l(p(e),{baseMaterial:t.baseMaterial,vertexShader:"\n\tvarying vec3 vPos;\n\tvoid main() {\n\t\tvPos = position;\n\t}\n",side:z,fragmentShader:r,uniforms:o},null,8,["baseMaterial","side"]))}}),$=["geometry"],I=["blending"],R=s({__name:"particlesPoints",props:{geo:{default:new C},uEdge:{default:6},uFreq:{default:.41},uAmp:{default:20},uProgress:{default:-2},uColor:{default:"#4d9bff"},uPointSize:{default:200},particleData:{default:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}},async setup(e){let o,r;const a=e,s=a.geo.clone(),l=([o,r]=d(()=>T("./plugins/industry4/image/particle.png")),o=await o,r(),o);let v,g,f,x,y,w,h=s.attributes.position.count;!function(e){h=e.attributes.position.count,v=new Float32Array(h),g=new Float32Array(e.getAttribute("position").array),f=new Float32Array(e.getAttribute("position").array),x=new Float32Array(3*h),y=new Float32Array(h),w=new Float32Array(h);for(let t=0;t<h;t++){let e=3*t+0,n=3*t+1,o=3*t+2;v[t]=5.5*Math.random()+1.5,x[e]=.5*Math.random()+.5,x[n]=.5*Math.random()+.5,x[o]=.1*Math.random(),y[t]=.001,w[t]=Math.random()*Math.PI*2}e.setAttribute("aOffset",new D(v,1)),e.setAttribute("aCurrentPos",new D(f,3)),e.setAttribute("aVelocity",new D(x,3)),e.setAttribute("aDist",new D(y,1)),e.setAttribute("aAngle",new D(w,1))}(s);const{renderer:A}=t(),P={uTexture:{value:l},uPixelDensity:{value:A.getPixelRatio()},uProgress:{value:a.uProgress},uEdge:{value:a.uEdge},uAmp:{value:a.uAmp},uFreq:{value:a.uFreq},uBaseSize:{value:a.uPointSize},uColor:{value:new b(a.uColor)}},j=`\n    ${N}\n    uniform float uPixelDensity;\n    uniform float uBaseSize;\n    uniform float uFreq;\n    uniform float uAmp;\n    uniform float uEdge;\n    uniform float uProgress;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    attribute vec3 aCurrentPos;\n    attribute float aDist;\n    attribute float aAngle;\n\n    void main() {\n        vec3 pos = position;\n\n        float noise = snoise(pos * uFreq) * uAmp;\n        vNoise =noise;\n\n        vAngle = aAngle;\n\n        if( vNoise > uProgress-2.0 && vNoise < uProgress + uEdge+2.0){\n            pos = aCurrentPos;\n        }\n\n        vec4 modelPosition = modelMatrix * vec4(pos, 1.0);\n        vec4 viewPosition = viewMatrix * modelPosition;\n        vec4 projectedPosition = projectionMatrix * viewPosition;\n        gl_Position = projectedPosition;\n\n        float size = uBaseSize * uPixelDensity;\n        size = size  / (aDist + 1.0);\n        gl_PointSize = size / -viewPosition.z;\n}\n`;function z(e){let t=x[3*e+0],n=x[3*e+1],o=x[3*e+2];t*=a.particleData.velocityFactor.x,n*=a.particleData.velocityFactor.y;let{xwave:r,ywave:s}=function(e){const t=f[3*e+0],n=f[3*e+1];let o=Math.sin(2*n)*(.8+a.particleData.waveAmplitude),r=Math.sin(2*t)*(.6+a.particleData.waveAmplitude),s=Math.sin(5*n)*(.2+a.particleData.waveAmplitude),i=Math.sin(1*t)*(.9+a.particleData.waveAmplitude),l=Math.sin(8*n)*(.8+a.particleData.waveAmplitude),u=Math.sin(5*t)*(.6+a.particleData.waveAmplitude);return{xwave:o+s+l+Math.sin(3*n)*(.8+a.particleData.waveAmplitude),ywave:r+i+u+Math.sin(7*t)*(.6+a.particleData.waveAmplitude)}}(e);return t+=r,n+=s,t*=Math.abs(a.particleData.particleSpeedFactor),n*=Math.abs(a.particleData.particleSpeedFactor),o*=Math.abs(a.particleData.particleSpeedFactor),{vx:t,vy:n,vz:o}}const{onBeforeRender:C}=n();return C(()=>{!function(){for(let e=0;e<h;e++){let t=3*e+0,n=3*e+1,o=3*e+2,{vx:r,vy:a,vz:s}=z(e);f[t]+=r,f[n]+=a,f[o]+=s;const i=new F(g[t],g[n],g[o]),l=new F(f[t],f[n],f[o]),u=i.distanceTo(l);y[e]=u,w[e]+=.01,u>v[e]&&(f[t]=g[t],f[n]=g[n],f[o]=g[o])}s.setAttribute("aOffset",new D(v,1)),s.setAttribute("aCurrentPos",new D(f,3)),s.setAttribute("aVelocity",new D(x,3)),s.setAttribute("aDist",new D(y,1)),s.setAttribute("aAngle",new D(w,1))}()}),i(()=>[a.uColor,a.uEdge,a.uFreq,a.uAmp,a.uProgress,a.uPointSize],([e,t,n,o,r,a])=>{P.uColor.value.setStyle(e),P.uEdge.value=t,P.uFreq.value=n,P.uAmp.value=o,P.uProgress.value=r,P.uBaseSize.value=a}),(e,t)=>(u(),c("TresPoints",{geometry:p(s)},[m("TresShaderMaterial",{transparent:"",blending:_,uniforms:P,vertexShader:j,fragmentShader:"\n    uniform vec3 uColor;\n    uniform float uEdge;\n    uniform float uProgress;\n    uniform sampler2D uTexture;\n\n    varying float vNoise;\n    varying float vAngle;\n\n    void main(){\n        if( vNoise < uProgress ) discard;\n        if( vNoise > uProgress + uEdge) discard;\n\n        vec2 coord = gl_PointCoord;\n        coord = coord - 0.5; // get the coordinate from 0-1 ot -0.5 to 0.5\n        coord = coord * mat2(cos(vAngle),sin(vAngle) , -sin(vAngle), cos(vAngle)); // apply the rotation transformaion\n        coord = coord +  0.5; // reset the coordinate to 0-1  \n\n        vec4 texture = texture2D(uTexture,coord);\n\n        gl_FragColor = vec4(vec3(uColor.xyz * texture.xyz),1.0);\n    }\n"},null,8,I)],8,$))}}),G=["geometry"],V=s({__name:"torusKnot",setup(e){const t=new E(3,1,64,8,2,3);return(e,n)=>(u(),c("TresGroup",null,[m("TresMesh",{geometry:p(t)},[v(K,g({color:"#636363",metalness:2,roughness:0},e.$attrs),null,16)],8,G),(u(),l(f,null,{default:x(()=>[v(R,g({geo:p(t)},e.$attrs,{uColor:e.$attrs.uEdgeColor}),null,16,["geo","uColor"])]),_:1}))]))}}),J=s({__name:"bloomPass",setup(e){const{camera:o,renderer:r,scene:a,sizes:s}=t(),i=0,l=.216,u=.2;let p=null;y(()=>{s.width.value&&((e,t,n,o,r)=>{const a=new M(e,t),s=new S(new q(o,r),l,u,i);p=new k(n),p.addPass(a),p.addPass(s)})(a.value,o.value,r,s.width.value,s.height.value)});const{onBeforeRender:d}=n();return d(()=>{p&&p.render()}),(e,t)=>null}}),O=s({__name:"dissolveEffectPlus",setup(e){const t={clearColor:"#201919",windowSize:!0,toneMapping:B,toneMappingExposure:.8,renderMode:"manual"},n=w({uEdgeColor:"#ff784d",uEdge:6,uFreq:.41,uAmp:20,uProgress:-4.9,uPointSize:576,particleData:{particleSpeedFactor:.02,velocityFactor:{x:2.5,y:2},waveAmplitude:0}}),s=w({torusKnotColor:"#7a8c87"}),i=new a({title:"参数",expanded:!0});return i.addBinding(s,"torusKnotColor",{label:"torusKnotColor"}),i.addBinding(n,"uEdgeColor",{label:"边缘颜色"}),i.addBinding(n,"uEdge",{label:"边缘宽度",min:0,max:9,step:.01}),i.addBinding(n,"uFreq",{label:"密度",min:.002,max:2,step:.002}),i.addBinding(n,"uAmp",{label:"幅度",min:3,max:22,step:.01}),i.addBinding(n,"uProgress",{label:"进度",min:-25,max:20,step:.1}),i.addBinding(n,"uPointSize",{label:"粒子大小",min:10,max:800,step:5}),i.addBinding(n.particleData,"particleSpeedFactor",{label:"粒子速度",min:1e-4,max:.1,step:1e-4}),i.addBinding(n.particleData,"velocityFactor",{picker:"inline",label:"粒子飘逸方向",expanded:!0,x:{min:-10,max:10,step:.01},y:{min:-10,max:10,step:.01}}),i.addBinding(n.particleData,"waveAmplitude",{label:"粒子扰动幅度",min:0,max:5,step:.01}),(e,a)=>{const i=h("TresCanvas");return u(),l(i,A(P(t)),{default:x(()=>[a[0]||(a[0]=m("TresPerspectiveCamera",{position:[15,15,15],fov:45,near:.1,far:1e4,"look-at":[0,0,0]},null,-1)),v(p(o),{enableDamping:""}),v(V,g(n,{color:s.torusKnotColor}),null,16,["color"]),(u(),l(f,null,{default:x(()=>[v(p(r),{texture:"https://opensource.cdn.icegl.cn/images/skyBox/workshop_blur.jpg"},null,8,["texture"])]),_:1})),v(J)]),_:1},16)}}});export{O as default};
