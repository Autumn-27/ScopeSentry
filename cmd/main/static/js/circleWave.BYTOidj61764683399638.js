import{_ as a,K as e}from"./@tresjs.CJvYCGUA1764683399638.js";import{P as o}from"./tweakpane.CqZAnw7f1764683399638.js";import{_ as n}from"./reflectorDUDV.vue_vue_type_script_setup_true_lang.u89pth7i1764683399638.js";import"./index.DM693cYN1764683399638.js";import{u as t}from"./utils.Dayf5snU1764683399638.js";import{d as r,a as s,ad as i,r as l,a3 as c,G as m,o as u,I as p,a9 as v,aa as f,b as d,e as j,f as g,h as k,u as h,ah as w,m as S}from"./@vue.DjQnunkc1764683399638.js";import{aE as y,k as C,bJ as x,a6 as _}from"./three.BbguFgn81764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./dither.glsl.tNAdkJUa1764683399638.js";import"./Reflector.DiEbG3XV1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";const M=["rotation-x","scale"],T=r({__name:"shaderCircleWave",props:{color:{default:"#ffffff"},colorDark:{default:"#000000"},speed:{default:1},scale:{default:2}},async setup(e){let o,n;const r=e,d=s(),{onBeforeRender:j}=a();j(({delta:a})=>{d.value&&(d.value.material.uniforms.uTime.value+=a*r.speed)});const g=([o,n]=i(()=>t("./plugins/floor/image/scan.png")),o=await o,n(),o);g.wrapS=y,g.wrapT=y;const k=l({side:_,transparent:!0,blending:x,flatShading:!0,depthTest:!1,uniforms:{uTime:{type:"f",value:0},uScanTex:{type:"t",value:g},uScanColor:{type:"v3",value:new C(r.color)},uScanColorDark:{type:"v3",value:new C(r.colorDark)}},vertexShader:"\nvarying vec2 vUv;\nvarying vec3 vPosition;\nvoid main(){\n\tvUv=uv;\n\tvPosition=position;\n\tgl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);\n}\n",fragmentShader:"\n#define uScanOrigin vec3(0.,0.,0.)\n#define uScanWaveRatio1 3.2\n#define uScanWaveRatio2 2.8\n\nuniform float uTime;\nuniform sampler2D uScanTex;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform vec3 uScanColor;\nuniform vec3 uScanColorDark;\n\nfloat circleWave(vec3 p,vec3 origin,float distRatio){\n    float t=uTime;\n    float dist=distance(p,origin)*distRatio;\n    float radialMove=fract(dist-t);\n    float fadeOutMask=1.-smoothstep(1.,3.,dist);\n    radialMove*=fadeOutMask;\n    float cutInitialMask=1.-step(t,dist);\n    radialMove*=cutInitialMask;\n    return radialMove;\n}\n\nvec3 getScanColor(vec3 worldPos,vec2 uv,vec3 col){\n    // mask\n    float scanMask=texture(uScanTex,uv).r;\n    // waves\n    float cw=circleWave(worldPos,uScanOrigin,uScanWaveRatio1);\n    float cw2=circleWave(worldPos,uScanOrigin,uScanWaveRatio2);\n    // scan\n    float mask1=smoothstep(.3,0.,1.-cw);\n    mask1*=(1.+scanMask*.7);\n    \n    float mask2=smoothstep(.07,0.,1.-cw2)*.8;\n    mask1+=mask2;\n    \n    float mask3=smoothstep(.09,0.,1.-cw)*1.5;\n    mask1+=mask3;\n\n    // color\n    vec3 scanCol=mix(uScanColorDark,uScanColor,mask1);\n    col=mix(col,scanCol,mask1);\n    \n    return col;\n\t\t// return vec3(cw);\n\t\t// return vec3(scanMask);\n\t\t// return worldPos;\n\t\t// return vec3(mask1);\n\t\t// return scanCol;\n}\n\nvoid main()\n{\n    vec3 col=vec3(0.);\n    col=getScanColor(vPosition,vUv*10.0,col);\n    gl_FragColor=vec4(col,1.);\n}\n"});return c(()=>{d.value&&(d.value.material.uniforms.uScanColor.value=new C(r.color),d.value.material.uniforms.uScanColorDark.value=new C(r.colorDark))}),(a,e)=>(u(),m("TresMesh",{ref_key:"tmRef",ref:d,"rotation-x":-Math.PI/2,scale:a.scale},[e[0]||(e[0]=p("TresPlaneGeometry",{args:[1,1]},null,-1)),p("TresShaderMaterial",v(f(k)),null,16)],8,M))}}),b=r({__name:"circleWave",setup(a){const t=l({reflectivity:.1,showGridHelper:!1,scale:1}),r=l({color:"#ffffff",colorDark:"#000000",speed:1,scale:2}),s=new o({title:"shaderCircleWave地面",expanded:!0});return s.addBinding(r,"color",{label:"圈颜色"}),s.addBinding(r,"colorDark",{label:"圈渐变色"}),s.addBinding(r,"speed",{label:"速度",min:.1,max:5,step:.1}),s.addBinding(r,"scale",{label:"大小",min:.1,max:10,step:.1}),(a,o)=>{const s=d("TresCanvas");return u(),j(s,{clearColor:"#201919","window-size":""},{default:g(()=>[o[0]||(o[0]=p("TresPerspectiveCamera",{position:[3,3,0],fov:45,near:.1,far:1e4},null,-1)),k(h(e),{enableDamping:""}),o[1]||(o[1]=p("TresAmbientLight",{intensity:6},null,-1)),(u(),j(w,null,{default:g(()=>[k(T,v(f(r)),null,16)]),_:1})),k(n,S({position:[0,-.5,0]},t),null,16)]),_:1})}}});export{b as default};
