import{_ as e,K as o}from"./@tresjs.CJvYCGUA1764683399638.js";import{d as l,r as n,q as i,w as t,G as a,o as r,I as d,V as f,b as s,e as v,f as c,h as m,u,ah as p,m as y}from"./@vue.DjQnunkc1764683399638.js";import{k as g}from"./three.BbguFgn81764683399638.js";import{P as h}from"./tweakpane.CqZAnw7f1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";const C=["rotation-x"],x=["uniforms"],z=l({__name:"rippleFloor",props:{color:{default:"#ffed00"},flySpeed:{default:3},flyIntensity:{default:.3},dotSize:{default:.03},lineColor:{default:"#66f5ff"},floorColor1:{default:"#4c6480"},floorColor2:{default:"#acb4c0"},gridSize:{default:50},lineWidth:{default:.02},paused:{type:Boolean,default:!1}},setup(o){const l=o,f=n({time:{value:0},color1:{value:new g(l.floorColor1)},color2:{value:new g(l.floorColor2)},lineColor:{value:new g(l.lineColor)},flyLineColor:{value:new g(l.lineColor)},gridSize:{value:l.gridSize},lineWidth:{value:l.lineWidth},flySpeed:{value:l.flySpeed},flyIntensity:{value:l.flyIntensity},dotSize:{value:l.dotSize}}),{onBeforeRender:s}=e();let v=0;s(({delta:e})=>{l.paused||(v+=e,f.time.value=v)});const c=()=>{f.color1.value=new g(l.floorColor1),f.color2.value=new g(l.floorColor2),f.lineColor.value=new g(l.lineColor),f.flyLineColor.value=new g(l.lineColor),f.gridSize.value=l.gridSize,f.lineWidth.value=l.lineWidth,f.flySpeed.value=l.flySpeed,f.flyIntensity.value=l.flyIntensity,f.dotSize.value=l.dotSize};return i(()=>{c()}),t(()=>[l.flySpeed,l.flyIntensity,l.dotSize,l.lineColor,l.floorColor1,l.floorColor2,l.gridSize,l.lineWidth],c),(e,o)=>(r(),a("TresMesh",{"rotation-x":-Math.PI/2,position:[0,0,0]},[o[0]||(o[0]=d("TresPlaneGeometry",{args:[10,10]},null,-1)),d("TresShaderMaterial",{uniforms:f,"vertex-shader":"\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n","fragment-shader":"\n    uniform float time;\n    uniform vec3 color1;\n    uniform vec3 color2;\n    uniform vec3 lineColor;\n    uniform vec3 flyLineColor;\n    uniform float gridSize;\n    uniform float lineWidth;\n    uniform float flySpeed;\n    uniform float flyIntensity;\n    uniform float dotSize;\n    varying vec2 vUv;\n    \n    void main() {\n        // 缩放UV以创建网格\n        vec2 scaledUv = vUv * gridSize;\n        \n        // 创建棋盘格图案\n        vec2 cellIndex = floor(scaledUv);\n        float checkValue = mod(cellIndex.x + cellIndex.y, 2.0);\n        vec3 baseColor = (checkValue < 1.0) ? color1 : color2;\n        \n        // 创建基础网格线\n        vec2 gridUv = fract(scaledUv);\n        \n        // 基础垂直线\n        float verticalLine = abs(gridUv.x - 0.5) / fwidth(gridUv.x);\n        float verticalMask = 1.0 - smoothstep(0.0, lineWidth, verticalLine);\n        \n        // 基础水平线\n        float horizontalLine = abs(gridUv.y - 0.5) / fwidth(gridUv.y);\n        float horizontalMask = 1.0 - smoothstep(0.0, lineWidth, horizontalLine);\n        \n        // 组合基础线条\n        float baseLineMask = max(verticalMask, horizontalMask);\n        vec3 colorWithLines = mix(baseColor, lineColor, baseLineMask);\n        \n        // 创建飞线效果\n        // 垂直线飞线\n        float flyVertical = sin(gridUv.y * 6.28 + time * flySpeed) * flyIntensity;\n        float flyVerticalLine = abs(gridUv.x - 0.5 + flyVertical) / fwidth(gridUv.x);\n        float flyVerticalMask = 1.0 - smoothstep(0.0, lineWidth * 0.5, flyVerticalLine);\n        \n        // 水平线飞线\n        float flyHorizontal = sin(gridUv.x * 6.28 + time * flySpeed * 0.7) * flyIntensity;\n        float flyHorizontalLine = abs(gridUv.y - 0.5 + flyHorizontal) / fwidth(gridUv.y);\n        float flyHorizontalMask = 1.0 - smoothstep(0.0, lineWidth * 0.5, flyHorizontalLine);\n        \n        // 组合飞线\n        float flyLineMask = max(flyVerticalMask, flyHorizontalMask);\n        \n        // 添加飞线的发光效果\n        float glowVertical = exp(-flyVerticalLine * 2.0) * 0.3;\n        float glowHorizontal = exp(-flyHorizontalLine * 2.0) * 0.3;\n        float glowMask = max(glowVertical, glowHorizontal);\n        \n        // 创建节点效果 - 在网格正方形的四个顶点\n        float dotRadius = dotSize;\n        float dotFeather = dotSize * 0.3;\n        \n        // 计算到四个顶点的距离\n        vec2 topLeft = vec2(0.0, 0.0);\n        vec2 topRight = vec2(1.0, 0.0);\n        vec2 bottomLeft = vec2(0.0, 1.0);\n        vec2 bottomRight = vec2(1.0, 1.0);\n        \n        float distTopLeft = length(gridUv - topLeft);\n        float distTopRight = length(gridUv - topRight);\n        float distBottomLeft = length(gridUv - bottomLeft);\n        float distBottomRight = length(gridUv - bottomRight);\n        \n        // 找到最近顶点的距离\n        float minDist = min(min(distTopLeft, distTopRight), min(distBottomLeft, distBottomRight));\n        \n        // 在最近顶点附近绘制节点\n        float dotMask = 1.0 - smoothstep(dotRadius - dotFeather, dotRadius + dotFeather, minDist);\n        \n        // 飞线经过节点时的增强效果\n        float nodeGlow = dotMask * flyLineMask * 3.0;\n        \n        // 组合所有效果\n        vec3 finalColor = colorWithLines;\n        \n        // 添加飞线颜色\n        finalColor = mix(finalColor, flyLineColor, flyLineMask);\n        \n        // 添加发光效果\n        finalColor += flyLineColor * glowMask;\n        finalColor += flyLineColor * nodeGlow;\n        \n        // 添加节点 - 使用飞线颜色而不是白色\n        finalColor = mix(finalColor, flyLineColor, dotMask);\n        \n        gl_FragColor = vec4(finalColor, 1.0);\n    }\n",side:2},null,8,x)],8,C))}}),L=l({__name:"rippleFloor",setup(e){const l=n({flySpeed:3,flyIntensity:.3,dotSize:.03,lineColor:"#66f5ff",floorColor1:"#4c6480",floorColor2:"#acb4c0",gridSize:50,lineWidth:.02,paused:!1}),i=new h({title:"飞线效果控制",expanded:!0}),t=i.addFolder({title:"飞线参数",expanded:!0});t.addBinding(l,"flySpeed",{label:"飞线速度",min:0,max:10,step:.1}),t.addBinding(l,"flyIntensity",{label:"飞线强度",min:0,max:1,step:.05}),t.addBinding(l,"dotSize",{label:"节点大小",min:.01,max:.08,step:.005}),t.addBinding(l,"paused",{label:"暂停"});const a=i.addFolder({title:"颜色设置",expanded:!0});a.addBinding(l,"lineColor",{label:"飞线颜色",view:"color"}),a.addBinding(l,"floorColor1",{label:"地板颜色1",view:"color"}),a.addBinding(l,"floorColor2",{label:"地板颜色2",view:"color"});const g=i.addFolder({title:"网格设置",expanded:!0});return g.addBinding(l,"gridSize",{label:"网格大小",min:10,max:100,step:1}),g.addBinding(l,"lineWidth",{label:"线条宽度",min:.01,max:.1,step:.001}),f(()=>{i.dispose()}),(e,n)=>{const i=s("TresCanvas");return r(),v(i,{clearColor:"#282828","window-size":""},{default:c(()=>[n[0]||(n[0]=d("TresPerspectiveCamera",{position:[0,50,150],fov:50,near:.1,far:2e3},null,-1)),m(u(o),{enableDamping:"","damping-factor":.05,"min-distance":20,"max-distance":500,"max-polar-angle":Math.PI/2.1},null,8,["max-polar-angle"]),n[1]||(n[1]=d("TresAmbientLight",{intensity:.8},null,-1)),n[2]||(n[2]=d("TresDirectionalLight",{position:[10,20,5],intensity:.5},null,-1)),(r(),v(p,null,{default:c(()=>[m(z,y(l,{scale:20}),null,16)]),_:1}))]),_:1})}}});export{L as default};
