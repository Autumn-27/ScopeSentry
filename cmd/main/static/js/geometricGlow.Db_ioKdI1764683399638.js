import{K as e}from"./@tresjs.CJvYCGUA1764683399638.js";import{P as r}from"./tweakpane.CqZAnw7f1764683399638.js";import{d as o,w as t,G as i,o as n,I as a,m as l,u as s,r as m,b as u,e as c,f as d,h as v}from"./@vue.DjQnunkc1764683399638.js";import{V as f,k as g,bJ as p,bj as w,dm as C}from"./three.BbguFgn81764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";function y(e,r){if(!e.isBufferGeometry)return void console.error("The geometry must be a BufferGeometry.");e.attributes.normal||e.computeVertexNormals();const o=e.attributes.position,t=e.attributes.normal,i=o.array,n=t.array;for(let a=0;a<o.count;a++){const e=3*a;i[e]+=n[e]*r,i[e+1]+=n[e+1]*r,i[e+2]+=n[e+2]*r}o.needsUpdate=!0}var x="varying vec3 vVertexWorldPosition;\r\nvarying vec3 vVertexNormal;\r\nvarying vec4 vFragColor;\r\nvoid main() {\r\n  vVertexNormal = normalize(normalMatrix * normal);\r\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}",h="uniform vec3 glowColor;\r\nuniform float coeficient;\r\nuniform float power;\r\nvarying vec3 vVertexNormal;\r\nvarying vec3 vVertexWorldPosition;\r\nvarying vec4 vFragColor;\r\nvoid main() {\r\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\r\n  vec3 viewCameraToVertex = (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\r\n  viewCameraToVertex = normalize(viewCameraToVertex);\r\n  float intensity =\r\n      pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);\r\n  gl_FragColor = vec4(glowColor, intensity);\r\n}";const M=["geometry"],T=["blending","side"],V=["geometry"],b=["blending","side"],P=o({__name:"geometricGlowMesh",props:{geometry:Object,inColor:{default:"hotpink"},outColor:{default:"hotpink"},inPower:{default:1.4},outPower:{default:1.2},inCoeficient:{default:1.1},outCoeficient:{default:.1}},setup(e){const r=e,o=r.geometry.clone();y(o,.01);const m=r.geometry.clone();y(m,.2);const u={uniforms:{coeficient:{value:r.inCoeficient},power:{value:r.inPower},glowColor:{value:new g(r.inColor)},viewVector:{value:new f(0,0,1)}},vertexShader:x,fragmentShader:h},c={uniforms:{coeficient:{value:r.outCoeficient},power:{value:r.outPower},glowColor:{value:new g(r.outColor)},viewVector:{value:new f(0,0,1)}},vertexShader:x,fragmentShader:h};return t(()=>[r.inColor,r.outColor],([e,r])=>{u.uniforms.glowColor.value.set(e),c.uniforms.glowColor.value.set(r)}),t(()=>[r.inPower,r.outPower,r.inCoeficient,r.outCoeficient],([e,r,o,t])=>{u.uniforms.power.value=e,c.uniforms.power.value=r,u.uniforms.coeficient.value=o,c.uniforms.coeficient.value=t}),(e,r)=>(n(),i("TresGroup",null,[a("TresMesh",{geometry:s(o)},[a("TresShaderMaterial",l(u,{blending:p,transparent:"",depthWrite:!1,side:void 0}),null,16,T)],8,M),a("TresMesh",{geometry:s(m),visible:!0},[a("TresShaderMaterial",l(c,{blending:p,transparent:"",depthWrite:!1,side:w}),null,16,b)],8,V)]))}}),B=["geometry"],j=["geometry"],G=["geometry"],N=["geometry"],_=["geometry"],S=o({__name:"geometricGlow",setup(o){const t=new C(.75,.25,64),i=t.clone();y(i,-.1);const f=t.clone();y(f,.1);const g=m({inColor:"#0078ff",outColor:"#ff00ba",inPower:1.4,outPower:1.2,inCoeficient:1.1,outCoeficient:.1}),p=new r;return p.addBinding(g,"inColor",{label:"内发光色"}),p.addBinding(g,"inPower",{label:"内发光强度",step:.01,min:0,max:4}),p.addBinding(g,"inCoeficient",{step:.01,min:0,max:4}),p.addBinding(g,"outColor",{label:"外发光色"}),p.addBinding(g,"outPower",{label:"外发光强度",step:.01,min:0,max:6}),p.addBinding(g,"outCoeficient",{step:.01,min:0,max:4}),(r,o)=>{const m=u("TresCanvas");return n(),c(m,{"window-size":"",clearColor:"#333333"},{default:d(()=>[o[5]||(o[5]=a("TresPerspectiveCamera",{position:[5,5,5]},null,-1)),v(s(e)),a("TresMesh",{position:[0,1,-4],geometry:s(t)},[o[1]||(o[1]=a("TresMeshNormalMaterial",{transparent:"",opacity:.8},null,-1)),a("TresMesh",{geometry:s(i)},[...o[0]||(o[0]=[a("TresMeshBasicMaterial",{wireframe:"",color:"#000"},null,-1)])],8,j)],8,B),a("TresMesh",{position:[0,1,4],geometry:s(t)},[o[3]||(o[3]=a("TresMeshNormalMaterial",{transparent:"",opacity:.9},null,-1)),a("TresMesh",{geometry:s(f)},[...o[2]||(o[2]=[a("TresMeshBasicMaterial",{wireframe:"",color:"#000"},null,-1)])],8,N)],8,G),a("TresMesh",{position:[0,1,0],geometry:s(t),renderOrder:1},[o[4]||(o[4]=a("TresMeshBasicMaterial",{color:"gray"},null,-1)),v(P,l({geometry:s(t)},g),null,16,["geometry"])],8,_),o[6]||(o[6]=a("TresGridHelper",{args:[10,10]},null,-1))]),_:1})}}});export{S as default};
