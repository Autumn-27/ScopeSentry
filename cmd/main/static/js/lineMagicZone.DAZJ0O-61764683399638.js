import{P as e}from"./tweakpane.CqZAnw7f1764683399638.js";import{_ as t,o,K as n}from"./@tresjs.CJvYCGUA1764683399638.js";import{_ as a}from"./reflectorDUDV.vue_vue_type_script_setup_true_lang.u89pth7i1764683399638.js";import"./index.DM693cYN1764683399638.js";import{u as i}from"./useTexture.RJnyBWqC1764683399638.js";import{d as s,ac as r,ad as l,w as m,G as d,o as p,I as u,h as f,u as h,r as g,b as v,e as c,f as x,ah as I,m as j}from"./@vue.DjQnunkc1764683399638.js";import{ds as w,i as S,k as T,bJ as b,h as y}from"./three.BbguFgn81764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./dither.glsl.tNAdkJUa1764683399638.js";import"./Reflector.DiEbG3XV1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";const U=["rotateX"],N=["position","aIndex","aNormal"],_=s({__name:"lineMagicZone",props:{height:{default:1.6},speed:{default:1},color:{default:"#90ee90"}},async setup(e){let n,a;const s=r(),g=e,v=([n,a]=l(()=>i(["./plugins/basic/shine/image/round.png","./plugins/digitalCity/image/noise/noisePerlin.png"])),n=await n,a(),n),c=new w(0,0,8,8,0,2*Math.PI,!1,0),x=[];for(let t=0;t<5;t++)x.push(...c.getPoints(719)),c.xRadius+=.2,c.yRadius+=.2;const I=new Float32Array(x.map((e,t)=>t)),j=(new S).setFromPoints(x).getAttribute("position").array,_=new Float32Array(j.length);for(let t=0;t<j.length/3;t++){const e=3*t;j[e+1]+=.15*Math.floor(t/720);const o=t%720*3,n=3*(t%720+2880);_[e]=j[n]-j[o],_[e+1]=j[n+1]-j[o+1],_[e+2]=j[n+2]-j[o+2]}const P={uTime:{value:0},uScale:{value:s.scale?s.scale:1},uHeight:{value:g.height},uPerlinTexture:{value:v[1]},baseColor:{value:new T(g.color)}},{onRender:C}=t();return C(()=>{P.uTime.value+=.01*g.speed}),m(()=>[g.color,s.scale,g.height],([e,t,o])=>{P.baseColor.value.set(e),P.uScale.value=t,P.uHeight.value=o}),(e,t)=>(p(),d("TresGroup",null,[u("TresPoints",{rotateX:-Math.PI/2,scale:.1},[u("TresBufferGeometry",{position:[h(j),3],aIndex:[h(I),1],aNormal:[h(_),3]},null,8,N),f(h(o),{baseMaterial:y,vertexShader:"\nvarying vec2 vMapUv;\nattribute float aIndex;\nattribute vec3 aNormal;\nuniform float uTime;\nuniform float uScale;\nuniform float uHeight;\nuniform sampler2D uPerlinTexture;\nvarying float vIndex;\nvarying float vSelfIndex;\nvarying float vCircleNum;\nfloat getStrength(float aIndex, float uTime, vec3 aNormal) {\n    float selfIndex = mod(aIndex, 720.0);\n    float circleNum = (aIndex - selfIndex) / 720.0;\n    vec3 pDir = normalize(aNormal);\n    float waveWidth = 90.0;\n    float totalLength = 720.0;\n    float modUtime = mod(uTime * 50.0, 720.0);\n    float dw = waveWidth * 0.5;\n    float smoothStart = smoothstep(modUtime, modUtime + dw, selfIndex);\n    float smoothEnd = 1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex);\n    float strength = min(smoothStart, smoothEnd);\n    float isOver = step(720.0, modUtime + waveWidth);\n    float over = (modUtime + waveWidth - 720.0);\n    float isOverStep1 = (1.0 - step(dw, over)) * isOver;\n    float isOverStep2 = step(dw, over);\n    float overStep1Left = min(smoothstep(modUtime, modUtime + dw, selfIndex), (1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex)));\n    float overStep1Right = 1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex + 720.0);\n    float overStep1 = max(overStep1Left, overStep1Right);\n    float overStep2Left = smoothstep(modUtime, modUtime + dw, selfIndex);\n    float overStep2Right = min(smoothstep(modUtime, modUtime + dw, selfIndex + 720.0), (1.0 - smoothstep(modUtime + waveWidth - dw, modUtime + waveWidth, selfIndex + 720.0)));\n    float overStep2 = max(overStep2Left, overStep2Right);\n    float os = isOverStep1 * overStep1 + overStep2 * isOverStep2;\n    strength = (1.0 - isOver) * strength + isOver * os;\n    return strength;\n}\nvoid main() {\n\tvMapUv = uv;\n\tfloat selfIndex = mod(aIndex, 720.0);\n\tfloat circleNum = (aIndex - selfIndex) / 720.0;\n\tvec3 pDir = normalize(aNormal);\n\tfloat noise = texture(uPerlinTexture, vec2((selfIndex / 720.0), mod(uTime * 0.1, 1.0))).r;\n\tfloat strength = getStrength(aIndex, uTime, aNormal);\n\tstrength += getStrength(aIndex, uTime + 10.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 20.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 30.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 40.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 50.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 60.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 70.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 80.0 + noise, aNormal);\n\tstrength += getStrength(aIndex, uTime + 90.0 + noise, aNormal);\n\tcsm_Position.x += pDir.x * strength * 0.5;\n\tcsm_Position.z += strength * circleNum * noise * uHeight;\n\tcsm_Position.y += pDir.z * strength * 0.5;\n\tvIndex = aIndex;\n\tcsm_PointSize = 0.01*uScale;\n}\n",fragmentShader:"\nvarying vec2 vMapUv;\nvarying float vIndex;\nuniform float uTime;\nuniform vec3 baseColor;\nuniform sampler2D uPerlinTexture;\nvoid main() {\n\tvec3 whiteColor = vec3( 1.0,1.0,1.0);\n\tfloat selfIndex=mod(vIndex,720.0);\n\tfloat circleNum=(vIndex - selfIndex)/720.0;\n\tvec3 finalColor=mix(baseColor,diffuse,circleNum/5.0);\n\tfinalColor*=1.0;\n\tcsm_DiffuseColor = vec4( finalColor, opacity );\n}\n",uniforms:P,map:h(v)[0],alphaMap:h(v)[0],transparent:"",depthWrite:!1,blending:b,color:"#409eff",size:.1},null,8,["baseMaterial","map","alphaMap","blending"])],8,U)]))}}),P=s({__name:"lineMagicZone",setup(t){const o=g({reflectivity:.1,showGridHelper:!0,scale:1}),i=g({color:"#ff0000",scale:1.8,height:2.4,speed:1}),s=new e;return s.addBinding(i,"color",{label:"颜色"}),s.addBinding(i,"scale",{label:"大小",min:.1,max:3,step:.1}),s.addBinding(i,"height",{label:"高度",min:.1,max:3,step:.1}),s.addBinding(i,"speed",{label:"速度",min:-5,max:5,step:.1}),(e,t)=>{const s=v("TresCanvas");return p(),c(s,{clearColor:"#201919","window-size":"",antialias:"",alpha:"",logarithmicDepthBuffer:""},{default:x(()=>[t[0]||(t[0]=u("TresPerspectiveCamera",{position:[5,5,5],fov:45,near:.1,far:1e4},null,-1)),f(h(n),{enableDamping:""}),t[1]||(t[1]=u("TresAmbientLight",{intensity:2},null,-1)),(p(),c(I,null,{default:x(()=>[f(_,j({position:[3,0,0]},i),null,16)]),_:1})),(p(),c(I,null,{default:x(()=>[f(_,{position:[-3,0,0],scale:1.6,height:3})]),_:1})),f(a,j({position:[0,-.5,0]},o),null,16)]),_:1})}}});export{P as default};
