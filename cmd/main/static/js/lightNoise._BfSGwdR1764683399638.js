import{_ as e,F as n,K as t}from"./@tresjs.CJvYCGUA1764683399638.js";import{a4 as o,bb as a,b as r,H as l,aw as i,y as s,bk as c,i as v,ae as u,ao as m,J as f,a1 as d,bU as g,p,o as h,k as b,cT as x,cR as y,cS as T,d as w,dh as U,q as _,cC as S}from"./three.BbguFgn81764683399638.js";import{d as D,G as B,o as N,F as C,I as P,u as j,w as F,h as k,v as z,b as E,f as M,a9 as $,aa as A}from"./@vue.DjQnunkc1764683399638.js";import{_ as G}from"./@fesjs.CQdxRiFD1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";var R="float N21(vec2 st){\n\treturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\r\n}\r\nfloat smoothNoise(vec2 ip){\n\tvec2 lv=fract(ip);\r\n\tvec2 id=floor(ip);\r\n\t\r\n\tlv=lv*lv*(3.-2.*lv);\r\n\t\r\n\tfloat bl=N21(id);\r\n\tfloat br=N21(id+vec2(1,0));\r\n\tfloat b=mix(bl,br,lv.x);\r\n\t\r\n\tfloat tl=N21(id+vec2(0,1));\r\n\tfloat tr=N21(id+vec2(1,1));\r\n\tfloat t=mix(tl,tr,lv.x);\r\n\t\r\n\treturn clamp(mix(b,t,lv.y)*.5+.5,0.,1.);\r\n}\r\nfloat smoothNoise2(vec2 p){\r\n\tp.y+=time;\r\n\tp/=4.;\r\n\t\r\n\tfloat n=smoothNoise(p)*1.5;\r\n\tn+=smoothNoise(p*2.01)*.25;\r\n\tn+=smoothNoise(p*4.02)*.125;\r\n\tn+=smoothNoise(p*8.03)*.0625;\r\n\tn/=(1.5+.25+.125+.0625);\r\n\treturn clamp(n,0.,1.);\r\n}";const H=["geometry","material"],I=["material"],L=["rotateX"],V=100,q=D({__name:"lucesPlane",props:{globalUniforms:{}},setup(n){const t=n,v=[],u=[],m=new o(1,36,18),f=(new a).copy(m);f.instanceCount=V;const d=[];for(let e=0;e<V;e++){let e=r.randFloatSpread(49),n=r.randFloatSpread(49),t=r.randFloat(.0625,.125),o=r.randFloat(1,3);d.push(e,n,t),u.push(new l(e,n,o,r.randFloat(1,2))),v.push(new l(e,n,t,o))}f.setAttribute("instData",new i(new Float32Array(d),3));const g=new s({color:16720418,onBeforeCompile:e=>{e.uniforms.noiseTex=t.globalUniforms.noise,e.vertexShader=`\n      uniform sampler2D noiseTex;\n      attribute vec4 instData;\n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n      transformed = position * instData.z;\n      \n      transformed.x += instData.x;\n      transformed.z += instData.y;\n      vec2 nUv = (vec2(instData.x, -instData.y) - vec2(-25.)) / 50.;\n      float h = texture2D(noiseTex, nUv).g;\n      h = (h - 0.5) * 4.;\n      transformed.y += h;\n      ")}}),p={luces:{value:v}},h=new c({color:2363940,onBeforeCompile:e=>{e.uniforms.luces=p.luces,e.uniforms.globalBloom=t.globalUniforms.globalBloom,e.uniforms.noiseTex=t.globalUniforms.noise,e.vertexShader=`\n      uniform float time;\n      uniform sampler2D noiseTex;\n      varying vec3 vPos;\n      varying float intensity;\n      \n      //// https://discourse.threejs.org/t/calculating-vertex-normals-after-displacement-in-the-vertex-shader/16989/8 ///\n      \n      // the function which defines the displacement\n      float displace(vec2 vUv) {\n        return (texture2D(noiseTex, vUv).g - 0.5) * 4.;\n      }\n\n      vec3 getNormal(vec2 vUv){\n        vec3 displacedPosition = position + normal * displace(vUv);\n\n        float texelSize = 1.0 / 512.0; // temporarily hardcoding texture resolution\n        float offset = 0.1;\n\n        vec3 neighbour1 = position + vec3(1., 0., 0.) * offset;\n        vec3 neighbour2 = position + vec3(0., 0., 1.) * offset;\n        vec2 neighbour1uv = vUv + vec2(-texelSize, 0);\n        vec2 neighbour2uv = vUv  + vec2(0, -texelSize);\n        vec3 displacedNeighbour1 = neighbour1 + normal * displace(neighbour1uv);\n        vec3 displacedNeighbour2 = neighbour2 + normal * displace(neighbour2uv);\n\n        // https://i.ya-webdesign.com/images/vector-normals-tangent-16.png\n        vec3 displacedTangent = displacedNeighbour1 - displacedPosition;\n        vec3 displacedBitangent = displacedNeighbour2 - displacedPosition;\n\n        // https://upload.wikimedia.org/wikipedia/commons/d/d2/Right_hand_rule_cross_product.svg\n        vec3 displacedNormal = normalize(cross(displacedBitangent, displacedTangent));\n        return displacedNormal;\n      }\n      \n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n\n        float h = texture2D(noiseTex, uv).g;\n        intensity = h;\n        h = (h - 0.5) * 4.;\n        transformed.y = h;\n        vPos = transformed;\n        transformedNormal = normalMatrix * getNormal(uv);\n      "),e.fragmentShader=`\n      uniform vec4 luces[100];\n      uniform sampler2D noiseTex;\n      uniform float globalBloom;\n      varying vec3 vPos;\n      varying float intensity;\n\n      ${e.fragmentShader}\n    `.replace("#include <fog_fragment>","\n        vec3 col = vec3(1, 0, 0)*0.75;\n        float intensity = 0.;\n        for(int i = 0;i < 100; i++){\n          vec4 lux = luces[i];\n          vec2 luxUv = (vec2(lux.x, -lux.y) - vec2(-25.)) / 50.;\n          float h = texture2D(noiseTex, luxUv).g;\n          h = (h - 0.5) * 4.;\n          vec3 lightPos = vec3(lux.x, h, lux.y);\n          float currIntensity = smoothstep(lux.z + lux.w, lux.z, distance(vPos, lightPos));\n          intensity += pow(currIntensity, 16.);\n        }\n        intensity = clamp(intensity, 0., 1.);\n        col = mix(col * 0.5, col, intensity);\n        col = mix(gl_FragColor.rgb, col, intensity);\n        col += vec3(1) * intensity * 0.01;\n        gl_FragColor = vec4( col, opacity );\n        #include <fog_fragment>\n      ").replace("#include <dithering_fragment>","#include <dithering_fragment>\n        if (globalBloom > 0.5) {\n          gl_FragColor = vec4(0);\n        }\n      ")}}),{onBeforeRender:b}=e();return b(({elapsed:e})=>{for(let n=0;n<V;n++){const t=u[n];let o=(t.y+e+25)%50-25;v[n].y=o,v[n].w=(Math.sin(e*t.w*(n%3+1))*Math.cos(e*t.w*(n%5+1))*.25+.25)*t.z+.75*t.z,f.attributes.instData.setY(n,o)}f.attributes.instData.needsUpdate=!0}),(e,n)=>(N(),B(C,null,[P("TresMesh",{geometry:j(f),material:j(g)},null,8,H),P("TresMesh",{material:j(h)},[P("TresPlaneGeometry",{args:[50,50,500,500],rotateX:.5*-Math.PI},null,8,L)],8,I)],64))}}),W=["material"],X=D({__name:"portal",props:{globalUniforms:{}},setup(e){const n=e,t=new s({color:16737843,transparent:!0,onBeforeCompile:e=>{e.uniforms.time=n.globalUniforms.time,e.uniforms.globalBloom=n.globalUniforms.globalBloom,e.fragmentShader=`\n      #define S(a, b, t) smoothstep(a, b, t)\n      uniform float time;\n      uniform float globalBloom;\n      \n      ${R}\n      \n      float getTri(vec2 uv, float shift){\n        uv = uv * 2.-1.;\n        float a = atan(uv.x + shift,uv.y) + 3.1415926;\n        float r = 3.1415926 * 2./3.;\n        return cos(floor(.5+a/r)*r-a)*length(uv);\n      }\n      \n      float doubleTri(vec2 uv, float still, float width){\n        vec2 baseUv = uv;\n        vec2 e2 = fwidth(baseUv * 20.);\n        float e = min(e2.x, e2.y) * width;\n        float baseTri = getTri(baseUv, cos(baseUv.y * 31. + time) * sin(baseUv.y * 27. + time * 4.) * 0.025 * still);\n        float td = abs(fract(baseTri * 20.) - 0.5);\n        float tri = S(e, 0., td) - S(0., e, td);\n        tri *= step(0.4, baseTri) -  step(0.5, baseTri);\n        return tri;\n      }\n      \n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n        float tri = doubleTri(vUv, 0.0, 16.);\n        float triWave = doubleTri(vUv, 1.0, 8.);\n        float fullTri = max(tri, triWave);\n        \n        if (fullTri < 0.5) discard;\n        \n        vec3 col = mix(diffuse, vec3(0.75), fullTri);\n        \n        float blinking = smoothNoise(vec2(time, time * 5.));\n        blinking = blinking * 0.9 + 0.1;\n        \n        vec4 diffuseColor = vec4(col * blinking, fullTri);\n      ").replace("#include <dithering_fragment>","#include <dithering_fragment>\n        if (globalBloom > 0.5) {\n          gl_FragColor = vec4(gl_FragColor.rgb * 0.375, fullTri);\n        }\n      ")}});return t.defines={USE_UV:""},(e,n)=>(N(),B("TresMesh",{material:j(t),position:[0,3.75,-12]},[...n[0]||(n[0]=[P("TresPlaneGeometry",{args:[5,5]},null,-1)])],8,W))}}),J=["material","geometry"],K=D({__name:"drops",props:{globalUniforms:{}},setup(e){const n=e,t=[],o=[];for(let i=0;i<2e4;i++){const e=r.randFloatSpread(35),n=r.randFloat(-5,10),a=r.randFloatSpread(35),l=r.randFloat(.25,.5);t.push(e,n,a,e,n,a),o.push(0,l,1,l)}const a=new v;a.setAttribute("position",new u(t,3)),a.setAttribute("gEnds",new u(o,2));const l=new m({color:8930440,transparent:!0,onBeforeCompile:e=>{e.uniforms.time=n.globalUniforms.time,e.uniforms.noiseTex=n.globalUniforms.noise,e.uniforms.globalBloom=n.globalUniforms.globalBloom,e.vertexShader=`\n      uniform float time;\n      uniform sampler2D noiseTex;\n      attribute vec2 gEnds;\n      varying float vGEnds;\n      varying float vH;\n\n      ${e.vertexShader}\n    `.replace("#include <begin_vertex>","#include <begin_vertex>\n        \n      vec3 pos = position;\n      \n      vec2 nUv = (vec2(pos.x, -pos.z) - vec2(-25.)) / 50.;\n      float h = texture2D(noiseTex, nUv).g;\n      h = (h - 0.5) * 4.;\n      \n      pos.y = -mod(10. - (pos.y - time * 5.), 15.) + 10.;\n      h = pos.y - h;\n      pos.y += gEnds.x * gEnds.y;\n      transformed = pos;\n      vGEnds = gEnds.x;\n      vH = smoothstep(3., 0., h);\n      "),e.fragmentShader=`\n      uniform float time;\n      uniform float globalBloom;\n      varying float vGEnds;\n      varying float vH;\n      ${R}\n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n      float op = 1. - vGEnds;\n      op = pow(op, 3.);\n      float h = (pow(vH, 3.) * 0.5 + 0.5);\n      vec3 col = diffuse * h; // lighter close to the surface\n      col *= 1. + smoothstep(0.99, 1., h); // sparkle at the surface\n      if (globalBloom > 0.5) {\n        //col *= 0.5;\n      }\n      vec4 diffuseColor = vec4( col, op );\n      \n      ")}});return(e,n)=>(N(),B("TresLineSegments",{material:j(l),geometry:j(a)},null,8,J))}}),Y=D({__name:"fboRender",setup(t){const o={time:{value:0},globalBloom:{value:0},noise:{value:null}},a=new f(512,512),r=new d,l=new g,i=new p(2,2),c=new s({onBeforeCompile:e=>{e.uniforms.time=o.time,e.fragmentShader=`\n      uniform float time;\n      ${R}\n      ${e.fragmentShader}\n    `.replace("vec4 diffuseColor = vec4( diffuse, opacity );","\n        vec3 col = vec3(0);\n        float h = clamp(smoothNoise2(vUv * 50.), 0., 1.);\n        col = vec3(h);\n        vec4 diffuseColor = vec4( col, opacity );\n      ")}});c.defines={USE_UV:""};const v=new h(i,c);r.add(v),o.noise.value=a.texture;const{camera:u,renderer:m,scene:D,sizes:P,controls:j}=n();F(()=>j.value,e=>{e?.target.set(0,2,0),D.value.background||(D.value.background=new b(6706534))});const z=new x(m),E=new x(m),M=new y(D.value,u.value),$=new T(new w(P.width.value,P.height.value),1.2,.5,0);z.renderToScreen=!1,z.addPass(M),z.addPass($);const A=new U(new _({uniforms:{baseTexture:{value:null},bloomTexture:{value:z.renderTarget2.texture}},vertexShader:"\n\t\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\tvUv = uv;\n\t\t\t\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\t\t\t\t}",fragmentShader:"\n\t\t\t\t\t\t\t\tuniform sampler2D baseTexture;\n\t\t\t\t\t\t\t\tuniform sampler2D bloomTexture;\n\t\t\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\t\t\t\t\tgl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );\n\t\t\t\t\t\t\t\t}",defines:{}}),"baseTexture");A.needsSwap=!0,E.addPass(M),E.addPass(A),D.value.fog=new S(6706534,1,25);const{onBeforeRender:G}=e();return G(({elapsed:e})=>{o.time.value=e,m&&(m.setRenderTarget(a),m.render(r,l),m.setRenderTarget(null),o.globalBloom.value=1.2,D.value.fog.color.set(0),D.value.fog.near=15,D.value.background?.set(0),z.render(),o.globalBloom.value=0,D.value.fog.color.set(6706534),D.value.fog.near=10,D.value.background?.set(6706534),E.render())}),(e,n)=>(N(),B(C,null,[k(q,{globalUniforms:o}),k(X,{globalUniforms:o}),k(K,{globalUniforms:o})],64))}}),O={class:"text"};const Q=G({},[["render",function(e,n){return N(),B("div",O,[...n[0]||(n[0]=[P("span",{class:"retro noselect"},[P("span",{style:{color:"#eae"}},"光"),z("噪声")],-1)])])}],["__scopeId","data-v-fe776db1"]]),Z=D({__name:"lightNoise",setup(e){const n={windowSize:!0,antialias:!0,renderMode:"manual"},o={enableDamping:!0,minDistance:5,maxDistance:10,minPolarAngle:60*r.DEG2RAD,maxPolarAngle:90*r.DEG2RAD,makeDefault:!0};return(e,a)=>{const r=E("TresCanvas");return N(),B(C,null,[k(Q),k(r,$(A(n)),{default:M(()=>[a[0]||(a[0]=P("TresPerspectiveCamera",{position:[0,3,5],fov:45,near:.1,far:1e3},null,-1)),k(j(t),$(A(o)),null,16),a[1]||(a[1]=P("TresAmbientLight",{intensity:.5},null,-1)),a[2]||(a[2]=P("TresDirectionalLight",{position:[0,3,-12],intensity:1},null,-1)),k(Y)]),_:1},16)],64)}}});export{Z as default};
