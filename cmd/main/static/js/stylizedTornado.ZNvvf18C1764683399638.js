import{P as e}from"./tweakpane.CqZAnw7f1764683399638.js";import{i as r,l as o}from"./index.DM693cYN1764683399638.js";import"./@fesjs.CQdxRiFD1764683399638.js";import{b as n}from"./pagesShow.vue_vue_type_script_setup_true_lang.BJJ2kmGn1764683399638.js";import{_ as l}from"./@tresjs.CJvYCGUA1764683399638.js";import{d as a,w as t,G as i,o as s,a9 as f,aa as u,a as c,I as d,h as p,u as m,r as v,f as h,e as g,H as w,m as C,F as y}from"./@vue.DjQnunkc1764683399638.js";import{k as O,a6 as T,d as b}from"./three.BbguFgn81764683399638.js";import"./chalk.BHLFMujs1764683399638.js";/* empty css                                 */import"./iconify-icon.Dg3Wmqac1764683399638.js";import"./@iconify.Db0UMRdG1764683399638.js";import"./pinia.yp40krTn1764683399638.js";import"./vite-plugin-qiankun.B06WoCqG1764683399638.js";import"./vue-router.CW9J5iK31764683399638.js";import"./dompurify.C4MEnGDh1764683399638.js";import"./color.D_UQSrzA1764683399638.js";import"./color-string.cWrXb_cU1764683399638.js";import"./color-name.gyPnsvCn1764683399638.js";import"./lodash.OvYRBTRe1764683399638.js";import"./@amap.fjyZdsU91764683399638.js";import"./object-hash.C0HZ2EUZ1764683399638.js";import"./jszip.CqykFGTv1764683399638.js";import"./oimophysics.CfVKSiAm1764683399638.js";import"./three-stdlib.CqpxBIJB1764683399638.js";import"./@pmndrs.CRF-_adI1764683399638.js";import"./axios.Bl1IyXmH1764683399638.js";import"./lodash-es.DWe8oqPO1764683399638.js";import"./@qlin.y-0Z8WnK1764683399638.js";import"./@babel.BPq7uOAK1764683399638.js";import"./@floating-ui.Bhq4ibgf1764683399638.js";import"./@juggle.Vc7cP4_P1764683399638.js";import"./three-custom-shader-material.VhylcSiy1764683399638.js";import"./buildingsCustomShaderMaterial.C_BZxytV1764683399638.js";import"./postprocessing.DjqPXL_K1764683399638.js";import"./@vueuse.BBrxj3Xz1764683399638.js";const S=a({__name:"meshSpiralMaterial",props:{frontColor:{default:"#320564"},backColor:{default:"#ec22ff"},intensity:{default:1.5},powerOffset:{default:4},noiseCutOff:{default:.32},colorBoth:{type:Boolean,default:!1}},setup(e){const o=e,n=r.getItem("noiseVoronoi.png"),a={uniforms:{uTime:{value:0},uFrontColor:{value:new O(o.frontColor)},uBackColor:{value:new O(o.backColor).multiplyScalar(o.intensity)},uNoise:{value:n},uPowerOffset:{value:o.powerOffset},uNoiseCutOff:{value:o.noiseCutOff},uColorBoth:{value:o.colorBoth}},vertexShader:"out vec2 vUv;\n\nvoid main()\r\n{\r\n    \n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\r\n    \r\n}",fragmentShader:"uniform float uTime;\r\nuniform vec3 uFrontColor;\r\nuniform vec3 uBackColor;\r\nuniform sampler2D uNoise;\r\nuniform float uPowerOffset;\r\nuniform float uNoiseCutOff;\r\nuniform bool uColorBoth;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\r\n{\r\n    \n    switch( type )\r\n    {\r\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\r\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\r\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\r\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\r\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\r\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\r\n        break;\r\n    }\r\n}\r\nvec2 tileOffset( vec2 uv , vec2 tiling, vec2 offset )\r\n{\r\n    return  uv * tiling + offset;\r\n}\n\nvoid main()\r\n{\r\n    vec2 uv = vUv;\n\n    vec2 timeOffset = vec2( uTime * 0.6, 0.0 );\n\n    \n\n    \n    vec3 noiseVoronoi = texture( uNoise, uv ).rgb;\n\n    float uvCutOff = uv.y;\n\n    uvCutOff = smoothstep( 0.02, 1.0, uvCutOff + 0.2  );\n\n    \n    float noiseCutOff = pow( noiseVoronoi.r, uPowerOffset );\n\n    \n\n    \n    vec3 colorFront = uFrontColor;\r\n    colorFront *= noiseCutOff;\n\n    vec3 colorBack = uBackColor;\r\n    colorBack *= noiseCutOff;\n\n    \n    vec3 colorFinal = colorFront;\n\n    if( uColorBoth )\r\n    {\r\n        colorFinal = ( ( gl_FrontFacing ) ? colorFront : colorBack );\r\n    }\n\n    \n    clip( noiseCutOff, uNoiseCutOff, 0 );\n\n    gl_FragColor = vec4( colorFinal, noiseCutOff * uvCutOff );\r\n    \n\n    #include <tonemapping_fragment>\r\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:T,depthWrite:!0,depthTest:!0},{onBeforeRender:c}=l();return c(({delta:e})=>{a.uniforms.uTime.value+=e}),t(()=>[o.frontColor,o.backColor],([e,r])=>{a.uniforms.uFrontColor.value.setStyle(e),a.uniforms.uBackColor.value.setStyle(r).multiplyScalar(o.intensity)}),(e,r)=>(s(),i("TresShaderMaterial",f(u(a)),null,16))}}),j=["geometry"],x=a({__name:"highlightMiddle",props:{frontColor:{default:"#111111"},backColor:{default:"#ff810c"}},setup(e){const o=c(null),{nodes:n}=r.getItem("spiral-middle.glb"),{onBeforeRender:a}=l();return a(({delta:e,elapsed:r})=>{if(o.value){const n=3.4*r,l=.2*Math.sin(n)+.8;o.value.rotation.y+=6*e,o.value.scale.set(l,l,l)}}),(e,r)=>(s(),i("TresGroup",null,[d("TresMesh",{ref_key:"meshRef",ref:o,geometry:m(n).Cylinder.geometry,renderOrder:999991},[p(S,{frontColor:e.frontColor,backColor:e.backColor,intensity:2.7,powerOffset:12,colorBoth:""},null,8,["frontColor","backColor"])],8,j)]))}});const k=a({__name:"meshTornadoMaterial",props:{colorBase:{default:"#ff821c"},colorIntensity:{default:12},twirlAmount:{default:8},radialShearAmount:{default:new b(5,5)},twirlOffset:{default:new b(0,.5)},radialOffset:{default:new b(0,.5)},twirlCenter:{default:new b(.5,-.5)},radialCenter:{default:new b(.5,.5)},noisePower:{default:1},alphaThreshold:{default:.17},showEdge:{type:Boolean,default:!1}},setup(e){const r=e,o={uniforms:{uTime:{value:0},uColor:{value:new O(r.colorBase).multiplyScalar(r.colorIntensity)},uTwirl:{value:r.twirlAmount},uRadialShear:{value:r.radialShearAmount},uTwirlOffset:{value:r.twirlOffset},uRadialOffset:{value:r.radialOffset},uTwirlCenter:{value:r.twirlCenter},uRadialCenter:{value:r.radialCenter},uNoisePower:{value:r.noisePower},uAlphaThreshold:{value:r.alphaThreshold},uEdge:{value:r.showEdge}},vertexShader:"out vec2 vUv;\n\nvoid main()\r\n{\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    vUv = uv;\r\n}",fragmentShader:"uniform float uTime;\r\nuniform vec3 uColor;\r\nuniform float uTwirl;\r\nuniform vec2 uRadialShear;\r\nuniform vec2 uTwirlOffset;\r\nuniform vec2 uRadialOffset;\r\nuniform vec2 uTwirlCenter;\r\nuniform vec2 uRadialCenter;\r\nuniform float uNoisePower;\r\nuniform float uAlphaThreshold;\r\nuniform bool uEdge;\n\nin vec2 vUv;\n\nvoid clip( float clipValue, float alphaThreshold, int type )\r\n{\r\n    \n    switch( type )\r\n    {\r\n        case 0: \n            if( clipValue < alphaThreshold ) discard;\r\n        break;\n\n        case 1: \n            if( clipValue > alphaThreshold ) discard;\r\n        break;\n\n        case 2: \n            if( clipValue <= alphaThreshold ) discard;\r\n        break;\n\n        case 3: \n            if( clipValue >= alphaThreshold ) discard;\r\n        break;\n\n        case 4: \n            if( clipValue == alphaThreshold ) discard;\r\n        break;\n\n        default: \n            if( clipValue < alphaThreshold ) discard;\r\n        break;\r\n    }\r\n}\r\nvec2 twirl(vec2 uv, vec2 center, float strength, vec2 offset)\r\n{\r\n    vec2 delta = uv - center;\r\n    float angle = strength * length(delta);\r\n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\r\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\r\n    return vec2(x + center.x + offset.x, y + center.y + offset.y);\r\n}\r\nvec2 radialShear( vec2 uv, vec2 center, float strength, vec2 offset )\r\n{\r\n    vec2 delta = uv - center;\r\n    float delta2 = dot( delta.xy, delta.xy );\n\n    float deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\r\n}\n\nvec2 radialShear( vec2 uv, vec2 center, vec2 strength, vec2 offset )\r\n{\r\n    vec2 delta = uv - center;\r\n    vec2 delta2 =  vec2( dot( delta.xy, delta.xy ) );\n\n    vec2 deltaOffset = delta2 * strength;\n\n    return uv + vec2( delta.y, -delta.x) * deltaOffset + offset;\r\n}\r\nfloat randomSimple(vec2 n) { \r\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\r\n}\n\nfloat interpolate( float a, float b, float t )\r\n{\r\n    return ( 1.0 - t ) * a + ( t * b );\r\n}\n\nfloat valueNoise( vec2 uv )\r\n{\r\n    vec2 i = floor( uv );\r\n    vec2 f = fract( uv );\r\n    f = f * f * ( 3.0 - 2.0 * f );\n\n    uv = abs( fract( uv ) - 0.5 );\r\n    vec2 c0 = i + vec2(0.0, 0.0);\r\n    vec2 c1 = i + vec2(1.0, 0.0);\r\n    vec2 c2 = i + vec2(0.0, 1.0);\r\n    vec2 c3 = i + vec2(1.0, 1.0);\r\n    float r0 = randomSimple(c0);\r\n    float r1 = randomSimple(c1);\r\n    float r2 = randomSimple(c2);\r\n    float r3 = randomSimple(c3);\n\n    float bottomOfGrid = interpolate(r0, r1, f.x);\r\n    float topOfGrid = interpolate(r2, r3, f.x);\r\n    float t = interpolate(bottomOfGrid, topOfGrid, f.y);\r\n    return t;\r\n}\n\nfloat noiseSimple( vec2 UV, float Scale )\r\n{\r\n    float t = 0.0;\n\n    float freq = pow(2.0, float(0));\r\n    float amp = pow(0.5, float(3-0));\r\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(1));\r\n    amp = pow(0.5, float(3-1));\r\n    t += valueNoise(vec2(UV.x*Scale/freq, UV.y*Scale/freq))*amp;\n\n    freq = pow(2.0, float(2));\r\n    amp = pow(0.5, float(3-2));\r\n    t += valueNoise(vec2(UV.x * Scale / freq, UV.y * Scale / freq ) ) * amp;\n\n    return t;\r\n}\r\nfloat remap( float value, float min1, float max1, float min2, float max2 ) \r\n{\r\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n}\n\nvoid main()\r\n{\n\n    vec2 uv = vUv;\r\n    float time = uTime;\n\n    vec2 twirlOffset = vec2( time * uTwirlOffset.x, time * uTwirlOffset.y );\r\n    vec2 radialOffset = vec2( time * uRadialOffset.x, time * uRadialOffset.y );\n\n    float uvCutOff = uv.y;\r\n    uvCutOff = smoothstep( 0.2, 1.0, uvCutOff + 0.2 );\r\n\n    vec2 uvRadial = radialShear( uv, uRadialCenter, uRadialShear, radialOffset );\r\n    vec2 uvTwirl = twirl( uv, uTwirlCenter, uTwirl, twirlOffset );\n\n    float noiseRadial = noiseSimple( uvRadial, 20.0 );\r\n    float noiseTwirl = noiseSimple( uvTwirl, 20.0 );\n\n    float noise = noiseRadial * noiseTwirl;\n\n    noise = pow( noise, uNoisePower );\n\n    float dissolve = remap( noise, 0.0, 1.0, 1.0, 0.0 );\n\n    vec3 colorFinal = uColor;\r\n    colorFinal *= noise;\n\n    clip( noise, uAlphaThreshold, 0 );\n\n    vec4 color = vec4( colorFinal, dissolve );\n\n    if( uEdge )\r\n    {\r\n        color.a *= uvCutOff;\r\n    }\n\n    gl_FragColor = color;\r\n    #include <tonemapping_fragment>\r\n    #include <colorspace_fragment>\n\n}",transparent:!0,side:T,depthWrite:!0,depthTest:!0},{onBeforeRender:n}=l();return n(({delta:e})=>{o.uniforms.uTime.value+=e}),t(()=>r.colorBase,e=>{o.uniforms.uColor.value.setStyle(e).multiplyScalar(r.colorIntensity)}),(e,r)=>(s(),i("TresShaderMaterial",f(u(o)),null,16))}}),_=["geometry"],B=a({__name:"tornadoOutter",props:{color:{default:"#ff5400"}},setup(e){const{nodes:o}=r.getItem("tornado.glb");return(e,r)=>(s(),i("TresMesh",{geometry:m(o).tornado.geometry},[p(k,{colorBase:e.color,colorIntensity:2,twirlAmount:6,radialShearAmount:new b(.9,.9),twirlCenter:new b(.5,-.52),twirlOffset:new b(-.5,-.25),radialOffset:new b(-.5,.5),alphaThreshold:.18,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,_))}}),V=["geometry"],F=a({__name:"tornado",props:{color:{default:"#ff5400"}},setup(e){const{nodes:o}=r.getItem("tornado.glb");return(e,r)=>(s(),i("TresMesh",{geometry:m(o).tornado.geometry},[p(k,{colorBase:e.color,colorIntensity:13,twirlAmount:8,radialShearAmount:new b(.7,.7),twirlCenter:new b(.5,-.52),twirlOffset:new b(-1,-.5),radialOffset:new b(-1,.5),alphaThreshold:.23,showEdge:!1},null,8,["colorBase","radialShearAmount","twirlCenter","twirlOffset","radialOffset"])],8,V))}}),R=["geometry"],A=a({__name:"tornadoInner",props:{color:{default:"#ff5400"}},setup(e){const{nodes:o}=r.getItem("tornado.glb");return(e,r)=>(s(),i("TresMesh",{geometry:m(o).tornado.geometry},[p(k,{colorBase:e.color,colorIntensity:8,radialShearAmount:new b(.7,.7),alphaThreshold:.17,showEdge:!0},null,8,["colorBase","radialShearAmount"])],8,R))}}),M=a({__name:"experience",props:{color0:{default:"#111111"},color1:{default:"#ff810c"},color2:{default:"#3a3a3a"},color3:{default:"#ff821c"},color4:{default:"#ff5400"}},setup:e=>(e,r)=>(s(),i("TresGroup",null,[p(x,{scale:[1.1,4.6,1.1],position:[0,-2,0],frontColor:e.color0,backColor:e.color1},null,8,["frontColor","backColor"]),p(B,{scale:[.6,.4,.6],position:[0,-2.5,0],renderOrder:999992,color:e.color2},null,8,["color"]),p(F,{scale:[.44,.4,.44],position:[0,-2.5,0],renderOrder:999993,color:e.color3},null,8,["color"]),p(A,{scale:.4,position:[0,-2.5,0],renderOrder:999994,color:e.color4},null,8,["color"])]))}),N=a({__name:"stylizedTornado",setup(l){r.loadResources([{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/spiral-middle.glb"},{functionName:"GLTFLoader",url:"./plugins/digitalCity/model/tornado.glb"},{functionName:"TextureLoader",url:"./plugins/digitalCity/image/noise/noiseVoronoi.png"}]);const a=new e({title:"龙卷风参数",expanded:!0}),t=v({color0:"#111111",color1:"#ff810c",color2:"#3a3a3a",color3:"#ff821c",color4:"#ff1800"});return a.addBinding(t,"color0",{label:"颜色0"}),a.addBinding(t,"color1",{label:"颜色1"}),a.addBinding(t,"color2",{label:"颜色2"}),a.addBinding(t,"color3",{label:"颜色3"}),a.addBinding(t,"color4",{label:"颜色4"}),(e,l)=>(s(),i(y,null,[p(m(o),{useResourceManager:""}),p(n,{showAxesHelper:!1},{ability:h(()=>[m(r).hasAllFinished.value?(s(),g(M,C({key:0,position:[10,280,0],scale:100},t),null,16)):w("",!0)]),_:1})],64))}});export{N as default};
